<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>x86汇编03-1:内存</title>
    
    <link rel="stylesheet" href="../style.css">
    
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="x86%E6%B1%87%E7%BC%9603-1%E5%86%85%E5%AD%98">x86汇编03-1:内存</h1>
                <h3 id="1-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><strong>1. 逻辑地址</strong></h3>
                <p>我们故事的起点是Intel 8086处理器。它的寄存器、ALU都是16位的，这意味着它一次最擅长处理16位的数字。如果直接用一个16位寄存器来寻址，它能访问的内存空间是多少？$2^{16}$ 字节，也就是65536字节，仅仅64KB。在1978年，这已经捉襟见肘。</p>
                <p><strong>设计的核心矛盾：</strong></p>
                <ul>
                <li><strong>内部能力：</strong> CPU是16位架构，寄存器只有16位宽。</li>
                <li><strong>外部需求：</strong> 需要访问比64KB大得多的内存空间。事实上，8086的物理地址总线有20位，能访问 $2^{20}$ 字节，即1MB的内存。</li>
                </ul>
                <p><strong>如何用16位的“尺子”去度量20位的“空间”？</strong></p>
                <p>这就是x86体系结构历史上最重要，也最具争议的设计决策——<strong>分段式内存管理（Segmented Memory）</strong>。Intel的工程师们没有选择彻底革新架构（那样成本太高且不兼容），而是设计了一种“双指针”方案。</p>
                <p>这个方案的核心是<strong>逻辑地址（Logical Address）</strong>，它由两部分组成：</p>
                <ol>
                <li><strong>段地址 (Segment Address)</strong>: 一个16位的值，它指向一个64KB大小内存块的<strong>基址</strong>。</li>
                <li><strong>偏移地址 (Offset Address)</strong>: 另一个16位的值，它表示目标内存在这个64KB段内的<strong>具体位置</strong>。</li>
                </ol>
                <p>我们通常将逻辑地址写作 <code>段地址:偏移地址</code>，例如 <code>2000h:1234h</code>。</p>
                <p><strong>那么，这个逻辑地址如何映射到20位的物理地址呢？</strong></p>
                <p>公式如下：
                <strong>物理地址 (Physical Address) = 段地址 $\times$ 16 + 偏移地址</strong></p>
                <p>用 $\LaTeX$ 表示就是：
                $$PhysicalAddress = SegmentValue \times 16_{10} + OffsetValue$$</p>
                <p>其中，乘以16在二进制中等价于<strong>左移4位</strong>。这是一个硬件可以瞬间完成的操作。</p>
                <p>$$PhysicalAddress_{20bit} = (SegmentValue_{16bit} \ll 4) + OffsetValue_{16bit}$$</p>
                <p><strong>让我们来看一个例子：</strong>
                计算逻辑地址 <code>2F00h:0158h</code> 对应的物理地址。</p>
                <ol>
                <li>取段地址 <code>2F00h</code>，左移4位（相当于末尾加一个0）：<code>2F000h</code>。</li>
                <li>加上偏移地址 <code>0158h</code>。<pre class="hljs"><code><div>  2F000h
                +  0158h
                ----------
                  2F158h
                </div></code></pre>
                </li>
                <li>所以，物理地址是 <code>2F158h</code>。</li>
                </ol>
                <p><strong>设计的哲学与评价：</strong></p>
                <ul>
                <li>
                <p><strong>优点：</strong></p>
                <ul>
                <li><strong>解决了寻址范围问题</strong>：用两个16位寄存器成功生成了20位地址，实现了1MB寻址。</li>
                <li><strong>向后兼容</strong>：对于那些只需要64KB内存的旧程序，只需固定段地址，就可以像以前一样只操作偏移地址。</li>
                <li><strong>内存保护的雏形</strong>：通过为代码、数据、堆栈分配不同的段，可以提供最基础的内存隔离。</li>
                </ul>
                </li>
                <li>
                <p><strong>缺点：</strong></p>
                <ul>
                <li><strong>复杂性</strong>：程序员必须同时管理段和偏移，心智负担加重。</li>
                <li><strong>地址不唯一</strong>：同一个物理地址可以由多个不同的逻辑地址表示。例如：
                <ul>
                <li><code>2F00h:0158h</code> -&gt; <code>2F158h</code></li>
                <li><code>2F15h:0008h</code> -&gt; <code>2F150h + 0008h</code> -&gt; <code>2F158h</code></li>
                <li><code>2E00h:1158h</code> -&gt; <code>2E000h + 1158h</code> -&gt; <code>2F158h</code>
                这给编程带来了混乱。</li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
                <h3 id="2-%E5%B0%8F%E7%AB%AF%E8%A7%84%E5%88%99-little-endian-byte-order"><strong>2. 小端规则 (Little-Endian Byte Order)</strong></h3>
                <p>在我们讨论如何在内存中存取数据之前，必须先解决一个基本问题：当一个多字节数据（如一个16位的<code>WORD</code>或32位的<code>DWORD</code>）要存入以字节为单位编址的内存时，是高位字节在前还是低位字节在前？</p>
                <p>这存在两种设计流派：</p>
                <ol>
                <li><strong>大端 (Big-Endian)</strong>: “所见即所得”，高位字节存储在低地址，低位字节存储在高地址。符合人类的阅读习惯。例如，<code>0x12345678</code> 存放在地址 <code>0x100</code>，则 <code>[0x100]=0x12</code>, <code>[0x101]=0x34</code>...</li>
                <li><strong>小端 (Little-Endian)</strong>: “反着存”，低位字节存储在低地址，高位字节存储在高地址。这是<strong>Intel x86架构的选择</strong>。</li>
                </ol>
                <p><strong>为什么Intel选择小端？</strong>
                这并非一个随意的决定，而是基于硬件效率的考量。
                假设你要从内存读取一个32位的<code>DWORD</code>到<code>EAX</code>寄存器，然后再单独使用它的低16位<code>AX</code>或低8位<code>AL</code>。在小端模式下，这个<code>DWORD</code>的地址就是它的最低字节的地址。CPU读取<code>AL</code>或<code>AX</code>时，不需要进行任何地址计算，直接使用原始地址即可。这简化了CPU内部的电路设计，并带来微小的性能优势。</p>
                <p><strong>示例：</strong>
                将 <code>DWORD</code> 值 <code>0x12345678</code> 存入以 <code>0x1000</code> 开始的内存地址：</p>
                <pre class="hljs"><code><div>         内存地址
                       +----------+
                0x1003 |    12    |  &lt;-- 最高有效字节 (MSB)
                       +----------+
                0x1002 |    34    |
                       +----------+
                0x1001 |    56    |
                       +----------+
                0x1000 |    78    |  &lt;-- 最低有效字节 (LSB)
                       +----------+
                </div></code></pre>
                <p>作为汇编程序员，你必须时刻牢记小端规则，尤其是在调试、查看内存时，否则你会对看到的数据感到困惑。</p>
                <h3 id="3-%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E5%92%8C%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-direct-and-indirect-addressing"><strong>3. 直接寻址和间接寻址 (Direct and Indirect Addressing)</strong></h3>
                <p>现在我们知道了地址的计算方式和数据的存储格式，那么在指令中如何指定一个内存地址呢？</p>
                <ul>
                <li>
                <p><strong>直接寻址 (Direct Addressing)</strong>
                偏移地址是一个<strong>常量</strong>，直接编码在指令中。这通常用于访问静态分配的全局变量。</p>
                <pre class="hljs"><code><div>.data
                    myVar dw 1234h ; 在数据段定义一个字变量
                .code
                    mov ax, [myVar] ; 将myVar的值加载到ax
                    ; 汇编器会将其转换为类似 mov ax, [0x100] 的指令
                    ; 偏移地址0x100是固定的
                </div></code></pre>
                <p>优点是简单明了，缺点是缺乏灵活性，因为地址在编译时就已固定。</p>
                </li>
                <li>
                <p><strong>间接寻址 (Indirect Addressing)</strong>
                偏移地址存储在<strong>寄存器</strong>中。这是汇编语言强大功能的体现，是实现指针、数组遍历、动态数据结构的基础。</p>
                <pre class="hljs"><code><div>mov bx, offset myVar ; 将myVar的偏移地址放入bx寄存器
                mov ax, [bx]         ; 通过bx寄存器间接访问myVar
                                     ; ax的值现在是1234h

                add bx, 2            ; 让bx指向下一个字 (地址+2)
                mov [bx], 5678h      ; 向新的地址写入数据
                </div></code></pre>
                <p>这里，<code>[bx]</code> 的含义是：“取出bx寄存器中的值，把它当作一个内存地址，然后去那个地址进行读写操作”。</p>
                </li>
                </ul>
                <h3 id="4-%E7%BC%BA%E7%9C%81%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%92%8C%E6%AE%B5%E8%A6%86%E7%9B%96-default-segments-and-segment-override"><strong>4. 缺省段地址和段覆盖 (Default Segments and Segment Override)</strong></h3>
                <p>每次内存访问都要写成 <code>段:偏移</code> 的形式，比如 <code>mov ax, ds:[bx]</code>，这太繁琐了。CPU设计者为此引入了<strong>缺省段</strong>（Default Segments）规则，简化编程。</p>
                <p><strong>规则:</strong>
                CPU根据指令的类型和使用的寄存器，自动选择一个默认的段寄存器。</p>
                <ul>
                <li><strong>代码获取</strong>: 总是使用 <strong>CS</strong> (Code Segment)。CPU取下一条指令时，隐式地使用 <code>CS:IP</code>。</li>
                <li><strong>堆栈操作</strong> (<code>PUSH</code>, <code>POP</code>, <code>CALL</code>, <code>RET</code>): 总是使用 <strong>SS</strong> (Stack Segment)。堆栈指针 <code>SP</code> 或 <code>BP</code> 相关的访问默认段是 <code>SS</code>。</li>
                <li><strong>数据访问</strong>: 大多数情况使用 <strong>DS</strong> (Data Segment)。当使用 <code>AX, BX, CX, DX, SI, DI</code> 等寄存器进行间接寻址时，默认段是 <code>DS</code>。</li>
                <li><strong>字符串操作目标地址</strong>: 某些字符串指令（如<code>STOS</code>）的目的操作数默认使用 <strong>ES</strong> (Extra Segment)。</li>
                </ul>
                <p><strong>段覆盖 (Segment Override)</strong>:
                当然，这些只是默认规则。如果你需要访问其他段的数据，可以使用<strong>段覆盖前缀</strong>来显式指定。</p>
                <pre class="hljs"><code><div>mov ax, [bx]          ; 默认从DS段读取, 相当于 mov ax, ds:[bx]
                mov ax, es:[bx]       ; 使用段覆盖前缀, 强制从ES段读取
                mov ax, ss:[bx]       ; 强制从SS段读取
                mov ax, cs:[bx]       ; 强制从CS段读取
                </div></code></pre>
                <p><strong>注意：</strong> CS 通常是只读的，不能作为大多数写入指令的目的段。SS 的修改需要特别小心，否则会造成堆栈崩溃。</p>
                <h3 id="5-1m%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E5%92%8C%E6%98%BE%E5%8D%A1%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84-a-case-study"><strong>5. 1M内存空间划分和显卡地址映射 (A Case Study)</strong></h3>
                <p>让我们把前面的知识应用到经典的PC内存布局中。这1MB的空间并不是一块统一的RAM。</p>
                <p><strong>1M内存空间划分:</strong></p>
                <pre class="hljs"><code><div>+------------------+ 0xFFFFF (1MB - 1)
                |  ROM BIOS        |
                +------------------+ 0xF0000
                |  扩展 ROM         |
                +------------------+ 0xC8000
                |  显卡 ROM BIOS    |
                +------------------+ 0xC0000
                |  显存区域 (Video RAM) |
                +------------------+ 0xA0000
                |                  |
                |  常规内存 (RAM)  |
                |  (给DOS和程序用) |
                |                  |
                +------------------+ 0x00500
                |  BIOS 数据区      |
                +------------------+ 0x00400
                |  中断向量表      |
                +------------------+ 0x00000
                </div></code></pre>
                <ul>
                <li><strong>0x00000 - 0x003FF</strong>: 中断向量表 (IVT)。存放中断服务程序的地址。</li>
                <li><strong>0x00400 - 0x004FF</strong>: BIOS数据区 (BDA)。存放硬件状态信息。</li>
                <li><strong>... - 0x9FFFF</strong>: 常规内存 (Conventional Memory)。这是用户程序能自由使用的主要RAM区域，最大为640KB。这就是著名的“640KB内存限制”的由来。</li>
                <li><strong>0xA0000 - 0xBFFFF</strong>: <strong>显存映射区 (Video Memory)</strong>。这是关键！</li>
                <li><strong>0xC0000 - 0xFFFFF</strong>: BIOS ROM和其他硬件的ROM。存放固化代码。</li>
                </ul>
                <p><strong>显卡地址映射 (Memory-Mapped I/O):</strong>
                在早期的PC中，要让屏幕显示字符，并不是调用一个复杂的API。而是通过一种叫做<strong>内存映射I/O (Memory-Mapped I/O, MMIO)</strong> 的技术。
                显卡控制器会监听地址总线。当CPU访问特定地址范围（如 <code>0xB8000</code> 开始的区域）时，物理RAM不会响应，而是显卡会“认领”这个地址，并将CPU写入的数据接收到它自己的显存中。</p>
                <ul>
                <li>
                <p><strong>文本模式显存</strong>:</p>
                <ul>
                <li>物理地址从 <code>0xB8000</code> 开始。</li>
                <li>逻辑地址可以是 <code>B800h:0000</code>。</li>
                <li>屏幕上每个字符位置对应显存中的<strong>2个字节</strong>。
                <ul>
                <li><strong>第1字节</strong>: 字符的ASCII码。</li>
                <li><strong>第2字节</strong>: 字符的属性（前景色、背景色、是否闪烁等）。</li>
                </ul>
                </li>
                </ul>
                <p>例如，要在屏幕左上角（第0行，第0列）显示一个白底红字的 'A'：</p>
                <pre class="hljs"><code><div>mov ax, 0B800h
                mov es, ax             ; 将ES指向文本显存段
                mov byte ptr es:[0], 'A'  ; 写入字符 'A' 的 ASCII 码
                mov byte ptr es:[1], 01110100b ; 写入属性: 白底(0111)红字(0100)
                </div></code></pre>
                <p>执行这两条指令后，屏幕左上角会立即出现一个红色的'A'。这就是汇编语言直接操控硬件的魅力所在。</p>
                </li>
                </ul>
                <h3 id="6-%E5%AE%BD%E5%BA%A6%E4%BF%AE%E9%A5%B0%E4%B8%8E%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8-type-safety-in-assembly"><strong>6. 宽度修饰与变量引用 (Type Safety in Assembly)</strong></h3>
                <p>考虑指令 <code>mov [bx], 5</code>。CPU应该写入一个字节(BYTE)、一个字(WORD)还是一个双字(DWORD)？指令本身没有提供这个信息，这会造成歧义。</p>
                <p>汇编器提供了两种方式解决这个问题：</p>
                <ol>
                <li>
                <p><strong>变量引用 (Variable Reference)</strong>
                如果你的内存操作数是一个已经定义好类型的变量，汇编器会根据变量的定义自动确定操作宽度。</p>
                <pre class="hljs"><code><div>.data
                    myByte  db ?  ; 定义一个字节
                    myWord  dw ?  ; 定义一个字
                .code
                    mov [myByte], 5 ; 汇编器知道这是一个字节操作
                    mov [myWord], 5 ; 汇编器知道这是一个字操作
                </div></code></pre>
                </li>
                <li>
                <p><strong>宽度修饰符 (Size Specifier)</strong>
                当操作数没有明确类型时（如 <code>[bx]</code>），你必须<strong>显式</strong>地告诉汇编器操作的宽度。这通过 <code>PTR</code> 操作符完成。</p>
                <pre class="hljs"><code><div>mov BYTE PTR [bx], 5  ; 明确写入一个字节 (8位)
                mov WORD PTR [bx], 5  ; 明确写入一个字 (16位)
                mov DWORD PTR [bx], 5 ; 明确写入一个双字 (32位, 在386+处理器)
                </div></code></pre>
                <p><strong>忘记宽度修饰符是新手在汇编编程中最常犯的错误之一。</strong></p>
                </li>
                </ol>
            </article>
        </main>
    </div>
    
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
</body>
</html>