<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>计算机图形学06:几何变换</title>
    <link rel="stylesheet" href="../style.css">
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A606%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2">计算机图形学06:几何变换</h1>
                <h3 id="%E5%BC%95%E8%A8%80%E5%8F%98%E6%8D%A2%E5%8D%B3%E4%B8%80%E5%88%87"><strong>引言：变换即一切</strong></h3>
                <p>在计算机图形学中，<strong>变换</strong>无处不在。它至少有两种核心应用场景：</p>
                <ol>
                <li><strong>改变物体：</strong> 对模型本身进行操作，改变它的大小、位置和朝向，例如，让一架飞机在场景中飞行。</li>
                <li><strong>改变坐标系：</strong> 物体不动，而是移动和旋转我们观察它的“尺子”——坐标系。这在处理复杂的场景图和相机视图时至关重要。</li>
                </ol>
                <p>幸运的是，由于所有三维模型最终都是由一系列<strong>顶点</strong>构成的，我们只需要学会如何变换一个点，就能变换整个世界。</p>
                <h3 id="1-%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BA%8C%E7%BB%B4%E4%B8%89%E7%BB%B4%E5%8F%98%E6%8D%A2"><strong>1. 基本的二维/三维变换</strong></h3>
                <p>我们先来了解几种最基础的变换类型。</p>
                <h4 id="11-%E5%B9%B3%E7%A7%BB-translation"><strong>1.1 平移 (Translation)</strong></h4>
                <ul>
                <li><strong>目的：</strong> 移动物体的位置。</li>
                <li><strong>描述：</strong> 将物体上的每个点 $(x, y, z)$ 沿着一个平移向量 $\mathbf{T} = (T_x, T_y, T_z)$ 进行移动。</li>
                <li><strong>数学形式：</strong>
                $x' = x + T_x$
                $y' = y + T_y$
                $z' = z + T_z$</li>
                <li><strong>属性：</strong> 平移是一种<strong>刚体变换 (Rigid Body Transformation)</strong>，因为它只改变位置，不改变物体的形状、大小或朝向。</li>
                </ul>
                <h4 id="12-%E7%BC%A9%E6%94%BE-scaling"><strong>1.2 缩放 (Scaling)</strong></h4>
                <ul>
                <li><strong>目的：</strong> 改变物体的大小。</li>
                <li><strong>描述：</strong> 将物体上的每个点 $(x, y, z)$ 相对于<strong>坐标原点</strong>，在各个坐标轴方向上乘以一个缩放因子 $(S_x, S_y, S_z)$。</li>
                <li><strong>数学形式：</strong>
                $x' = x \cdot S_x$
                $y' = y \cdot S_y$
                $z' = z \cdot S_z$</li>
                <li><strong>属性：</strong>
                <ul>
                <li>如果 $S_x = S_y = S_z$，则为<strong>统一缩放 (Uniform Scaling)</strong>，物体保持原有比例。</li>
                <li>否则为<strong>非统一缩放 (Non-uniform Scaling)</strong>，物体会被拉伸或压缩，导致形状改变。</li>
                <li><strong>关键点：</strong> 标准的缩放操作是<strong>相对于原点</strong>进行的。如果一个物体不在原点，对其进行缩放不仅会改变它的大小，还会同时改变它的位置！</li>
                </ul>
                </li>
                </ul>
                <h4 id="13-%E6%97%8B%E8%BD%AC-rotation"><strong>1.3 旋转 (Rotation)</strong></h4>
                <ul>
                <li><strong>目的：</strong> 改变物体的朝向。</li>
                <li><strong>描述：</strong> 将物体上的每个点 $(x, y, z)$ 围绕<strong>某个旋转轴</strong>旋转一定的角度 $\theta$。</li>
                <li><strong>数学形式 (以围绕Z轴旋转为例):</strong>
                $x' = x \cos\theta - y \sin\theta$
                $y' = x \sin\theta + y \cos\theta$
                $z' = z$</li>
                <li><strong>属性：</strong> 旋转也是一种<strong>刚体变换</strong>。</li>
                <li><strong>关键点：</strong> 与缩放类似，标准的旋转操作也是**相对于原点（或某个坐标轴）**进行的。</li>
                </ul>
                <h3 id="2-%E7%BB%9F%E4%B8%80%E7%9A%84%E8%AF%AD%E8%A8%80%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><strong>2. 统一的语言：矩阵表示法</strong></h3>
                <p>我们有三种不同的基本变换，它们的数学形式各不相同：平移是加法，缩放和旋转是乘法。这给处理带来了不便。我们能否找到一种统一的方式来表示所有这些变换呢？答案是<strong>矩阵</strong>。</p>
                <ul>
                <li>
                <p><strong>缩放矩阵 $S(S_x, S_y, S_z)$:</strong>
                $$\begin{pmatrix} x' \\ y' \\ z' \end{pmatrix} = \begin{pmatrix} S_x & 0 & 0 \\ 0 & S_y & 0 \\ 0 & 0 & S_z \end{pmatrix} \begin{pmatrix} x \\ y \\ z \end{pmatrix}$$</p>
                </li>
                <li>
                <p><strong>旋转矩阵 $R_z(\theta)$ (绕Z轴):</strong>
                $$\begin{pmatrix} x' \\ y' \\ z' \end{pmatrix} = \begin{pmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{pmatrix} \begin{pmatrix} x \\ y \\ z \end{pmatrix}$$</p>
                </li>
                </ul>
                <p>缩放和旋转都可以漂亮地表示为与顶点坐标向量的<strong>矩阵乘法</strong>。但是，平移呢？平移是向量加法，我们无法用一个3x3矩阵的乘法来表示 $P' = P + T$。</p>
                <p>这个问题成为了一个巨大的障碍。如果我们不能统一表示平移，我们就无法将一系列复杂的变换（比如“先旋转再平移”）合并成一个单一的操作。这正是<strong>齐次坐标 (Homogeneous Coordinates)</strong> 登场解决的难题。</p>
                <h3 id="3-%E7%A5%9E%E5%A5%87%E7%9A%84%E7%AC%AC%E5%9B%9B%E7%BB%B4%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87"><strong>3. 神奇的第四维：齐次坐标</strong></h3>
                <p>齐次坐标是计算机图形学中最优雅、最重要的数学技巧之一。</p>
                <ul>
                <li>
                <p><strong>核心思想：</strong> 通过增加一个额外的维度（w分量），将n维空间中的问题映射到n+1维空间中去解决。</p>
                </li>
                <li>
                <p><strong>表示法：</strong></p>
                <ul>
                <li>一个三维笛卡尔坐标点 $(x, y, z)$ 在齐次坐标中表示为 $(x, y, z, 1)$。</li>
                <li>一个三维笛卡尔坐标向量 $(x, y, z)$ 在齐次坐标中表示为 $(x, y, z, 0)$。</li>
                </ul>
                </li>
                <li>
                <p><strong>从齐次坐标转换回笛卡尔坐标：</strong></p>
                <ul>
                <li>对于点 $(x, y, z, w)$ 且 $w \neq 0$，其对应的三维笛卡尔坐标为 $(x/w, y/w, z/w)$。</li>
                <li>这意味着，在齐次坐标系中，$(1, 2, 3, 1)$ 和 $(2, 4, 6, 2)$ 表示的是同一个三维点。</li>
                </ul>
                </li>
                </ul>
                <p><strong>为什么w分量如此关键？</strong></p>
                <ul>
                <li><strong>w=1代表点：</strong> 点是有位置的，它可以被平移。</li>
                <li><strong>w=0代表向量：</strong> 向量只有方向和大小，没有位置，它不应该被平移。例如，一个指向北方的向量，无论你站在哪里，它都应该指向北方。</li>
                </ul>
                <h4 id="%E4%BD%BF%E7%94%A8%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%BB%9F%E4%B8%80%E5%8F%98%E6%8D%A2"><strong>使用齐次坐标统一变换</strong></h4>
                <p>引入齐次坐标后，我们使用4x4矩阵来进行变换。现在，奇迹发生了：<strong>平移也可以表示为矩阵乘法了！</strong></p>
                <ul>
                <li>
                <p><strong>平移矩阵 $T(T_x, T_y, T_z)$:</strong>
                $$\begin{pmatrix} x' \\ y' \\ z' \\ 1 \end{pmatrix} = \begin{pmatrix} 1 & 0 & 0 & T_x \\ 0 & 1 & 0 & T_y \\ 0 & 0 & 1 & T_z \\ 0 & 0 & 0 & 1 \end{pmatrix} \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix}$$</p>
                <p>验证一下：$x' = 1 \cdot x + 0 \cdot y + 0 \cdot z + T_x \cdot 1 = x + T_x$。完全正确！</p>
                <p>再看看对向量（w=0）的作用：
                $$\begin{pmatrix} v_x' \\ v_y' \\ v_z' \\ 0 \end{pmatrix} = \begin{pmatrix} 1 & 0 & 0 & T_x \\ 0 & 1 & 0 & T_y \\ 0 & 0 & 1 & T_z \\ 0 & 0 & 0 & 1 \end{pmatrix} \begin{pmatrix} v_x \\ v_y \\ v_z \\ 0 \end{pmatrix}$$</p>
                <p>验证一下：$v_x' = v_x, v_y' = v_y, v_z' = v_z$。向量果然没有被平移！</p>
                </li>
                </ul>
                <p>现在，平移、旋转、缩放都统一为了4x4矩阵的乘法。这是一个巨大的突破！</p>
                <h3 id="4-%E5%8F%98%E6%8D%A2%E7%9A%84%E7%BB%84%E5%90%88-composition-of-transformations"><strong>4. 变换的组合 (Composition of Transformations)</strong></h3>
                <p>现实世界中的运动往往是复杂的，例如“让一个物体以自身的中心为轴旋转”。我们知道，标准的旋转是绕原点进行的。要实现这个效果，我们需要一个<strong>复合变换 (Composite Transformation)</strong>：</p>
                <ol>
                <li><strong>第一步：</strong> 将物体平移，使其中心点与原点重合。 (矩阵 $T$)</li>
                <li><strong>第二步：</strong> 执行标准的旋转操作。 (矩阵 $R$)</li>
                <li><strong>第三步：</strong> 将物体平移回原来的位置。 (矩阵 $T^{-1}$)</li>
                </ol>
                <p>由于所有变换都是矩阵，对一个点 $P$ 应用这一系列变换的过程就是：
                $$P' = T^{-1} (R (T P))$$</p>
                <p>根据矩阵乘法的结合律，这等价于：
                $$P' = (T^{-1} R T) P$$</p>
                <p>这意味着我们可以<strong>预先计算</strong>复合变换矩阵 $M = T^{-1} R T$。然后，我们只需要用这个单一的矩阵 $M$ 去乘以模型的所有顶点，就可以一步到位地完成整个复杂变换！</p>
                <p><strong>这是现代图形管线的核心：</strong> 无论你的变换序列有多长，最终都可以合并成一个单一的矩阵。GPU所做的，就是用这个最终的矩阵去高效地处理成千上万的顶点。</p>
                <h4 id="%E5%8F%98%E6%8D%A2%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81"><strong>变换的顺序至关重要！</strong></h4>
                <p>矩阵乘法<strong>不满足交换律</strong> ($AB \neq BA$)。这意味着变换的顺序会极大地影响最终结果。</p>
                <ul>
                <li><strong>先旋转，再平移：</strong> 物体会围绕原点旋转，然后整个被移动到新的位置。</li>
                <li><strong>先平移，再旋转：</strong> 物体会先被移动到新的位置，然后围绕<strong>新的原点</strong>进行旋转，产生一种“公转”的效果。</li>
                </ul>
                <p><strong>在OpenGL等遵循列主序矩阵的系统中，代码中的变换顺序与实际数学上的应用顺序是相反的。</strong>
                如果你写的代码是：</p>
                <div class="code-container">
                    <pre class="hljs"><code><div>glTranslate(...);
glRotate(...);
drawObject();
</div></code></pre>
                </div>
                <p>那么一个顶点 $v$ 实际经历的变换是 $v' = (\text{Translate Matrix} \times \text{Rotate Matrix}) \times v$。即<strong>代码中最后调用的变换最先作用于顶点</strong>。</p>
                <h3 id="5-opengl%E4%B8%AD%E7%9A%84%E5%8F%98%E6%8D%A2"><strong>5. OpenGL中的变换</strong></h3>
                <p>在（旧版）OpenGL中，变换是通过维护一个<strong>当前变换矩阵 (Current Transformation Matrix, CTM)</strong> 的状态机来实现的。</p>
                <ul>
                <li><code>glMatrixMode(mode)</code>: 选择要操作的矩阵，最常用的是 <code>GL_MODELVIEW</code> (模型视图矩阵)。</li>
                <li><code>glLoadIdentity()</code>: 将当前矩阵重置为单位矩阵。</li>
                <li><code>glTranslatef(x, y, z)</code>: 生成一个平移矩阵，并<strong>右乘</strong>到当前矩阵上。</li>
                <li><code>glRotatef(angle, x, y, z)</code>: 生成一个旋转矩阵，并<strong>右乘</strong>到当前矩阵上。</li>
                <li><code>glScalef(x, y, z)</code>: 生成一个缩放矩阵，并<strong>右乘</strong>到当前矩阵上。</li>
                </ul>
                <p><strong>代码示例：绕任意轴旋转</strong>
                假设我们要将一个物体绕点 $P_1(4, 5, 6)$，以向量 $(1, 2, 3)$ 为轴，旋转45度。
                这个复合变换的数学表达是 $M = T_{P1} R_{45} T_{-P1}$。
                由于OpenGL的逆序特性，代码应该写成：</p>
                <div class="code-container">
                    <pre class="hljs"><code><div>glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
<span class="hljs-comment">// 步骤3: 平移回来</span>
glTranslatef(<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>); 
<span class="hljs-comment">// 步骤2: 绕原点旋转</span>
glRotatef(<span class="hljs-number">45.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>); 
<span class="hljs-comment">// 步骤1: 平移到原点</span>
glTranslatef(<span class="hljs-number">-4.0</span>, <span class="hljs-number">-5.0</span>, <span class="hljs-number">-6.0</span>); 
<span class="hljs-comment">// 在这里绘制的物体，就会应用上述复合变换</span>
drawObject();
</div></code></pre>
                </div>
                <h4 id="%E7%9F%A9%E9%98%B5%E5%A0%86%E6%A0%88-matrix-stack"><strong>矩阵堆栈 (Matrix Stack)</strong></h4>
                <p>在处理具有层级结构的模型（如一个身体，有大臂、小臂、手掌）时，我们需要一种方法来保存和恢复变换状态。OpenGL为此提供了<strong>矩阵堆栈</strong>。</p>
                <ul>
                <li><code>glPushMatrix()</code>: 将当前变换矩阵的副本压入堆栈顶部。</li>
                <li><code>glPopMatrix()</code>: 弹出堆栈顶部的矩阵，恢复它作为当前变换矩阵。</li>
                </ul>
                <p>这使得我们可以轻松地实现场景图的遍历：</p>
                <div class="code-container">
                    <pre class="hljs"><code><div>draw_robot() {
    <span class="hljs-comment">// ... 绘制身体 ...</span>
    glPushMatrix(); <span class="hljs-comment">// 保存身体的变换状态</span>
    
    <span class="hljs-comment">// 应用针对大臂的变换 (相对于身体)</span>
    glTranslate(...); 
    glRotate(...);
    draw_upper_arm();
    
    glPushMatrix(); <span class="hljs-comment">// 保存大臂的变换状态</span>
    
    <span class="hljs-comment">// 应用针对小臂的变换 (相对于大臂)</span>
    glTranslate(...);
    glRotate(...);
    draw_lower_arm();
    
    glPopMatrix(); <span class="hljs-comment">// 恢复到大臂的坐标系</span>
    
    glPopMatrix(); <span class="hljs-comment">// 恢复到身体的坐标系</span>
}
</div></code></pre>
                </div>
            </article>
        </main>
    </div>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
</body>
</html>