<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ads05:二项队列（Binomial Queue）</title>
    <link rel="stylesheet" href="../style.css">
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="ads05%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97binomial-queue">ads05:二项队列（Binomial Queue）</h1>
                <p>（补档：将以前的ads笔记做修缮后上传）</p>
                <h3 id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E4%BA%8C%E9%A1%B9%E5%A0%86%E7%9A%84%E5%9F%BA%E7%9F%B3--%E4%BA%8C%E9%A1%B9%E6%A0%91-binomial-tree">第一部分：二项堆的基石 —— 二项树 (Binomial Tree)</h3>
                <p>要理解二项堆，我们必须首先理解它的基本组成部分：<strong>二项树</strong>。</p>
                <p><strong>定义：</strong>
                二项树是一种递归定义的有序树，我们用 $B_k$ 来表示一棵 $k$ 阶二项树。</p>
                <ul>
                <li><strong>$B_0$</strong> 是一棵 <strong>0 阶</strong>二项树，它只有一个节点。</li>
                <li><strong>$B_k$</strong> 是一棵 <strong>$k$ 阶</strong>二项树，它由两棵 $B_{k-1}$（$k-1$ 阶二项树）连接而成。具体地，我们将其中一棵 $B_{k-1}$ 的根节点，作为另一棵 $B_{k-1}$ 根节点的最左边的孩子。</li>
                </ul>
                <p>让我们来看一下前几阶二项树的样子：</p>
                <div class="mermaid">
                graph TD
                    subgraph B_0
                        B0_root(( ))
                    end
                    
                    subgraph B_1
                        B1_root(( )) --- B1_child(( ))
                    end

                    subgraph B_2
                        B2_root(( )) --- B2_c1(( ))
                        B2_root --- B2_c2(( ))
                        B2_c1 --- B2_gc(( ))
                    end

                    subgraph B_3
                        B3_root(( )) --- B3_c1(( ))
                        B3_root --- B3_c2(( ))
                        B3_root --- B3_c3(( ))
                        
                        B3_c1 --- B3_gc1_1(( ))
                        B3_c1 --- B3_gc1_2(( ))
                        B3_gc1_1 --- B3_ggc(( ))
                        
                        B3_c2 --- B3_gc2_1(( ))
                    end
                    
                    subgraph B_4
                        B4_root(( )) --- B4_c1(( ))
                        B4_root --- B4_c2(( ))
                        B4_root --- B4_c3(( ))
                        B4_root --- B4_c4(( ))
                        
                        B4_c1 --- B4_gc1_1(( ))
                        B4_c1 --- B4_gc1_2(( ))
                        B4_c1 --- B4_gc1_3(( ))
                        
                        B4_c2 --- B4_gc2_1(( ))
                        B4_c2 --- B4_gc2_2(( ))
                        
                        B4_c3 --- B4_gc3_1(( ))
                        
                        B4_gc1_1 --- B4_ggc1_1(( ))
                        B4_gc1_1 --- B4_ggc1_2(( ))
                        
                        B4_ggc1_1 --- B4_gggc(( ))
                        
                        B4_gc1_2 --- B4_ggc1_3(( ))
                        
                        B4_gc2_1 --- B4_ggc2_1(( ))
                    end
                </div>
                <p>观察这些树，我们可以发现一些非常重要的数学性质。这些性质不仅优美，而且是二项堆高效运作的理论基础。</p>
                <h4 id="%E4%BA%8C%E9%A1%B9%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">二项树的性质</h4>
                <p>对于一棵 $k$ 阶二项树 $B_k$：</p>
                <ol>
                <li>
                <p><strong>节点数</strong>: $B_k$ 恰好有 <strong>$2^k$</strong> 个节点。</p>
                <ul>
                <li><strong>证明 (数学归纳法):</strong>
                <ul>
                <li><strong>基础情况 ($k=0$):</strong> $B_0$ 有 1 个节点，$2^0 = 1$。成立。</li>
                <li><strong>归纳假设:</strong> 假设 $B_{k-1}$ 有 $2^{k-1}$ 个节点。</li>
                <li><strong>归纳证明:</strong> $B_k$ 由两棵 $B_{k-1}$ 构成，因此其节点总数为 $2^{k-1} + 2^{k-1} = 2 * 2^{k-1} = 2^k$。</li>
                <li>证毕。</li>
                </ul>
                </li>
                </ul>
                </li>
                <li>
                <p><strong>树高</strong>: $B_k$ 的高度为 <strong>$k$</strong>。</p>
                <ul>
                <li><strong>证明 (数学归纳法):</strong>
                <ul>
                <li><strong>基础情况 ($k=0$):</strong> $B_0$ 的高度为 0。成立。</li>
                <li><strong>归纳假设:</strong> 假设 $B_{k-1}$ 的高度为 $k-1$。</li>
                <li><strong>归纳证明:</strong> $B_k$ 的根是由一棵 $B_{k-1}$ 的根形成的，它的子树是一棵新的 $B_{k-1}$。因此，$B_k$ 的高度是 $B_{k-1}$ 的高度加 1，即 $(k-1) + 1 = k$。</li>
                <li>证毕。</li>
                </ul>
                </li>
                </ul>
                </li>
                <li>
                <p><strong>根的度数</strong>: $B_k$ 的根节点恰好有 <strong>$k$</strong> 个孩子。并且，这些孩子节点恰好是 $B_{k-1}, B_{k-2}, ..., B_0$ 的根（从左到右）。</p>
                <ul>
                <li><strong>证明 (通过构造):</strong>
                <ul>
                <li>$B_k$ 由两棵 $B_{k-1}$ 构成，我们称之为 $T_A$ 和 $T_B$。假设 $T_B$ 的根连接到 $T_A$ 的根。</li>
                <li>$T_A$ 的根原来有 $k-1$ 个孩子，它们是 $B_{k-2}, ..., B_0$ 的根。</li>
                <li>现在，$T_B$ 的根成为 $T_A$ 根的一个新孩子。$T_B$ 本身是一棵 $B_{k-1}$。</li>
                <li>因此，$B_k$ 的根现在有 $(k-1) + 1 = k$ 个孩子，它们分别是 $B_{k-1}, B_{k-2}, ..., B_0$ 的根。</li>
                <li>证毕。</li>
                </ul>
                </li>
                </ul>
                </li>
                <li>
                <p><strong>深度的节点数 (核心性质)</strong>: 在 $B_k$ 中，深度为 $d$ 的节点数量为 <strong>二项式系数 C(k, d)</strong>，即 $k$ 中选 $d$ 的组合数。</p>
                <ul>
                <li><strong>为什么叫“二项树”？</strong> 这就是名字的由来！$(a+b)^k$ 的二项式展开，其系数就与此有关。</li>
                <li><strong>证明 (数学归纳法):</strong>
                <ul>
                <li>令 $N(k, d)$ 为 $B_k$ 在深度 $d$ 的节点数。</li>
                <li><strong>基础情况 ($k=0$):</strong> $B_0$ 在深度 0 有 1 个节点，$N(0, 0) = 1$。而 $C(0, 0) = 1$。成立。</li>
                <li><strong>归纳假设:</strong> 假设对于 $B_{k-1}$，其深度 $d$ 的节点数为 $N(k-1, d) = C(k-1, d)$。</li>
                <li><strong>归纳证明:</strong> $B_k$ 由两棵 $B_{k-1}$（$T_A$ 和 $T_B$）构成。$B_k$ 中深度为 $d$ 的节点来自两个部分：
                <ol>
                <li>来自 $T_A$ 中深度为 $d$ 的节点。其数量为 $N(k-1, d)$。</li>
                <li>来自 $T_B$ 中深度为 $d-1$ 的节点（因为 $T_B$ 的根被挂在了 $B_k$ 的根下，深度增加了1）。其数量为 $N(k-1, d-1)$。</li>
                </ol>
                </li>
                <li>因此，$N(k, d) = N(k-1, d) + N(k-1, d-1)$。</li>
                <li>根据帕斯卡恒等式（Pascal's Identity），我们知道 $C(k, d) = C(k-1, d) + C(k-1, d-1)$。</li>
                <li>所以，$N(k, d) = C(k, d)$。</li>
                <li>证毕。</li>
                </ul>
                </li>
                </ul>
                </li>
                </ol>
                <hr>
                <h3 id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E4%BA%8C%E9%A1%B9%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84">第二部分：二项堆的结构</h3>
                <p>现在我们知道了二项树，那么二项堆是什么呢？</p>
                <p>一个二项堆不是一棵树，而是一个由<strong>二项树组成的森林</strong>。</p>
                <p>这个森林必须满足两个核心属性：</p>
                <ol>
                <li><strong>堆序属性 (Heap-Ordered):</strong> 森林中的<strong>每一棵</strong>二项树都满足<strong>最小堆</strong>性质。即，每个节点的值都小于或等于其所有孩子节点的值。这也意味着每棵树的根节点是该树中的最小值。</li>
                <li><strong>结构属性 (Unique Structure):</strong> 对于任意阶数 $k$，森林中<strong>至多只有一棵</strong> $B_k$ 类型的二项树。</li>
                </ol>
                <p><strong>关键思想：与二进制的深刻联系</strong></p>
                <p>这个结构属性非常巧妙。它意味着一个包含 $N$ 个节点的二项堆的结构，是由 $N$ 的二进制表示唯一确定的！</p>
                <p>假设 $N$ 的二进制表示为 $(...b_k ... b_1 b_0)_2$。
                如果 $b_k$ 位是 $1$，那么这个二项堆中就包含一棵 $B_k$。
                如果 $b_k$ 位是 $0$，那么这个二项堆中就没有 $B_k$。</p>
                <p><strong>【示例】一个包含 13 个节点的二项堆</strong></p>
                <ol>
                <li><strong>计算:</strong> $13$ 的二进制表示是 $1101_2$。</li>
                <li><strong>分解:</strong> $13 = 8 + 4 + 0 + 1 = 1<em>2^3 + 1</em>2^2 + 0<em>2^1 + 1</em>2^0$。</li>
                <li><strong>构建:</strong> 这意味着这个二项堆由 $B_3$ (8个节点), $B_2$ (4个节点), 和 $B_0$ (1个节点) 组成。它没有 $B_1$。</li>
                </ol>
                <p>假设我们有13个元素，它们可以构成如下的二项堆（注意，每棵树都满足最小堆性质）：</p>
                <div class="mermaid">
                graph TD
                    subgraph "Binomial Heap (Size 13)"
                        subgraph B0
                            direction TB
                            B0_R((13))
                        end
                        
                        subgraph B2
                            direction TB
                            B2_R((23)) --> B2_C1((51))
                            B2_R --> B2_C2((24))
                            B2_C1 --> B2_GC1((65))
                        end
                        
                        subgraph B3
                            direction TB
                            B3_R((12)) --> B3_C1((21))
                            B3_R --> B3_C2((24))
                            B3_R --> B3_C3((14))
                            
                            B3_C1 --> B3_GC1_1((65))
                            B3_C1 --> B3_GC1_2((26))
                            
                            B3_GC1_2 --> B3_GGC1((18))
                            
                            B3_C2 --> B3_GC2_1((16))
                        end
                    end
                </div>
                <p><em>注意：$B_1$ 是不存在的，用灰色表示其缺失的位置，以强调结构。</em></p>
                <div class="mermaid">
                graph TD
                    subgraph "Structure for N=13 (Binary 1101)"
                        direction LR
                    
                        subgraph B0 [Exists]
                             B0_Node((13))
                        end

                        subgraph B1 [Not Present]
                             B1_Placeholder( )
                             style B1_Placeholder fill:#eee,stroke:#999,stroke-width:2px,stroke-dasharray: 5 5
                        end

                        subgraph B2 [Exists]
                            B2_R((23)) --> B2_C1((51))
                            B2_R --> B2_C2((24))
                            B2_C1 --> B2_GC1((65))
                        end

                        subgraph B3 [Exists]
                            B3_R((12)) --> B3_C1((21))
                            B3_R --> B3_C2((24))
                            B3_R --> B3_C3((14))
                            
                            B3_C1 --> B3_GC1_1((65)) & B3_GC1_2((26))
                            B3_GC1_2 --> B3_GGC1((18))
                            B3_C2 --> B3_GC2_1((16))
                        end
                    end
                </div>
                <p>这个根节点的列表（13, 23, 12）是二项堆的核心，我们通常按树的阶数从小到大排序。</p>
                <hr>
                <h3 id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C">第三部分：核心操作</h3>
                <h4 id="1-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC-findmin">1. 查找最小值 (FindMin)</h4>
                <ul>
                <li>
                <p><strong>原理:</strong> 由于每棵二项树都满足最小堆性质，整个堆的最小值必然是森林中某棵树的根。</p>
                </li>
                <li>
                <p><strong>实现:</strong> 我们只需要遍历所有树的根节点，找到其中的最小值即可。</p>
                </li>
                <li>
                <p><strong>复杂度:</strong> 一个包含 $N$ 个节点的堆，最多有多少棵树？树的数量等于 $N$ 的二进制表示中 $1$ 的个数。当 $N = 2^k - 1$ 时，树的数量最多，为 $k$。因为 $k = \lfloor \log_2 N\rfloor$，所以根节点的数量是 $O(\log N)$。因此，<code>FindMin</code> 的时间复杂度为 <strong>$O(\log N)$</strong>。</p>
                </li>
                <li>
                <p><strong>优化:</strong> 我们可以像在斐波那契堆中一样，维护一个指向最小根节点的指针。这样，<code>FindMin</code> 操作就可以在 <strong>$O(1)$</strong> 时间内完成。不过，这个指针需要在执行 <code>Insert</code>, <code>Merge</code>, <code>DeleteMin</code> 等修改堆结构的操作时进行更新。</p>
                </li>
                </ul>
                <h4 id="2-%E5%90%88%E5%B9%B6-merge--union">2. 合并 (Merge / Union)</h4>
                <p>这是二项堆的“杀手级应用”。合并两个二项堆 $H_1$ 和 $H_2$ 的过程，与二进制加法惊人地相似。</p>
                <ul>
                <li><strong>思想:</strong> 我们从 $k=0$ 开始，逐阶（就像二进制的每一位）处理。对于每一阶 $k$，我们可能会有来自 $H_1$ 的 $B_k$，来自 $H_2$ 的 $B_k$，以及从前一阶 $k-1$ 合并产生的“进位” $B_k$。</li>
                <li><strong>规则:</strong> 在第 $k$ 阶，我们最多可能有三棵 $B_k$。
                <ul>
                <li><strong>0 棵 $B_k$:</strong> 什么都不做。</li>
                <li><strong>1 棵 $B_k$:</strong> 这棵树直接成为结果堆中的 $B_k$。</li>
                <li><strong>2 棵 $B_k$:</strong> 将这两棵树合并成一棵 $B_{k+1}$。这棵 $B_{k+1}$ 成为到下一阶的“进位”。结果堆中没有 $B_k$。</li>
                <li><strong>3 棵 $B_k$:</strong> 保留其中一棵作为结果堆中的 $B_k$，另外两棵合并成一棵 $B_{k+1}$，作为到下一阶的“进位”。</li>
                </ul>
                </li>
                </ul>
                <p><strong>【合并示例】</strong>
                合并 $H_1$ (大小为 6) 和 $H_2$ (大小为 7)。</p>
                <ul>
                <li>$6 = (110)_2$ -&gt; $H_1$ 有 $B_2$ 和 $B_1$。</li>
                <li>$7 = (111)_2$ -&gt; $H_2$ 有 $B_2$, $B_1$, 和 $B_0$。</li>
                <li>合并结果大小为 13，应该是 $(1101)_2$ -&gt; $B_3$, $B_2$, $B_0$。</li>
                </ul>
                <p>让我们模拟这个过程：</p>
                <table>
                <thead>
                <tr>
                <th style="text-align:center">阶 (k)</th>
                <th style="text-align:center">H1</th>
                <th style="text-align:center">H2</th>
                <th style="text-align:center">Carry In</th>
                <th style="text-align:center">Sum (棵)</th>
                <th style="text-align:center">Result</th>
                <th style="text-align:center">Carry Out</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                <td style="text-align:center"><strong>0</strong></td>
                <td style="text-align:center">无</td>
                <td style="text-align:center">B0</td>
                <td style="text-align:center">无</td>
                <td style="text-align:center">1</td>
                <td style="text-align:center">B0</td>
                <td style="text-align:center">无</td>
                </tr>
                <tr>
                <td style="text-align:center"><strong>1</strong></td>
                <td style="text-align:center">B1</td>
                <td style="text-align:center">B1</td>
                <td style="text-align:center">无</td>
                <td style="text-align:center">2</td>
                <td style="text-align:center">无</td>
                <td style="text-align:center">B2</td>
                </tr>
                <tr>
                <td style="text-align:center"><strong>2</strong></td>
                <td style="text-align:center">B2</td>
                <td style="text-align:center">B2</td>
                <td style="text-align:center">B2 (进位)</td>
                <td style="text-align:center">3</td>
                <td style="text-align:center">B2</td>
                <td style="text-align:center">B3</td>
                </tr>
                <tr>
                <td style="text-align:center"><strong>3</strong></td>
                <td style="text-align:center">无</td>
                <td style="text-align:center">无</td>
                <td style="text-align:center">B3 (进位)</td>
                <td style="text-align:center">1</td>
                <td style="text-align:center">B3</td>
                <td style="text-align:center">无</td>
                </tr>
                </tbody>
                </table>
                <p>最终结果包含 $B_3$, $B_2$, $B_0$，与预期一致！</p>
                <p><strong>合并两棵同阶树 <code>CombineTrees(T1, T2)</code></strong>
                这是合并操作的基础。假设要合并两棵 $B_k$。</p>
                <ol>
                <li>比较它们的根节点 <code>root1</code> 和 <code>root2</code> 的值。</li>
                <li>假设 <code>value(root1) &lt;= value(root2)</code>。</li>
                <li>将 <code>T2</code> 变成 <code>T1</code> 的一个新孩子（通常是最左边的孩子）。</li>
                <li>结果是一棵 $B_{k+1}$，其根是 <code>root1</code>。
                这个操作是 <strong>O(1)</strong> 的。</li>
                </ol>
                <p><strong>复杂度:</strong> 合并过程需要遍历两个堆的根列表，其长度都是 $O(\log N)$。每一步都是 $O(1)$ 的 <code>CombineTrees</code> 操作。因此，总的合并时间复杂度为 <strong>$O(\log N)$</strong>。</p>
                <h4 id="3-%E6%8F%92%E5%85%A5-insert">3. 插入 (Insert)</h4>
                <ul>
                <li><strong>原理:</strong> 插入一个新元素可以看作是<strong>特殊情况的合并</strong>。</li>
                <li><strong>实现:</strong>
                <ol>
                <li>创建一个只包含待插入新元素的二项堆（即一个 $B_0$）。</li>
                <li>将这个新堆与原有的堆进行合并。</li>
                </ol>
                </li>
                <li><strong>复杂度:</strong>
                <ul>
                <li><strong>最坏情况:</strong> $O(\log N)$。例如，向一个包含 $2^k - 1$ 个元素的堆（由 $B_{k-1}, ..., B_0$ 组成）插入一个元素。这会引发一连串的进位，直到形成一棵 $B_k$。</li>
                <li><strong>均摊情况 (Amortized Analysis):</strong> $O(1)$。</li>
                </ul>
                </li>
                </ul>
                <p><strong>【均摊分析】</strong>
                为什么插入的均摊时间是 $O(1)$？我们可以用两种方法来理解。</p>
                <p><strong>方法一：聚合分析 (Aggregate Analysis)</strong>
                考虑连续 $N$ 次插入到一个空堆中。</p>
                <ul>
                <li>第1次插入：1次操作 (创建 $B_0$)</li>
                <li>第2次插入：2次操作 (合并 $B_0$ 和 $B_0$ 成 $B_1$)</li>
                <li>第3次插入：1次操作 (添加 $B_0$)</li>
                <li>第4次插入：3次操作 (合并 $B_0$, $B_0$ -&gt; $B_1$；合并 $B_1$, $B_1$ -&gt; $B_2$)
                ...
                总的来看，每次插入，元素 $i$ 的二进制表示的最低位是 $0$ 变成 $1$。如果第 $k$ 位是第一个 $0$，则会发生 $k$ 次合并。
                在 $N$ 次插入中，$B_0$ 合并了 $N/2$ 次，$B_1$ 合并了 $N/4$ 次，$B_2$ 合并了 $N/8$ 次...
                总合并次数 = $N/2 + N/4 + N/8 + ... &lt; N$。
                所以 $N$ 次插入总共花费 $O(N)$ 的时间，平均每次就是 <strong>$O(1)$</strong>。</li>
                </ul>
                <p><strong>方法二：势能法 (Potential Function Method)</strong>
                这是更严谨的证明。</p>
                <ul>
                <li>定义<strong>势能函数 $\Phi(H)$</strong> 为堆 $H$ 中树的数量。</li>
                <li>第 $i$ 次操作的<strong>实际成本</strong>为 $C_i$。</li>
                <li>第 $i$ 次操作的<strong>均摊成本</strong>为 $a_i = C_i + \Phi(H_i) - \Phi(H_{i-1})$。</li>
                <li>假设第 $i$ 次插入操作需要 $k$ 次 <code>CombineTrees</code> 操作。这意味着在插入前，堆中有 $B_0, B_1, ..., B_{k-1}$。
                <ul>
                <li>实际成本 $C_i = k + 1$ (k 次合并，1 次创建新堆)。</li>
                <li>操作前树的数量 $\Phi(H_{i-1}) = k$。</li>
                <li>操作后，这些树合并成一棵 $B_k$，树的数量 $\Phi(H_i) = 1$（假设堆中更高阶的树不受影响）。</li>
                <li>势能变化 $\Delta \Phi = \Phi(H_i) - \Phi(H_{i-1}) = 1 - k$。</li>
                <li>均摊成本 $a_i = (k+1) + (1-k) = 2$。</li>
                </ul>
                </li>
                <li>因此，每次插入的均摊成本是一个常数 <strong>$O(1)$</strong>。</li>
                </ul>
                <h4 id="4-%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%80%BC-deletemin">4. 删除最小值 (DeleteMin)</h4>
                <p>这是最复杂的操作，但逻辑清晰，可以分解为以下步骤：</p>
                <ol>
                <li><strong>找到最小根:</strong> 遍历根列表，找到带有最小值的根。假设它属于 $B_k$。 (复杂度: $O(\log N)$)</li>
                <li><strong>分离:</strong> 将这棵 $B_k$ 从堆 $H$ 的森林中移除。剩下的树构成一个新的堆 $H'$。 (复杂度: $O(1)$)</li>
                <li><strong>拆解:</strong> 移除 $B_k$ 的根节点（这就是我们要返回的最小值）。它的 $k$ 个孩子，根据性质，恰好是 $B_{k-1}, B_{k-2}, ..., B_0$ 的根。将这些孩子看作一个独立的二项堆 $H''$。 (复杂度: $O(\log N)$ 来创建 $H''$ 的根列表)</li>
                <li><strong>合并:</strong> 合并 $H'$ 和 $H''$。 (复杂度: $O(\log N)$)</li>
                </ol>
                <p><strong>【DeleteMin 示例】</strong>
                假设我们从之前大小为 13 的堆中删除最小值。</p>
                <div class="mermaid">
                graph TD
                    subgraph "H' (Heap after removing B3)"
                        direction LR

                        subgraph B0
                            B0_R((13))
                        end

                        subgraph B2
                            B2_R((23)) --> B2_C1((51))
                            B2_R --> B2_C2((24))
                            B2_C1 --> B2_GC1((65))
                        end
                    end
                </div>
                <ol>
                <li><strong>FindMin:</strong> 最小值为 12，在 $B_3$ 的根上。</li>
                <li><strong>分离:</strong>
                <ul>
                <li>$H'$ 包含 $B_2$ 和 $B_0$。</li>
                </ul>
                <div class="mermaid">
                graph TD
                subgraph "H'' (from children of node 12)"
                    direction LR

                    %% B_0 Tree from B_3's children
                    B0_from_B3((14))

                    %% B_1 Tree from B_3's children
                    B1_from_B3_R((24)) --> B1_from_B3_C((16))

                    %% B_2 Tree from B_3's children
                    B2_from_B3_R((21)) --> B2_from_B3_C1((65))
                    B2_from_B3_R --> B2_from_B3_C2((26))
                    B2_from_B3_C2 --> B2_from_B3_GC((18))
                end
                </div>
                </li>
                <li><strong>拆解:</strong> 移除 12。$B_3$ 的孩子是 $B_2$, $B_1$, $B_0$ 的根。它们形成 $H''$。<div class="mermaid">
                graph TD
                subgraph "H'' (Formed from children of min root 12)"
                    direction LR

                    subgraph "Child 1 (B2)"
                        B2_from_B3_R((21)) --> B2_from_B3_C1((65))
                        B2_from_B3_R --> B2_from_B3_C2((26))
                        B2_from_B3_C2 --> B2_from_B3_GC((18))
                    end

                    subgraph "Child 2 (B1)"
                        B1_from_B3_R((24)) --> B1_from_B3_C((16))
                    end

                    subgraph "Child 3 (B0)"
                         B0_from_B3((14))
                    end
                end
                </div>
                </li>
                <li><strong>合并:</strong> 合并 $H'$ (大小 5) 和 $H''$ (大小 7)。结果是一个大小为 12 的新堆。$5 = (101)_2$, $7 = (111)_2$。$5+7=12 = (1100)_2$。最终结果将包含 $B_3$ 和 $B_2$。</li>
                </ol>
                <p>总复杂度为 <strong>$O(\log N)$</strong>。</p>
                <hr>
                <h3 id="%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%E4%B8%8E%E4%BB%A3%E7%A0%81">第四部分：实现细节与代码</h3>
                <p>要高效地实现二项堆，我们需要一个合适的节点表示。<strong>左孩子-右兄弟表示法</strong> 是一个绝佳的选择。</p>
                <h4 id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89-c">数据结构定义 (C++)</h4>
                <div class="code-container">
                <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;

// 节点结构
struct BinNode {
    int key;            // 节点的值
    int degree;         // 节点的度（即孩子的数量，等于其作为根的二项树的阶）
    BinNode* parent;    // 指向父节点
    BinNode* child;     // 指向最左边的孩子
    BinNode* sibling;   // 指向右边的兄弟

    BinNode(int k) : key(k), degree(0), parent(nullptr), child(nullptr), sibling(nullptr) {}
};

// 二项堆结构
class BinomialHeap {
private:
    BinNode* head; // 指向根链表的头部（最小阶数的树）
    
    // 内部辅助函数
    void link(BinNode* y, BinNode* z);
    BinNode* merge_lists(BinNode* h1, BinNode* h2);
    BinNode* union_heaps(BinNode* h1, BinNode* h2);
    void print_tree(BinNode* node, std::string indent, bool last);

public:
    BinomialHeap() : head(nullptr) {}
    ~BinomialHeap(); // 需要实现析构函数来释放内存

    bool isEmpty() const { return head == nullptr; }
    void insert(int key);
    int findMin() const;
    int extractMin();
    void merge(BinomialHeap&amp; other);
    void print() const;
};
</code></pre>
                </div>
                <h4 id="%E5%85%B3%E9%94%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0">关键操作实现</h4>
                <p><strong>1. Link (对应 <code>CombineTrees</code>)</strong>
                将一棵树连接到另一棵树下，形成更高一阶的树。</p>
                <div class="code-container">
                <pre><code class="language-cpp">// 将 y 的根链接到 z 的根下，z 成为新根
void BinomialHeap::link(BinNode* y, BinNode* z) {
    y-&gt;parent = z;
    y-&gt;sibling = z-&gt;child;
    z-&gt;child = y;
    z-&gt;degree++;
}
</code></pre>
                </div>
                <p><strong>2. Union (核心合并逻辑)</strong>
                模拟二进制加法，合并两个根链表。</p>
                <div class="code-container">
                <pre><code class="language-cpp">BinNode* BinomialHeap::union_heaps(BinNode* h1, BinNode* h2) {
    BinNode* new_head = merge_lists(h1, h2);
    if (new_head == nullptr) {
        return nullptr;
    }

    BinNode* prev_x = nullptr;
    BinNode* x = new_head;
    BinNode* next_x = x-&gt;sibling;

    while (next_x != nullptr) {
        if ((x-&gt;degree != next_x-&gt;degree) || 
            (next_x-&gt;sibling != nullptr &amp;&amp; next_x-&gt;sibling-&gt;degree == x-&gt;degree)) {
            // Case 1 & 2: x 和 next_x 的度不同，或者后面还有一个同度的
            prev_x = x;
            x = next_x;
        } else {
            // Case 3 & 4: x 和 next_x 的度相同
            if (x-&gt;key &lt;= next_x-&gt;key) { // x 成为根
                x-&gt;sibling = next_x-&gt;sibling;
                link(next_x, x);
            } else { // next_x 成为根
                if (prev_x == nullptr) {
                    new_head = next_x;
                } else {
                    prev_x-&gt;sibling = next_x;
                }
                link(x, next_x);
                x = next_x;
            }
        }
        next_x = x-&gt;sibling;
    }
    return new_head;
}

// 辅助函数: 合并两个按度排序的根链表
BinNode* BinomialHeap::merge_lists(BinNode* h1, BinNode* h2) {
    // ... 标准的合并两个有序链表的逻辑 ...
    if (!h1) return h2;
    if (!h2) return h1;

    BinNode* head;
    BinNode* tail;

    if (h1-&gt;degree &lt;= h2-&gt;degree) {
        head = h1;
        h1 = h1-&gt;sibling;
    } else {
        head = h2;
        h2 = h2-&gt;sibling;
    }
    tail = head;

    while (h1 &amp;&amp; h2) {
        if (h1-&gt;degree &lt;= h2-&gt;degree) {
            tail-&gt;sibling = h1;
            h1 = h1-&gt;sibling;
        } else {
            tail-&gt;sibling = h2;
            h2 = h2-&gt;sibling;
        }
        tail = tail-&gt;sibling;
    }

    if (h1) {
        tail-&gt;sibling = h1;
    } else {
        tail-&gt;sibling = h2;
    }

    return head;
}
</code></pre>
                </div>
                <p><strong>3. Insert</strong>
                创建一个单节点堆，然后合并。</p>
                <div class="code-container">
                <pre><code class="language-cpp">void BinomialHeap::insert(int key) {
    BinNode* new_node = new BinNode(key);
    head = union_heaps(head, new_node);
}
</code></pre>
                </div>
                <p><strong>4. ExtractMin</strong>
                实现前面描述的四个步骤。</p>
                <div class="code-container">
                <pre><code class="language-cpp">int BinomialHeap::extractMin() {
    if (isEmpty()) {
        std::cerr &lt;&lt; "Heap is empty!" &lt;&lt; std::endl;
        return INT_MIN;
    }

    // 步骤 1: 找到最小根
    BinNode* min_node = head;
    BinNode* min_prev = nullptr;
    BinNode* current = head-&gt;sibling;
    BinNode* prev = head;
    
    while (current != nullptr) {
        if (current-&gt;key < min_node-&gt;key) {
            min_node = current;
            min_prev = prev;
        }
        prev = current;
        current = current-&gt;sibling;
    }

    // 步骤 2: 从根链表中移除最小节点
    if (min_prev == nullptr) { // 最小节点是头节点
        head = min_node-&gt;sibling;
    } else {
        min_prev-&gt;sibling = min_node-&gt;sibling;
    }

    // 步骤 3: 创建子树构成的新堆 H''
    BinNode* new_head = nullptr;
    BinNode* child = min_node-&gt;child;
    while (child != nullptr) {
        BinNode* next_child = child-&gt;sibling;
        child-&gt;sibling = new_head;
        child-&gt;parent = nullptr; // 子节点的父指针清空
        new_head = child;
        child = next_child;
    }
    // 注意：这里的 new_head 是一个反向的链表，需要翻转
    BinNode* reversed_head = nullptr;
    current = new_head;
    while(current != nullptr) {
        BinNode* next = current-&gt;sibling;
        current-&gt;sibling = reversed_head;
        reversed_head = current;
        current = next;
    }
    
    // 步骤 4: 合并 H' 和 H''
    head = union_heaps(head, reversed_head);

    int min_key = min_node-&gt;key;
    delete min_node;
    return min_key;
}
</code></pre>
                </div>
                <hr>
                <h3 id="%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8B%93%E5%B1%95">第五部分：总结与拓展</h3>
                <h4 id="%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94">性能对比</h4>
                <table>
                <thead>
                <tr>
                <th style="text-align:left">操作</th>
                <th style="text-align:left">二叉堆 (Binary Heap)</th>
                <th style="text-align:left">二项堆 (Binomial Heap)</th>
                <th style="text-align:left">斐波那契堆 (Fibonacci Heap)</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                <td style="text-align:left"><strong>Insert</strong></td>
                <td style="text-align:left">$O(\log N)$</td>
                <td style="text-align:left"><strong>$O(1)$ (均摊)</strong>, $O(\log N)$</td>
                <td style="text-align:left"><strong>$O(1)$</strong></td>
                </tr>
                <tr>
                <td style="text-align:left"><strong>FindMin</strong></td>
                <td style="text-align:left">$O(1)$</td>
                <td style="text-align:left">$O(1)$ (带指针优化)</td>
                <td style="text-align:left">$O(1)$</td>
                </tr>
                <tr>
                <td style="text-align:left"><strong>DeleteMin</strong></td>
                <td style="text-align:left">$O(\log N)$</td>
                <td style="text-align:left">$O(\log N)$</td>
                <td style="text-align:left">$O(\log N)$ (均摊)</td>
                </tr>
                <tr>
                <td style="text-align:left"><strong>Merge(Union)</strong></td>
                <td style="text-align:left">$O(N)$</td>
                <td style="text-align:left"><strong>$O(\log N)$</strong></td>
                <td style="text-align:left"><strong>$O(1)$</strong></td>
                </tr>
                <tr>
                <td style="text-align:left"><strong>DecreaseKey</strong></td>
                <td style="text-align:left">$O(\log N)$</td>
                <td style="text-align:left">$O(\log N)$</td>
                <td style="text-align:left"><strong>$O(1)$ (均摊)</strong></td>
                </tr>
                </tbody>
                </table>
                <p><strong>结论:</strong></p>
                <ul>
                <li>二项堆在<strong>合并</strong>操作上完胜二叉堆。</li>
                <li>它的 <code>Insert</code> 均摊性能也非常好。</li>
                <li>虽然斐波那契堆在理论上更快，但其结构复杂，常数因子巨大，在实践中除非数据规模极大且 <code>DecreaseKey</code> 操作非常频繁，否则二项堆可能是更好的选择。</li>
                </ul>
                <h4 id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</h4>
                <p>二项堆的 $O(\log N)$ 合并特性使其非常适用于：</p>
                <ol>
                <li><strong>事件模拟系统:</strong> 当需要将多个独立的事件队列合并成一个时。</li>
                <li><strong>实现其他高级算法:</strong> 作为某些算法的内部组件，这些算法需要频繁地合并优先队列。</li>
                <li><strong>Dijkstra's &amp; Prim's 算法:</strong> 虽然斐波那契堆因其 $O(1)$ 的 <code>DecreaseKey</code> 而成为理论上的最佳选择，但二项堆的 $O(\log N)$ <code>DecreaseKey</code>（通过上浮节点实现）也比二叉堆的实现更灵活，并且整体性能依然优秀。在需要合并图的场景下（例如，处理动态图），二项堆的优势会更加明显。</li>
                </ol>
            </article>
        </main>
    </div>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
</body>
</html>