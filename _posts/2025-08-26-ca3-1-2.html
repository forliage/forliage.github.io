<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>计算机体系结构3-1-2:Scoreboarding</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../modal.css">
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
                <li><a href="#" id="about-me-btn">ABOUT ME</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%843-1-2scoreboarding">计算机体系结构3-1-2:Scoreboarding</h1>
                <h3 id="%E7%AC%AC%E4%BA%8C%E8%8A%82scoreboarding">第二节：Scoreboarding</h3>
                <p>记分牌算法最早应用于 1964 年的 CDC 6600 超级计算机，它是动态调度的开山之作。它的设计哲学非常直观：<strong>建立一个集中式的信息中心（记分牌），来统一监控和管理整个流水线中所有指令和硬件资源的状态。</strong> 任何指令想要进入下一步，都必须先向记分牌“请示”，获得批准后方可行动。</p>
                <h4 id="21-%E8%AE%B0%E5%88%86%E7%89%8C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%8A%B6%E6%80%81%E8%A1%A8">2.1 记分牌的体系结构：三大核心状态表</h4>
                <p>这个所谓的“信息中心”，具体是由三张紧密关联的状态表构成的。让我们逐一剖析它的设计。</p>
                <p><img src="../images/imagea032.png" alt="figure 32"></p>
                <h4 id="1-%E6%8C%87%E4%BB%A4%E7%8A%B6%E6%80%81%E8%A1%A8-instruction-status">1. <strong>指令状态表 (Instruction Status)</strong></h4>
                <p>这张表回答了最基本的问题：“<strong>每条正在执行的指令，进行到哪一步了？</strong>”</p>
                <p>它为每一条从发射（Issue）到写回（Write Back）的指令维护一个条目，跟踪其在以下四个逻辑阶段的进展：</p>
                <ul>
                <li><strong>Issue (发射)</strong>：指令已被译码，并分配给一个功能单元。</li>
                <li><strong>Read Operands (读操作数)</strong>：指令正在等待其源操作数变为可用。一旦可用，它就会读取这些操作数。</li>
                <li><strong>Execution Complete (执行完成)</strong>：功能单元已经完成了计算。</li>
                <li><strong>Write Result (写回结果)</strong>：指令已经将结果写回目标寄存器。</li>
                </ul>
                <p><em>设计思考：为什么是这四个阶段？这其实是动态调度对传统流水线阶段的重新抽象。<code>Issue</code> 和 <code>Read Operands</code> 共同取代了 <code>ID</code> 阶段，<code>Execution Complete</code> 对应 <code>EX</code> 的完成，<code>Write Result</code> 对应 <code>WB</code>。注意，为了简化，早期的记分牌主要关注浮点运算，因此暂时忽略了访存（MEM）阶段。</em></p>
                <h4 id="2-%E5%8A%9F%E8%83%BD%E5%8D%95%E5%85%83%E7%8A%B6%E6%80%81%E8%A1%A8-functional-unit-status">2. <strong>功能单元状态表 (Functional Unit Status)</strong></h4>
                <p>这张表从硬件资源的角度回答了：“<strong>每个功能单元（FU）现在正在干什么，它的状态如何？</strong>”</p>
                <p>系统中有多少个功能单元（如一个整数单元，两个乘法器，一个除法器），这张表就有多少行。每一行包含了九个关键字段，这是记分牌的核心所在：</p>
                <ul>
                <li><code>Busy</code>：布尔值。<code>Yes</code> 表示该 FU 正在被使用。</li>
                <li><code>Op</code>：操作。记录该 FU 正在执行何种操作，如 <code>ADD</code>、<code>MUL</code>、<code>LOAD</code>。</li>
                <li><code>Fi</code>：目标寄存器 (Destination)。该操作的结果将要写入哪个寄存器。</li>
                <li><code>Fj</code>, <code>Fk</code>：源寄存器 (Sources)。两个源操作数分别来自哪个寄存器。</li>
                <li><code>Qj</code>, <code>Qk</code>：源功能单元。<strong>这是处理真数据依赖（RAW）的关键！</strong> 如果源操作数 <code>Fj</code> 尚未就绪（即正在被另一条指令计算），<code>Qj</code> 字段就会记录<strong>正在产生 <code>Fj</code> 的那个功能单元的名字</strong>。如果 <code>Fj</code> 已经就绪（值在寄存器中），<code>Qj</code> 字段就为空。<code>Qk</code> 同理。</li>
                <li><code>Rj</code>, <code>Rk</code>：源操作数就绪标志。<strong>这是处理写后读（WAR）相关的关键！</strong> <code>Rj</code> 为 <code>No</code> 表示虽然 <code>Fj</code> 的值可能已经在寄存器中了（<code>Qj</code>为空），但本 FU <strong>还未读取</strong>它。一旦读取，<code>Rj</code> 就设为 <code>Yes</code>。这个标志告诉系统，FU 是否还在依赖寄存器的<strong>旧值</strong>。</li>
                </ul>
                <p><em>设计思考：<code>Q</code> 字段和 <code>R</code> 字段的设计非常精妙。<code>Q</code> 字段建立了一个生产者-消费者的数据流图（“我在等谁”），而 <code>R</code> 字段则标记了消费动作是否完成（“我已经拿到货了”）。二者结合，为处理数据相关提供了必要的信息。</em></p>
                <h4 id="3-%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%9C%E7%8A%B6%E6%80%81%E8%A1%A8-register-result-status">3. <strong>寄存器结果状态表 (Register Result Status)</strong></h4>
                <p>这张表从寄存器的角度回答了：“<strong>哪个寄存器正在等待被写入，由谁来写？</strong>”</p>
                <p>它为每一个寄存器（如 F0-F31）维护一个条目。</p>
                <ul>
                <li><strong>内容</strong>：如果当前没有任何指令要写入该寄存器，则该条目为空。如果有一条活跃指令的目标是该寄存器，则该条目记录<strong>正在为它产生结果的那个功能单元的名字</strong>。</li>
                </ul>
                <p><em>设计思考：这张表的作用是<strong>快速检测写后写（WAW）和真数据依赖（RAW）</strong>。当一条新指令要发射时，</em></p>
                <ul>
                <li>它需要检查自己的<strong>目标寄存器 <code>Fi</code></strong> 在这张表里是否为空。如果不为空，说明已经有别的指令要写这个寄存器了，发生了 WAW 相关，必须停顿。</li>
                <li>它还需要检查自己的<strong>源寄存器 <code>Fj</code>, <code>Fk</code></strong> 在这张表里是否为空。如果不为空，说明源操作数还没准备好，这张表告诉了它应该去等哪个 FU（然后把这个 FU 的名字填入自己 FU 状态表的 <code>Qj/Qk</code> 字段）。</li>
                </ul>
                <h4 id="22-%E8%AE%B0%E5%88%86%E7%89%8C%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E6%8C%87%E4%BB%A4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%9B%9B%E9%83%A8%E6%9B%B2">2.2 记分牌算法流程：指令生命周期的四部曲</h4>
                <p>理解了这三张表，我们就能完整地描述一条指令在记分牌控制下的生命周期。</p>
                <ol>
                <li>
                <p><strong>Issue (发射阶段)</strong>
                一条指令从指令队列的头部被取出，尝试发射。记分牌会进行两项检查：</p>
                <ul>
                <li><strong>结构相关检查</strong>：该指令需要的功能单元是否空闲（查询 FU 状态表的 <code>Busy</code> 字段）？</li>
                <li><strong>WAW 相关检查</strong>：该指令的目标寄存器 <code>Fi</code> 是否正在被其他指令作为目标（查询寄存器结果状态表的 <code>Fi</code> 条目是否为空）？</li>
                </ul>
                <p><strong>决策</strong>：<strong>只有当两个检查都通过时</strong>，指令才能成功发射。否则，<strong>指令停顿在发射阶段，并且其后的所有指令都必须等待</strong>。这是记分牌的一个重要瓶颈。
                <strong>动作</strong>：如果成功发射，记分牌会：
                a.  更新 FU 状态表：将对应 FU 的 <code>Busy</code> 设为 <code>Yes</code>，并填入 <code>Op</code>, <code>Fi</code>, <code>Fj</code>, <code>Fk</code> 等信息。
                b.  检查源寄存器 <code>Fj</code>, <code>Fk</code> 的状态，设置 <code>Qj</code>, <code>Qk</code> 和 <code>Rj</code>, <code>Rk</code> 字段。
                c.  更新寄存器结果状态表：将 <code>Fi</code> 条目设为本 FU 的名字。
                d.  更新指令状态表：标记该指令进入“Issue”状态。</p>
                </li>
                <li>
                <p><strong>Read Operands (读操作数阶段)</strong>
                指令在 FU 中等待其源操作数。</p>
                <ul>
                <li><strong>检查</strong>：记分牌持续监控所有 FU 的写回操作。当某个 FU 完成写回时，它会广播其结果和自己的名字。记分牌会检查所有 FU 状态表中的 <code>Qj</code>, <code>Qk</code> 字段，如果哪个字段的名字与刚完成的 FU 匹配，就将其清空，表示它等待的操作数已经就绪。</li>
                <li><strong>决策</strong>：当一条指令所在 FU 的 <code>Qj</code> 和 <code>Qk</code> 字段都为空时，意味着所有源操作数都已在寄存器中就绪。</li>
                <li><strong>动作</strong>：指令可以从寄存器堆中读取操作数，并立即将自己的 <code>Rj</code>, <code>Rk</code> 标志位置为 <code>Yes</code>。指令状态进入“Read Operands”完成状态。</li>
                </ul>
                </li>
                <li>
                <p><strong>Execution (执行阶段)</strong>
                一旦操作数被读取，FU 就开始执行计算。这个过程可能需要多个时钟周期。记分牌只需等待 FU 发出“执行完成”的信号。</p>
                </li>
                <li>
                <p><strong>Write Back (写回阶段)</strong>
                计算完成后，指令准备将结果写回目标寄存器 <code>Fi</code>。</p>
                <ul>
                <li><strong>WAR 相关检查</strong>：<strong>这是记分牌设计中最微妙也最关键的一步</strong>。在写回之前，必须确保没有其他<strong>更早发射的指令</strong>还需要读取 <code>Fi</code> 的<strong>旧值</strong>。记分牌如何检查？它会遍历<strong>所有</strong> FU 的状态表，检查它们的 <code>Fj</code> 和 <code>Fk</code> 字段。</li>
                <li><strong>决策</strong>：如果存在任何一个 FU，其 <code>Fj</code> 或 <code>Fk</code> 等于当前指令的 <code>Fi</code>，并且其对应的 <code>Rj</code> 或 <code>Rk</code> 标志位为 <code>No</code>，则说明有指令还没来得及读取旧值，发生了 WAR 相关。当前指令<strong>必须停顿在写回阶段</strong>，直到所有需要旧值的指令都读取完毕（即所有相关的 <code>R</code> 标志位变为 <code>Yes</code>）。</li>
                <li><strong>动作</strong>：WAR 检查通过后，指令执行写回：
                a.  更新寄存器堆。
                b.  广播自己的名字，以便其他等待它的指令（在其 <code>Qj/Qk</code> 中记录了本 FU）更新状态。
                c.  释放资源：清空自己所在的 FU 状态表条目，清空寄存器结果状态表中对应的条目。</li>
                </ul>
                </li>
                </ol>
                <h4 id="23-%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9C%8B%E6%87%82%E8%AE%B0%E5%88%86%E7%89%8C">2.3 实例详解：一步步看懂记分牌</h4>
                <p>让我们用 经典例子，来手动模拟一遍记分牌的工作流程。假设我们有以下指令序列和硬件资源：1 个整数单元，2 个乘法单元（Mult1, Mult2），1 个加法单元，1 个除法单元。</p>
                <div class="code-container">
                <pre><code class="language-plaintext">L.D     F6, 34(R2)
L.D     F2, 45(R3)
MUL.D   F0, F2, F4
SUB.D   F8, F6, F2
DIV.D   F10, F0, F6
ADD.D   F6, F8, F2
</code></pre>
                </div>
                <p>我们来追踪一个关键时刻的状态，如下所示的状态。这个状态是：所有指令都已发射，第一条 <code>L.D</code> 已经执行完毕但尚未写回，第二条 <code>L.D</code> 正在执行。</p>
                <p><img src="../images/imagea033.png" alt="figure 33">
                <img src="../images/imagea034.png" alt="figure 34"></p>
                <p>让我们来解读这张复杂的表格，理解“为什么”是这个状态：</p>
                <p><strong>指令状态表分析：</strong></p>
                <ul>
                <li><code>L.D F6, 34(R2)</code>：已完成执行，但在“Read Operands”列打勾，实际应理解为停在写回前。为什么停？因为它要写的 F6 被 <code>SUB.D</code> 当作源，而 <code>SUB.D</code> 还未读F6（<code>Rj</code>为No），存在 WAR 相关。</li>
                <li><code>L.D F2, 45(R3)</code>：已读操作数（地址 R3），正在执行（计算有效地址/访存）。</li>
                <li><code>MUL.D F0, F2, F4</code>：已发射，但停在“读操作数”阶段。因为它需要 F2，而 F2 正在由第二条 <code>L.D</code> (在 Integer 单元)产生。</li>
                <li><code>SUB.D F8, F6, F2</code>：已发射，停在“读操作数”。它需要 F6 和 F2，F6 在寄存器中但未读，F2 在等待 <code>L.D</code> 产生。</li>
                <li><code>DIV.D F10, F0, F6</code>：已发射，停在“读操作数”。它需要 F0 和 F6，F0 在等待 <code>MUL.D</code> 产生，F6 在寄存器中但未读。</li>
                <li><code>ADD.D F6, F8, F2</code>：<strong>注意，这条指令在真实情况下会被阻塞在发射阶段</strong>，因为它的目标 F6 与第一条 <code>L.D</code> 相同，存在 WAW 相关。记分牌不允许在第一条 <code>L.D</code> 写回前发射这条指令。</li>
                </ul>
                <p><strong>功能单元状态表分析 (最核心)：</strong></p>
                <ul>
                <li><code>Integer</code> (用于 L.D)：<code>Busy=Yes</code>, <code>Op=Load</code>, 目标<code>Fi=F2</code>。它正在为第二条 <code>L.D</code> 服务。</li>
                <li><code>Mult1</code>：<code>Busy=Yes</code>, <code>Op=Mult</code>, 目标<code>Fi=F0</code>。源是 <code>F2</code> 和 <code>F4</code>。<code>Qj=Integer</code> 表明它在等 Integer 单元产生 F2。<code>Qk</code> 为空表明 F4 是就绪的。</li>
                <li><code>Mult2</code>：<code>Busy=No</code>。空闲。</li>
                <li><code>Add</code>：<code>Busy=Yes</code>, <code>Op=Sub</code>, 目标<code>Fi=F8</code>。源是 <code>F6</code> 和 <code>F2</code>。<code>Qk=Integer</code> 表明它在等 Integer 单元产生 F2。<code>Qj</code> 为空表明 F6 是就绪的。<code>Rj=No</code>表明它<strong>还没读 F6</strong>。</li>
                <li><code>Divide</code>：<code>Busy=Yes</code>, <code>Op=Div</code>, 目标<code>Fi=F10</code>。源是 <code>F0</code> 和 <code>F6</code>。<code>Qj=Mult1</code> 表明它在等 Mult1 单元产生 F0。<code>Qk</code> 为空表明 F6 就绪。<code>Rk=No</code> 表明它<strong>还没读 F6</strong>。</li>
                </ul>
                <p><strong>寄存器结果状态表分析：</strong></p>
                <ul>
                <li><code>F0</code>：将被 <code>Mult1</code> 写入。</li>
                <li><code>F2</code>：将被 <code>Integer</code> 单元（即第二条L.D）写入。</li>
                <li><code>F8</code>：将被 <code>Add</code> 单元（即SUB.D）写入。</li>
                <li><code>F10</code>：将被 <code>Divide</code> 单元写入。</li>
                <li>其他寄存器（如F4, F6）为空，表示它们的值是稳定、可读的。</li>
                </ul>
                <p>通过这个例子，我们可以清晰地看到记分牌是如何通过这三张表，像一个“全知全能”的中央控制器一样，精确地追踪了指令间的依赖关系，并据此来决定每一步的操作。</p>
                <h4 id="24-%E5%AF%B9%E8%AE%B0%E5%88%86%E7%89%8C%E7%9A%84%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E8%80%83%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7">2.4 对记分牌的批判性思考：设计的局限性</h4>
                <p>记分牌作为动态调度的先驱，其设计思想是革命性的。它首次证明了硬件有能力在运行时安全地实现乱序执行。但是，站在今天的角度看，它的设计存在诸多局-限性，这些局限性也正是驱动后续算法（如 Tomasulo 算法）诞生的根本原因。</p>
                <ol>
                <li><strong>集中化的控制瓶颈</strong>：所有的依赖检查和状态更新都由一个集中的记分牌逻辑完成。随着功能单元和指令窗口的增大，这个中央控制器的复杂度和通信开销会急剧上升，成为新的性能瓶颈。</li>
                <li><strong>对 WAW 和 WAR 相关的处理过于保守</strong>：
                <ul>
                <li><strong>WAW (写后写)</strong>：在<strong>发射阶段</strong>检测到 WAW 相关就直接停顿。这阻塞了整个流水线的指令供给。</li>
                <li><strong>WAR (写后读)</strong>：在<strong>写回阶段</strong>检测到 WAR 相关才停顿。虽然没有阻塞发射，但它让一个已经完成计算的功能单元无法释放，占用了宝贵的硬件资源。</li>
                </ul>
                </li>
                <li><strong>缺乏寄存器重命名 (Register Renaming)</strong>：这是导致 WAW 和 WAR 问题无法被高效解决的<strong>根本原因</strong>。<code>ADD.D F6, F8, F2</code> 这条指令与 <code>L.D F6, 34(R2)</code> 竞争 F6 寄存器，这其实是一种<strong>伪相关（Name Dependency）</strong>，因为它们计算的值毫无关系，只是碰巧用了同一个寄存器名字。记分牌无法区分这种伪相关和真正的数据依赖，只能保守地停顿。</li>
                <li><strong>结构相关导致发射停顿</strong>：一旦发射阶段因为找不到空闲 FU 或 WAW 相关而停顿，后续所有指令，哪怕是完全独立的指令，都无法发射。这极大地限制了处理器能够“看到”和调度指令的范围（这个范围我们称之为<strong>指令窗口 (Instruction Window)</strong>）。</li>
                </ol>
                <p>总而言之，记分牌的设计哲学是“<strong>检测并等待</strong>”。它能发现问题，但解决问题的方式主要是“停下来”。虽然相比于纯粹的按序执行已经是一大进步，但这种“等待”的策略，依然浪费了大量的性能潜力。</p>
                <p>如何才能从“检测并等待”进化到“<strong>检测并绕过</strong>”？如何从根本上消除伪相关带来的束缚？这就是我们下一讲要学习的，更为先进的 <strong>Tomasulo 算法</strong>所要解决的问题。</p>
            </article>
        </main>
    </div>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
    <!-- The Modal -->
    <div id="about-me-modal" class="modal">
      <!-- Modal content -->
      <div class="modal-content">
        <span class="close-button">&times;</span>
        <h2>About Me</h2>
        <p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
        <p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
        <p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
        <p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
        <p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
        <p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
        <hr>
        <h3>订阅我的博客</h3>
        <p>订阅功能正在建设中，敬请期待！</p>
      </div>
    </div>
    <script src="../modal.js"></script>
</body>
</html>