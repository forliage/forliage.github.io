<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>计算机组成2-4:过程调用与指令寻址</title>
    
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../modal.css">
    
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
                <li><a href="#" id="about-me-btn">ABOUT ME</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%902-4%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%8E%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80">计算机组成2-4:过程调用与指令寻址</h1>
                <h3 id="%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%AF%BB%E5%9D%80"><strong>第四部分：程序的模块化与寻址</strong></h3>
                <p><strong>本讲提纲：</strong></p>
                <ol start="8">
                <li><strong>构建程序的基石——过程调用</strong>：我们将系统地学习实现一个过程调用所需要的六个步骤，并深入探讨<strong>栈 (Stack)</strong> 这种关键数据结构的作用。我们会学习专门用于过程调用的指令，理解<strong>调用者 (Caller)</strong> 和<strong>被调用者 (Callee)</strong> 之间的协作规约，并区分哪些寄存器需要保存，哪些不需要。</li>
                <li><strong>指令在哪里？——指令寻址</strong>：我们将总结RISC-V中的各种寻址模式，特别是分支和跳转指令是如何计算它们的目标地址的。</li>
                </ol>
                <h3 id="8-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><strong>8. 过程调用</strong></h3>
                <p>过程是结构化编程的核心。一个程序员只需要知道一个过程的功能（它做什么），而无需关心其内部实现（它怎么做），就可以直接使用它。这种抽象能力是构建大型复杂软件系统的关键。</p>
                <p>为了让硬件支持过程调用，必须提供一种机制来完成以下任务。</p>
                <h4 id="81-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%AD%E4%B8%AA%E6%AD%A5%E9%AA%A4"><strong>8.1 过程调用的六个步骤</strong></h4>
                <p>一个完整的函数调用和返回过程，可以分解为以下六个标准步骤：</p>
                <p><strong>调用方 (Caller) 的职责：</strong></p>
                <ol>
                <li><strong>参数传递 (Place Parameters)</strong>：将调用函数时传入的参数，放置在一个被调用函数(Callee)可以访问到的地方。</li>
                <li><strong>转移控制 (Transfer Control)</strong>：跳转到被调用函数的起始指令处开始执行。</li>
                </ol>
                <p><strong>被调用方 (Callee) 的职责：</strong>
                3.  <strong>获取存储资源 (Acquire Storage)</strong>：如果被调用函数需要额外的存储空间（例如，用于局部变量），它需要进行分配。
                4.  <strong>执行任务 (Perform Task)</strong>：执行函数体内的代码，完成指定的功能。</p>
                <p><strong>返回阶段的职责：</strong>
                5.  <strong>返回结果 (Place Result)</strong>：将被调用函数的返回值，放置在一个调用函数(Caller)可以访问到的地方。
                6.  <strong>返回控制 (Return Control)</strong>：跳转回调用函数当初发起调用的<strong>下一条</strong>指令，继续执行。</p>
                <p>这六个步骤构成了一个完整的“调用-返回”协定。现在，我们来逐一揭示RISC-V是如何通过指令集和编程规约来实现它们的。</p>
                <h4 id="82-%E6%AD%A5%E9%AA%A42--6%E6%8E%A7%E5%88%B6%E6%9D%83%E7%9A%84%E8%BD%AC%E7%A7%BB%E4%B8%8E%E8%BF%94%E5%9B%9E"><strong>8.2 步骤2 & 6：控制权的转移与返回</strong></h4>
                <p>这是过程调用中最核心的硬件支持。</p>
                <ul>
                <li><strong>如何跳转到被调用函数？</strong> 我们可以用 <code>beq x0, x0, ProcedureAddress</code> 这样的无条件跳转指令。但这还不够。</li>
                <li><strong>如何返回？</strong> 被调用函数执行完毕后，它必须知道应该返回到<strong>哪里</strong>。这个“返回地址”就是调用指令的下一条指令的地址。</li>
                </ul>
                <p>为了解决这个问题，RISC-V提供了一条专门的指令：</p>
                <p><strong><code>jal rd, Label</code> (Jump and Link)</strong></p>
                <p><code>jal</code> 指令巧妙地<strong>一步完成了两件事</strong>：</p>
                <ol>
                <li><strong>Link (链接)</strong>：将<strong>返回地址</strong>（即 <code>jal</code> 指令自身的地址 + 4）保存到目标寄存器 <code>rd</code> 中。</li>
                <li><strong>Jump (跳转)</strong>：无条件地跳转到 <code>Label</code> 标记的指令处执行。</li>
                </ol>
                <p>按照RISC-V的软件约定，返回地址通常保存在 <strong><code>x1</code></strong> 寄存器中，它有一个别名 <code>ra</code> (Return Address)。所以，一个标准的函数调用是：
                <code>jal ra, ProcedureAddress</code></p>
                <p>现在，被调用函数 <code>ProcedureAddress</code> 知道了返回地址就在 <code>ra</code> 寄存器里。当它执行完毕后，如何返回呢？它需要一条指令，能够跳转到 <code>ra</code> 寄存器里存储的地址。这条指令是：</p>
                <p><strong><code>jalr rd, offset(rs1)</code> (Jump and Link Register)</strong></p>
                <p><code>jalr</code> 指令也非常强大，它跳转的目标地址是<strong>动态计算</strong>出来的：<code>rs1</code> 寄存器的值 + <code>offset</code>。</p>
                <ol>
                <li><strong>Link</strong>：同样，它会把返回地址（<code>jalr</code> 指令地址 + 4）存入 <code>rd</code>。</li>
                <li><strong>Jump</strong>：跳转到 <code>rs1 + offset</code>。</li>
                </ol>
                <p>一个标准的函数返回是：
                <code>jalr x0, 0(ra)</code></p>
                <ul>
                <li><code>rs1</code> 是 <code>ra</code>，<code>offset</code> 是0，所以跳转目标是 <code>ra</code> 寄存器中的地址。</li>
                <li><code>rd</code> 是 <code>x0</code>。<code>x0</code> 寄存器永远为0，写入操作会被硬件忽略。这巧妙地利用了 <code>x0</code> 的特性，使得 <code>jalr</code> 在这里只执行跳转功能，而不保存新的返回地址（因为我们不需要）。</li>
                </ul>
                <h4 id="83-%E6%AD%A5%E9%AA%A41--5%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><strong>8.3 步骤1 & 5：参数传递与返回值</strong></h4>
                <p>参数和返回值需要在调用者和被调用者之间传递。有两种主要方式：</p>
                <ol>
                <li><strong>使用寄存器</strong>：对于少量参数/返回值，这是最快、最高效的方式。</li>
                <li><strong>使用内存</strong>：当参数/返回值数量很多，或者它们是大型数据结构（如数组、结构体）时，需要借助内存。</li>
                </ol>
                <p>RISC-V软件规约约定：</p>
                <ul>
                <li><strong>参数寄存器 (Argument Registers)</strong>：<strong><code>x10</code> - <code>x17</code></strong> (别名 <code>a0</code> - <code>a7</code>) 用于传递最多8个参数。</li>
                <li><strong>返回值寄存器 (Return Value Registers)</strong>：<strong><code>x10</code> - <code>x11</code></strong> (别名 <code>a0</code> - <code>a1</code>) 用于返回最多2个值。</li>
                </ul>
                <h4 id="84-%E6%AD%A5%E9%AA%A43%E4%B8%BA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8"><strong>8.4 步骤3：为局部变量分配存储</strong></h4>
                <p>如果一个函数内部定义了局部变量（如C语言中的自动变量 <code>auto</code>），或者参数数量超过8个，寄存器就不够用了。这时，我们需要在<strong>内存</strong>中为这些数据分配空间。</p>
                <p>这个用于过程调用的内存区域，被称为<strong>栈 (Stack)</strong>。</p>
                <p><strong>栈的特性：</strong></p>
                <ul>
                <li><strong>后进先出 (Last-In, First-Out, LIFO)</strong>：栈就像一个盘子堆，最后放上去的盘子最先被拿走。</li>
                <li><strong>栈指针 (Stack Pointer, <code>sp</code>)</strong>：RISC-V中使用 <code>x2</code> 寄存器（别名 <code>sp</code>）作为栈指针，它始终指向栈顶。</li>
                <li><strong>生长方向</strong>：在RISC-V中，栈从<strong>高地址向低地址生长</strong>。
                <ul>
                <li><strong>入栈 (Push)</strong>：分配空间。将 <code>sp</code> 的值减小。<code>sp = sp - N</code>。</li>
                <li><strong>出栈 (Pop)</strong>：释放空间。将 <code>sp</code> 的值增大。<code>sp = sp + N</code>。</li>
                </ul>
                </li>
                </ul>
                <p><strong>示例：在栈上分配24个字节（3个双字）的空间</strong>
                <code>addi sp, sp, -24</code>  # Push: sp 向低地址移动
                <strong>释放这24个字节</strong>
                <code>addi sp, sp, 24</code>   # Pop: sp 向高地址移动</p>
                <h4 id="85-%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><strong>8.5 寄存器使用的冲突与解决方案</strong></h4>
                <p>现在出现了一个严重的问题：寄存器是全局共享的资源，总共只有32个。当函数 <code>A</code> 调用函数 <code>B</code> 时，函数 <code>B</code> 可能会覆盖掉函数 <code>A</code> 正在使用的某个寄存器里的重要数据。</p>
                <p>例如，函数 <code>A</code> 用 <code>x19</code> 存放一个循环变量 <code>i</code>，然后调用了函数 <code>B</code>。如果 <code>B</code> 为了自己的计算也用了 <code>x19</code>，那么当 <code>B</code> 返回时，<code>A</code> 中的 <code>i</code> 的值就被破坏了。</p>
                <p>为了解决这个问题，RISC-V软件规约将寄存器分为两类：</p>
                <ol>
                <li>
                <p><strong>临时寄存器 (Temporary Registers)</strong>：<strong><code>t0-t6</code> (<code>x5-x7</code>, <code>x28-x31</code>)</strong></p>
                <ul>
                <li><strong>规约</strong>：被调用者 (Callee) <strong>可以随意使用</strong>这些寄存器，<strong>无需恢复</strong>它们原来的值。</li>
                <li><strong>调用者 (Caller) 的责任</strong>：如果调用者在调用一个函数前，某个临时寄存器里有它稍后还需使用的重要数据（称为<strong>活跃数据, live data</strong>），那么调用者<strong>必须</strong>在调用前，自己负责将这个寄存器的值<strong>保存</strong>到栈上，并在调用返回后，再从栈上<strong>恢复</strong>它。</li>
                </ul>
                </li>
                <li>
                <p><strong>保留寄存器 (Saved Registers)</strong>：<strong><code>s0-s11</code> (<code>x8-x9</code>, <code>x18-x27</code>)</strong></p>
                <ul>
                <li><strong>规约</strong>：被调用者 (Callee) 如果要使用这些寄存器，<strong>必须</strong>在函数的开头将它们的原始值<strong>保存</strong>到栈上，并在函数返回前，将它们从栈上<strong>恢复</strong>。</li>
                <li><strong>调用者 (Caller) 的保证</strong>：调用者可以放心地认为，在调用一个函数后，所有保留寄存器的值都和调用前一模一样。</li>
                </ul>
                </li>
                </ol>
                <p><strong><code>ra</code> (<code>x1</code>)</strong> 和<strong>参数寄存器 <code>a0-a7</code></strong> 的行为类似于临时寄存器。</p>
                <p>这个规约精妙地在调用者和被调用者之间分配了保存寄存器的责任，使得双方合作无间。</p>
                <h4 id="86-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%8F%B6%E5%AD%90%E8%BF%87%E7%A8%8B-leaf-procedure"><strong>8.6 过程调用实例：叶子过程 (Leaf Procedure)</strong></h4>
                <p>一个不调用任何其他过程的过程，称为<strong>叶子过程</strong>。</p>
                <p><strong>示例：编译一个叶子过程 <code>leaf_example</code></strong></p>
                <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">leaf_example</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> g, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> h, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> j)</span> </span>{
                    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> f = (g + h) - (i + j);
                    <span class="hljs-keyword">return</span> f;
                }
                </div></code></pre>
                <p><strong>编译步骤：</strong></p>
                <ol>
                <li><strong>参数分配</strong>：<code>g, h, i, j</code> 分别通过 <code>a0-a3</code> (<code>x10-x13</code>) 传入。</li>
                <li><strong>寄存器分配</strong>：
                <ul>
                <li>我们可以用<strong>临时寄存器</strong> <code>t0, t1</code> (<code>x5, x6</code>) 来存放中间结果 <code>g+h</code> 和 <code>i+j</code>。</li>
                <li>最终结果 <code>f</code> 可以直接计算到返回值寄存器 <code>a0</code> (<code>x10</code>) 中。</li>
                </ul>
                </li>
                <li><strong>代码生成</strong>：</li>
                </ol>
                <pre class="hljs"><code><div>leaf_example:
                    add  x5, x10, x11      # t0 = g + h
                    add  x6, x12, x13      # t1 = i + j
                    sub  x10, x5, x6       # f (in a0) = t0 - t1
                    jalr x0, 0(ra)         # return f
                </div></code></pre>
                <p><strong>分析</strong>：这个叶子过程非常简单，它只使用了临时寄存器和参数寄存器。根据规约，它<strong>不需要</strong>在栈上保存任何东西，也<strong>不需要</strong>分配栈空间。</p>
                <h4 id="87-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E9%9D%9E%E5%8F%B6%E5%AD%90%E8%BF%87%E7%A8%8B-non-leaf-procedure"><strong>8.7 过程调用实例：非叶子过程 (Non-leaf Procedure)</strong></h4>
                <p>当一个过程需要调用其他过程时，情况就复杂了。</p>
                <p><strong>示例：编译一个递归计算阶乘的函数 <code>fact</code></strong></p>
                <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
                    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>);
                }
                </div></code></pre>
                <p><strong>分析</strong>：函数 <code>fact</code> 调用了它自身，所以它是一个非叶子过程。</p>
                <ul>
                <li>当 <code>fact(n)</code> 调用 <code>fact(n-1)</code> 时，<code>fact(n)</code> 必须保存两样东西，否则它们会被 <code>fact(n-1)</code> 的调用所覆盖：
                <ol>
                <li><strong>参数 <code>n</code></strong>：因为在 <code>fact(n-1)</code> 返回后，还需要用 <code>n</code> 来做乘法。参数 <code>n</code> 在 <code>a0</code> 中，而 <code>fact(n-1)</code> 的调用会用新的参数 <code>n-1</code> 覆盖 <code>a0</code>。</li>
                <li><strong>返回地址 <code>ra</code></strong>：因为 <code>fact(n-1)</code> 的调用会用新的返回地址（返回到 <code>fact(n)</code> 内部）覆盖掉 <code>ra</code> 原来的值（返回到 <code>fact(n)</code> 的调用者）。</li>
                </ol>
                </li>
                <li><strong>解决方案</strong>：<code>fact</code> 函数必须在栈上分配空间，来保存 <code>n</code> 和 <code>ra</code>。</li>
                </ul>
                <p><strong>RISC-V 代码</strong>：</p>
                <pre class="hljs"><code><div>fact:
                    # 序言 (Prologue): 保存寄存器, 分配栈帧
                    addi sp, sp, -16        # 为 n 和 ra 分配 16 字节栈空间
                    sd   ra, 8(sp)           # 保存返回地址
                    sd   a0, 0(sp)           # 保存参数 n

                    # 检查基本情况: if (n &lt; 1)
                    slti t0, a0, 1          # t0 = (n &lt; 1) ? 1 : 0
                    beq  t0, x0, L1          # if (n &gt;= 1), goto L1

                    # 基本情况: return 1
                    addi a0, x0, 1          # 返回值 a0 = 1
                    # 结尾 (Epilogue): 恢复寄存器, 释放栈帧, 返回
                    addi sp, sp, 16         # 释放栈帧
                    jalr x0, 0(ra)          # 返回 (此时 ra 未被修改)

                L1: # 递归情况
                    # 准备调用 fact(n-1)
                    addi a0, a0, -1         # 参数 a0 = n - 1
                    jal  ra, fact            # 调用 fact(n-1), a0 中是其返回值

                    # 从 fact(n-1) 返回后
                    # 恢复 n 和 ra
                    ld   t1, 0(sp)           # 临时寄存器 t1 = n (从栈中恢复)
                    ld   ra, 8(sp)           # 恢复返回地址
                    addi sp, sp, 16         # 释放栈帧

                    # 计算 n * fact(n-1)
                    mul  a0, t1, a0          # 返回值 a0 = n * fact(n-1)
                    jalr x0, 0(ra)          # 返回
                </div></code></pre>
                <p>这个例子完美地展示了非叶子过程的完整结构：</p>
                <ul>
                <li><strong>序言 (Prologue)</strong>：在函数开头，分配栈帧，保存需要保留的寄存器（<code>s0-s11</code>）和在后续调用中可能被覆盖的活跃数据（如本例中的 <code>ra</code> 和 <code>a0</code>）。</li>
                <li><strong>函数体 (Body)</strong>：执行函数的核心逻辑。</li>
                <li><strong>结尾 (Epilogue)</strong>：在函数返回前，从栈中恢复寄存器，释放栈帧，然后跳转返回。</li>
                </ul>
                <h4 id="88-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><strong>8.8 内存布局</strong></h4>
                <p>一个运行中的程序，其内存通常被划分为以下几个段：</p>
                <ul>
                <li><strong>保留区 (Reserved)</strong>：通常是低地址区域，操作系统保留。</li>
                <li><strong>文本段 (Text Segment)</strong>：存放程序指令（机器码），通常是只读的。</li>
                <li><strong>静态数据段 (Static Data Segment)</strong>：存放全局变量和静态变量。
                <ul>
                <li><strong>全局指针 <code>gp</code> (<code>x3</code>)</strong>：RISC-V 约定 <code>gp</code> 指向静态数据段的中间，这样可以用一个寄存器和有符号偏移量方便地访问整个静态数据区。</li>
                </ul>
                </li>
                <li><strong>动态数据段 (Heap)</strong>：用于程序运行时动态分配的内存（如C语言的 <code>malloc</code>），从低地址向高地址生长。</li>
                <li><strong>栈段 (Stack Segment)</strong>：用于过程调用，存放局部变量、保存的寄存器等，从高地址向低地址生长。</li>
                </ul>
                <h3 id="9-%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><strong>9. 指令寻址</strong></h3>
                <p>寻址模式 (Addressing Mode) 指的是指令如何指定其操作数的地址。我们已经接触过几种：</p>
                <ol>
                <li><strong>寄存器寻址 (Register Addressing)</strong>：操作数在寄存器中，如 <code>add x5, x6, x7</code>。</li>
                <li><strong>基址+偏移量寻址 (Base + Offset Addressing)</strong>：操作数在内存中，地址由 <code>基址寄存器 + 立即数偏移量</code> 得到，如 <code>ld x5, 64(x6)</code>。</li>
                <li><strong>立即数寻址 (Immediate Addressing)</strong>：操作数是指令自身包含的立即数，如 <code>addi x5, x6, 100</code>。</li>
                </ol>
                <p>现在我们关注控制流指令（分支和跳转）是如何确定它们的<strong>目标指令地址</strong>的。</p>
                <h4 id="91-pc-%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80-pc-relative-addressing"><strong>9.1 PC 相对寻址 (PC-Relative Addressing)</strong></h4>
                <p>用于<strong>条件分支指令</strong> (<code>beq</code>, <code>bne</code>, <code>blt</code> 等)。</p>
                <p><strong>动机</strong>：大多数分支的目标都离分支指令本身不远（例如 <code>if</code> 语句和短循环）。
                <strong>原理</strong>：指令中不存放完整的32位或64位目标地址，而是存放一个带符号的<strong>偏移量 (offset)</strong>。目标地址由当前<strong>程序计数器 (Program Counter, PC)</strong> 的值加上这个偏移量得到。
                <code>Target Address = PC + Offset</code></p>
                <p><strong>优点</strong>：</p>
                <ul>
                <li><strong>节省指令空间</strong>：偏移量通常比完整地址短得多，可以节省指令中的宝贵位。</li>
                <li><strong>位置无关代码 (Position-Independent Code)</strong>：由于目标地址是相对当前PC计算的，这段代码无论被加载到内存的哪个位置，分支逻辑都能正常工作，这对于现代操作系统和动态链接库至关重要。</li>
                </ul>
                <p><strong>RISC-V实现细节</strong>：</p>
                <ul>
                <li>分支指令（如SB-type）中的12位立即数表示的是**半字（2字节）**的偏移量。</li>
                <li>实际的字节偏移量是 <code>立即数 &lt;&lt; 1</code>。这是因为RISC-V指令是4字节对齐的，指令地址的最低两位永远是00，没必要在指令中编码。</li>
                <li>PC的值通常是<strong>当前分支指令的地址</strong>。</li>
                </ul>
                <p><strong>示例：<code>beq x5, x6, L1</code></strong>
                假设 <code>beq</code> 指令在地址 <code>80020</code>，目标 <code>L1</code> 在地址 <code>80000</code>。</p>
                <ul>
                <li>偏移量（字节） = <code>80000 - 80020 = -20</code>。</li>
                <li>指令中编码的立即数 = <code>-20 / 2 = -10</code>。</li>
                <li>当CPU执行这条指令时，会计算 <code>PC + (-10 &lt;&lt; 1) = 80020 - 20 = 80000</code>，从而正确跳转。</li>
                </ul>
                <h4 id="92-%E4%BC%AA%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-pseudodirect-addressing"><strong>9.2 伪直接寻址 (Pseudodirect Addressing)</strong></h4>
                <p>用于**<code>jal</code> 指令**。</p>
                <p><strong>动机</strong>：<code>jal</code> 需要比条件分支更大的跳转范围，以支持调用程序中任意位置的函数。
                <strong>原理</strong>：</p>
                <ul>
                <li><code>jal</code> 指令（UJ-type）中有一个20位的立即数。</li>
                <li>目标地址由 <strong>PC + 20位立即数符号扩展后左移1位</strong> 得到。
                <code>Target Address = PC + sign_extend(imm[20:1] &lt;&lt; 1)</code></li>
                <li>这提供了一个大约 $\pm 1 \text{MB}$ 的跳转范围。</li>
                </ul>
                <h4 id="93-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9B%B4%E8%BF%9C%E7%9A%84%E8%B7%B3%E8%BD%AC"><strong>9.3 如何实现更远的跳转？</strong></h4>
                <p>如果需要跳转到超过 $\pm 1 \text{MB}$ 范围之外的地址，或者需要跳转到一个完全由程序动态计算出的32位/64位绝对地址，该怎么办？
                这时需要两条指令的配合：</p>
                <ol>
                <li><strong><code>lui rd, immediate</code> (Load Upper Immediate)</strong>：将一个20位的立即数加载到一个寄存器 <code>rd</code> 的<strong>高20位</strong>，低12位清零。</li>
                <li><strong><code>jalr rd, offset(rs1)</code></strong>：
                <ul>
                <li><code>lui</code> 先构建出目标地址的高位部分并存入一个临时寄存器（比如 <code>t0</code>）。</li>
                <li><code>jalr</code> 再利用其 <code>基址+偏移量</code> 的寻址方式，将 <code>t0</code> 作为基址，用12位的偏移量补上目标地址的低12位，从而构成一个完整的32位地址并跳转。</li>
                </ul>
                </li>
                </ol>
                <p>这个两步过程可以实现对整个32位地址空间的任意跳转。</p>
                <p><strong>本讲小结</strong></p>
                <p>在这一讲，我们完成了对计算机指令集核心功能的探索。</p>
                <ol>
                <li><strong>过程调用支持</strong>：我们详细学习了实现过程调用所需的软硬件协同机制，理解了 <code>jal</code> 和 <code>jalr</code> 指令的精妙设计，掌握了栈在参数传递、局部变量存储和寄存器保存中的关键作用，并明确了调用者和被调用者之间的寄存器使用规约。</li>
                <li><strong>指令寻址</strong>：我们总结了RISC-V的寻址模式，重点分析了用于条件分支的<strong>PC相对寻址</strong>和用于函数调用的<strong>伪直接寻址</strong>，理解了它们的设计动机和实现原理。
                。</li>
                </ol>
            </article>
        </main>
    </div>
    
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
    <!-- The Modal -->
    <div id="about-me-modal" class="modal">
      <!-- Modal content -->
      <div class="modal-content">
        <span class="close-button">&times;</span>
        <h2>About Me</h2>
        <p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
        <p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
        <p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
        <p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
        <p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
        <p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
        <hr>
        <h3>订阅我的博客</h3>
        <p>订阅功能正在建设中，敬请期待！</p>
      </div>
    </div>
    <script src="../modal.js"></script>
</body>
</html>