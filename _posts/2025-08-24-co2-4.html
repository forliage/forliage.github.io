<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<title>计算机组成2-4:过程调用与指令寻址</title>
<link href="../style.css" rel="stylesheet"/>
<link href="../modal.css" rel="stylesheet"/>
<script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" type="text/javascript">
</script>
<!-- Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
<script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
<!-- Highlight.js Themes -->
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/rose-pine-dawn.min.css" id="highlight-theme-link" rel="stylesheet"/>
<!-- Highlight.js Copy Plugin CSS -->
<link href="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.css" rel="stylesheet"/>
</head>
<body>
<audio id="bg-music" loop="" src="../music.mp3"></audio>
<button class="music-control" id="music-toggle">♪</button><button class="dark-mode-control" id="dark-mode-toggle">🌙</button>
<header>
<h1>forliage的blog</h1>
<nav>
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../posts.html">文章</a></li>
<li><a href="../about.html">关于</a></li>
<li><a href="../category.html?category=技术文章">技术文章</a></li>
<li><a href="../category.html?category=生活随笔">生活随笔</a></li>
<li><a href="../category.html?category=学习笔记">学习笔记</a></li>
<li><a href="../category.html?category=心情日记">心情日记</a></li>
<li><a href="#" id="about-me-btn">ABOUT ME</a></li>
</ul>
</nav>
</header>
<div class="container">
<div id="sidebar-container"></div>
<main>
<article>
<h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%902-4%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%8E%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80">计算机组成2-4:过程调用与指令寻址</h1>
<h3 id="%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%AF%BB%E5%9D%80"><strong>第四部分：程序的模块化与寻址</strong></h3>
<p><strong>本讲提纲：</strong></p>
<ol start="8">
<li><strong>构建程序的基石——过程调用</strong>：我们将系统地学习实现一个过程调用所需要的六个步骤，并深入探讨<strong>栈 (Stack)</strong> 这种关键数据结构的作用。我们会学习专门用于过程调用的指令，理解<strong>调用者 (Caller)</strong> 和<strong>被调用者 (Callee)</strong> 之间的协作规约，并区分哪些寄存器需要保存，哪些不需要。</li>
<li><strong>指令在哪里？——指令寻址</strong>：我们将总结RISC-V中的各种寻址模式，特别是分支和跳转指令是如何计算它们的目标地址的。</li>
</ol>
<h3 id="8-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><strong>8. 过程调用</strong></h3>
<p>过程是结构化编程的核心。一个程序员只需要知道一个过程的功能（它做什么），而无需关心其内部实现（它怎么做），就可以直接使用它。这种抽象能力是构建大型复杂软件系统的关键。</p>
<p>为了让硬件支持过程调用，必须提供一种机制来完成以下任务。</p>
<h4 id="81-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%AD%E4%B8%AA%E6%AD%A5%E9%AA%A4"><strong>8.1 过程调用的六个步骤</strong></h4>
<p>一个完整的函数调用和返回过程，可以分解为以下六个标准步骤：</p>
<p><strong>调用方 (Caller) 的职责：</strong></p>
<ol>
<li><strong>参数传递 (Place Parameters)</strong>：将调用函数时传入的参数，放置在一个被调用函数(Callee)可以访问到的地方。</li>
<li><strong>转移控制 (Transfer Control)</strong>：跳转到被调用函数的起始指令处开始执行。</li>
</ol>
<p><strong>被调用方 (Callee) 的职责：</strong>
                3.  <strong>获取存储资源 (Acquire Storage)</strong>：如果被调用函数需要额外的存储空间（例如，用于局部变量），它需要进行分配。
                4.  <strong>执行任务 (Perform Task)</strong>：执行函数体内的代码，完成指定的功能。</p>
<p><strong>返回阶段的职责：</strong>
                5.  <strong>返回结果 (Place Result)</strong>：将被调用函数的返回值，放置在一个调用函数(Caller)可以访问到的地方。
                6.  <strong>返回控制 (Return Control)</strong>：跳转回调用函数当初发起调用的<strong>下一条</strong>指令，继续执行。</p>
<p>这六个步骤构成了一个完整的“调用-返回”协定。现在，我们来逐一揭示RISC-V是如何通过指令集和编程规约来实现它们的。</p>
<h4 id="82-%E6%AD%A5%E9%AA%A42--6%E6%8E%A7%E5%88%B6%E6%9D%83%E7%9A%84%E8%BD%AC%E7%A7%BB%E4%B8%8E%E8%BF%94%E5%9B%9E"><strong>8.2 步骤2 &amp; 6：控制权的转移与返回</strong></h4>
<p>这是过程调用中最核心的硬件支持。</p>
<ul>
<li><strong>如何跳转到被调用函数？</strong> 我们可以用 <code>beq x0, x0, ProcedureAddress</code> 这样的无条件跳转指令。但这还不够。</li>
<li><strong>如何返回？</strong> 被调用函数执行完毕后，它必须知道应该返回到<strong>哪里</strong>。这个“返回地址”就是调用指令的下一条指令的地址。</li>
</ul>
<p>为了解决这个问题，RISC-V提供了一条专门的指令：</p>
<p><strong><code>jal rd, Label</code> (Jump and Link)</strong></p>
<p><code>jal</code> 指令巧妙地<strong>一步完成了两件事</strong>：</p>
<ol>
<li><strong>Link (链接)</strong>：将<strong>返回地址</strong>（即 <code>jal</code> 指令自身的地址 + 4）保存到目标寄存器 <code>rd</code> 中。</li>
<li><strong>Jump (跳转)</strong>：无条件地跳转到 <code>Label</code> 标记的指令处执行。</li>
</ol>
<p>按照RISC-V的软件约定，返回地址通常保存在 <strong><code>x1</code></strong> 寄存器中，它有一个别名 <code>ra</code> (Return Address)。所以，一个标准的函数调用是：
                <code>jal ra, ProcedureAddress</code></p>
<p>现在，被调用函数 <code>ProcedureAddress</code> 知道了返回地址就在 <code>ra</code> 寄存器里。当它执行完毕后，如何返回呢？它需要一条指令，能够跳转到 <code>ra</code> 寄存器里存储的地址。这条指令是：</p>
<p><strong><code>jalr rd, offset(rs1)</code> (Jump and Link Register)</strong></p>
<p><code>jalr</code> 指令也非常强大，它跳转的目标地址是<strong>动态计算</strong>出来的：<code>rs1</code> 寄存器的值 + <code>offset</code>。</p>
<ol>
<li><strong>Link</strong>：同样，它会把返回地址（<code>jalr</code> 指令地址 + 4）存入 <code>rd</code>。</li>
<li><strong>Jump</strong>：跳转到 <code>rs1 + offset</code>。</li>
</ol>
<p>一个标准的函数返回是：
                <code>jalr x0, 0(ra)</code></p>
<ul>
<li><code>rs1</code> 是 <code>ra</code>，<code>offset</code> 是0，所以跳转目标是 <code>ra</code> 寄存器中的地址。</li>
<li><code>rd</code> 是 <code>x0</code>。<code>x0</code> 寄存器永远为0，写入操作会被硬件忽略。这巧妙地利用了 <code>x0</code> 的特性，使得 <code>jalr</code> 在这里只执行跳转功能，而不保存新的返回地址（因为我们不需要）。</li>
</ul>
<h4 id="83-%E6%AD%A5%E9%AA%A41--5%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><strong>8.3 步骤1 &amp; 5：参数传递与返回值</strong></h4>
<p>参数和返回值需要在调用者和被调用者之间传递。有两种主要方式：</p>
<ol>
<li><strong>使用寄存器</strong>：对于少量参数/返回值，这是最快、最高效的方式。</li>
<li><strong>使用内存</strong>：当参数/返回值数量很多，或者它们是大型数据结构（如数组、结构体）时，需要借助内存。</li>
</ol>
<p>RISC-V软件规约约定：</p>
<ul>
<li><strong>参数寄存器 (Argument Registers)</strong>：<strong><code>x10</code> - <code>x17</code></strong> (别名 <code>a0</code> - <code>a7</code>) 用于传递最多8个参数。</li>
<li><strong>返回值寄存器 (Return Value Registers)</strong>：<strong><code>x10</code> - <code>x11</code></strong> (别名 <code>a0</code> - <code>a1</code>) 用于返回最多2个值。</li>
</ul>
<h4 id="84-%E6%AD%A5%E9%AA%A43%E4%B8%BA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8"><strong>8.4 步骤3：为局部变量分配存储</strong></h4>
<p>如果一个函数内部定义了局部变量（如C语言中的自动变量 <code>auto</code>），或者参数数量超过8个，寄存器就不够用了。这时，我们需要在<strong>内存</strong>中为这些数据分配空间。</p>
<p>这个用于过程调用的内存区域，被称为<strong>栈 (Stack)</strong>。</p>
<p><strong>栈的特性：</strong></p>
<ul>
<li><strong>后进先出 (Last-In, First-Out, LIFO)</strong>：栈就像一个盘子堆，最后放上去的盘子最先被拿走。</li>
<li><strong>栈指针 (Stack Pointer, <code>sp</code>)</strong>：RISC-V中使用 <code>x2</code> 寄存器（别名 <code>sp</code>）作为栈指针，它始终指向栈顶。</li>
<li><strong>生长方向</strong>：在RISC-V中，栈从<strong>高地址向低地址生长</strong>。
                <ul>
<li><strong>入栈 (Push)</strong>：分配空间。将 <code>sp</code> 的值减小。<code>sp = sp - N</code>。</li>
<li><strong>出栈 (Pop)</strong>：释放空间。将 <code>sp</code> 的值增大。<code>sp = sp + N</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例：在栈上分配24个字节（3个双字）的空间</strong>
<code>addi sp, sp, -24</code>  # Push: sp 向低地址移动
                <strong>释放这24个字节</strong>
<code>addi sp, sp, 24</code>   # Pop: sp 向高地址移动</p>
<h4 id="85-%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><strong>8.5 寄存器使用的冲突与解决方案</strong></h4>
<p>现在出现了一个严重的问题：寄存器是全局共享的资源，总共只有32个。当函数 <code>A</code> 调用函数 <code>B</code> 时，函数 <code>B</code> 可能会覆盖掉函数 <code>A</code> 正在使用的某个寄存器里的重要数据。</p>
<p>例如，函数 <code>A</code> 用 <code>x19</code> 存放一个循环变量 <code>i</code>，然后调用了函数 <code>B</code>。如果 <code>B</code> 为了自己的计算也用了 <code>x19</code>，那么当 <code>B</code> 返回时，<code>A</code> 中的 <code>i</code> 的值就被破坏了。</p>
<p>为了解决这个问题，RISC-V软件规约将寄存器分为两类：</p>
<ol>
<li>
<p><strong>临时寄存器 (Temporary Registers)</strong>：<strong><code>t0-t6</code> (<code>x5-x7</code>, <code>x28-x31</code>)</strong></p>
<ul>
<li><strong>规约</strong>：被调用者 (Callee) <strong>可以随意使用</strong>这些寄存器，<strong>无需恢复</strong>它们原来的值。</li>
<li><strong>调用者 (Caller) 的责任</strong>：如果调用者在调用一个函数前，某个临时寄存器里有它稍后还需使用的重要数据（称为<strong>活跃数据, live data</strong>），那么调用者<strong>必须</strong>在调用前，自己负责将这个寄存器的值<strong>保存</strong>到栈上，并在调用返回后，再从栈上<strong>恢复</strong>它。</li>
</ul>
</li>
<li>
<p><strong>保留寄存器 (Saved Registers)</strong>：<strong><code>s0-s11</code> (<code>x8-x9</code>, <code>x18-x27</code>)</strong></p>
<ul>
<li><strong>规约</strong>：被调用者 (Callee) 如果要使用这些寄存器，<strong>必须</strong>在函数的开头将它们的原始值<strong>保存</strong>到栈上，并在函数返回前，将它们从栈上<strong>恢复</strong>。</li>
<li><strong>调用者 (Caller) 的保证</strong>：调用者可以放心地认为，在调用一个函数后，所有保留寄存器的值都和调用前一模一样。</li>
</ul>
</li>
</ol>
<p><strong><code>ra</code> (<code>x1</code>)</strong> 和<strong>参数寄存器 <code>a0-a7</code></strong> 的行为类似于临时寄存器。</p>
<p>这个规约精妙地在调用者和被调用者之间分配了保存寄存器的责任，使得双方合作无间。</p>
<h4 id="86-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%8F%B6%E5%AD%90%E8%BF%87%E7%A8%8B-leaf-procedure"><strong>8.6 过程调用实例：叶子过程 (Leaf Procedure)</strong></h4>
<p>一个不调用任何其他过程的过程，称为<strong>叶子过程</strong>。</p>
<p><strong>示例：编译一个叶子过程 <code>leaf_example</code></strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">leaf_example</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> g, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> h, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> j)</span> </span>{
                    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> f = (g + h) - (i + j);
                    <span class="hljs-keyword">return</span> f;
                }
                </div></code></pre>
<p><strong>编译步骤：</strong></p>
<ol>
<li><strong>参数分配</strong>：<code>g, h, i, j</code> 分别通过 <code>a0-a3</code> (<code>x10-x13</code>) 传入。</li>
<li><strong>寄存器分配</strong>：
                <ul>
<li>我们可以用<strong>临时寄存器</strong> <code>t0, t1</code> (<code>x5, x6</code>) 来存放中间结果 <code>g+h</code> 和 <code>i+j</code>。</li>
<li>最终结果 <code>f</code> 可以直接计算到返回值寄存器 <code>a0</code> (<code>x10</code>) 中。</li>
</ul>
</li>
<li><strong>代码生成</strong>：</li>
</ol>
<pre class="hljs"><code><div>leaf_example:
                    add  x5, x10, x11      # t0 = g + h
                    add  x6, x12, x13      # t1 = i + j
                    sub  x10, x5, x6       # f (in a0) = t0 - t1
                    jalr x0, 0(ra)         # return f
                </div></code></pre>
<p><strong>分析</strong>：这个叶子过程非常简单，它只使用了临时寄存器和参数寄存器。根据规约，它<strong>不需要</strong>在栈上保存任何东西，也<strong>不需要</strong>分配栈空间。</p>
<h4 id="87-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E9%9D%9E%E5%8F%B6%E5%AD%90%E8%BF%87%E7%A8%8B-non-leaf-procedure"><strong>8.7 过程调用实例：非叶子过程 (Non-leaf Procedure)</strong></h4>
<p>当一个过程需要调用其他过程时，情况就复杂了。</p>
<p><strong>示例：编译一个递归计算阶乘的函数 <code>fact</code></strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
                    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>);
                }
                </div></code></pre>
<p><strong>分析</strong>：函数 <code>fact</code> 调用了它自身，所以它是一个非叶子过程。</p>
<ul>
<li>当 <code>fact(n)</code> 调用 <code>fact(n-1)</code> 时，<code>fact(n)</code> 必须保存两样东西，否则它们会被 <code>fact(n-1)</code> 的调用所覆盖：
                <ol>
<li><strong>参数 <code>n</code></strong>：因为在 <code>fact(n-1)</code> 返回后，还需要用 <code>n</code> 来做乘法。参数 <code>n</code> 在 <code>a0</code> 中，而 <code>fact(n-1)</code> 的调用会用新的参数 <code>n-1</code> 覆盖 <code>a0</code>。</li>
<li><strong>返回地址 <code>ra</code></strong>：因为 <code>fact(n-1)</code> 的调用会用新的返回地址（返回到 <code>fact(n)</code> 内部）覆盖掉 <code>ra</code> 原来的值（返回到 <code>fact(n)</code> 的调用者）。</li>
</ol>
</li>
<li><strong>解决方案</strong>：<code>fact</code> 函数必须在栈上分配空间，来保存 <code>n</code> 和 <code>ra</code>。</li>
</ul>
<p><strong>RISC-V 代码</strong>：</p>
<pre class="hljs"><code><div>fact:
                    # 序言 (Prologue): 保存寄存器, 分配栈帧
                    addi sp, sp, -16        # 为 n 和 ra 分配 16 字节栈空间
                    sd   ra, 8(sp)           # 保存返回地址
                    sd   a0, 0(sp)           # 保存参数 n

                    # 检查基本情况: if (n &lt; 1)
                    slti t0, a0, 1          # t0 = (n &lt; 1) ? 1 : 0
                    beq  t0, x0, L1          # if (n &gt;= 1), goto L1

                    # 基本情况: return 1
                    addi a0, x0, 1          # 返回值 a0 = 1
                    # 结尾 (Epilogue): 恢复寄存器, 释放栈帧, 返回
                    addi sp, sp, 16         # 释放栈帧
                    jalr x0, 0(ra)          # 返回 (此时 ra 未被修改)

                L1: # 递归情况
                    # 准备调用 fact(n-1)
                    addi a0, a0, -1         # 参数 a0 = n - 1
                    jal  ra, fact            # 调用 fact(n-1), a0 中是其返回值

                    # 从 fact(n-1) 返回后
                    # 恢复 n 和 ra
                    ld   t1, 0(sp)           # 临时寄存器 t1 = n (从栈中恢复)
                    ld   ra, 8(sp)           # 恢复返回地址
                    addi sp, sp, 16         # 释放栈帧

                    # 计算 n * fact(n-1)
                    mul  a0, t1, a0          # 返回值 a0 = n * fact(n-1)
                    jalr x0, 0(ra)          # 返回
                </div></code></pre>
<p>这个例子完美地展示了非叶子过程的完整结构：</p>
<ul>
<li><strong>序言 (Prologue)</strong>：在函数开头，分配栈帧，保存需要保留的寄存器（<code>s0-s11</code>）和在后续调用中可能被覆盖的活跃数据（如本例中的 <code>ra</code> 和 <code>a0</code>）。</li>
<li><strong>函数体 (Body)</strong>：执行函数的核心逻辑。</li>
<li><strong>结尾 (Epilogue)</strong>：在函数返回前，从栈中恢复寄存器，释放栈帧，然后跳转返回。</li>
</ul>
<h4 id="88-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><strong>8.8 内存布局</strong></h4>
<p>一个运行中的程序，其内存通常被划分为以下几个段：</p>
<ul>
<li><strong>保留区 (Reserved)</strong>：通常是低地址区域，操作系统保留。</li>
<li><strong>文本段 (Text Segment)</strong>：存放程序指令（机器码），通常是只读的。</li>
<li><strong>静态数据段 (Static Data Segment)</strong>：存放全局变量和静态变量。
                <ul>
<li><strong>全局指针 <code>gp</code> (<code>x3</code>)</strong>：RISC-V 约定 <code>gp</code> 指向静态数据段的中间，这样可以用一个寄存器和有符号偏移量方便地访问整个静态数据区。</li>
</ul>
</li>
<li><strong>动态数据段 (Heap)</strong>：用于程序运行时动态分配的内存（如C语言的 <code>malloc</code>），从低地址向高地址生长。</li>
<li><strong>栈段 (Stack Segment)</strong>：用于过程调用，存放局部变量、保存的寄存器等，从高地址向低地址生长。</li>
</ul>
<h3 id="9-%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><strong>9. 指令寻址</strong></h3>
<p>寻址模式 (Addressing Mode) 指的是指令如何指定其操作数的地址。我们已经接触过几种：</p>
<ol>
<li><strong>寄存器寻址 (Register Addressing)</strong>：操作数在寄存器中，如 <code>add x5, x6, x7</code>。</li>
<li><strong>基址+偏移量寻址 (Base + Offset Addressing)</strong>：操作数在内存中，地址由 <code>基址寄存器 + 立即数偏移量</code> 得到，如 <code>ld x5, 64(x6)</code>。</li>
<li><strong>立即数寻址 (Immediate Addressing)</strong>：操作数是指令自身包含的立即数，如 <code>addi x5, x6, 100</code>。</li>
</ol>
<p>现在我们关注控制流指令（分支和跳转）是如何确定它们的<strong>目标指令地址</strong>的。</p>
<h4 id="91-pc-%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80-pc-relative-addressing"><strong>9.1 PC 相对寻址 (PC-Relative Addressing)</strong></h4>
<p>用于<strong>条件分支指令</strong> (<code>beq</code>, <code>bne</code>, <code>blt</code> 等)。</p>
<p><strong>动机</strong>：大多数分支的目标都离分支指令本身不远（例如 <code>if</code> 语句和短循环）。
                <strong>原理</strong>：指令中不存放完整的32位或64位目标地址，而是存放一个带符号的<strong>偏移量 (offset)</strong>。目标地址由当前<strong>程序计数器 (Program Counter, PC)</strong> 的值加上这个偏移量得到。
                <code>Target Address = PC + Offset</code></p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>节省指令空间</strong>：偏移量通常比完整地址短得多，可以节省指令中的宝贵位。</li>
<li><strong>位置无关代码 (Position-Independent Code)</strong>：由于目标地址是相对当前PC计算的，这段代码无论被加载到内存的哪个位置，分支逻辑都能正常工作，这对于现代操作系统和动态链接库至关重要。</li>
</ul>
<p><strong>RISC-V实现细节</strong>：</p>
<ul>
<li>分支指令（如SB-type）中的12位立即数表示的是**半字（2字节）**的偏移量。</li>
<li>实际的字节偏移量是 <code>立即数 &lt;&lt; 1</code>。这是因为RISC-V指令是4字节对齐的，指令地址的最低两位永远是00，没必要在指令中编码。</li>
<li>PC的值通常是<strong>当前分支指令的地址</strong>。</li>
</ul>
<p><strong>示例：<code>beq x5, x6, L1</code></strong>
                假设 <code>beq</code> 指令在地址 <code>80020</code>，目标 <code>L1</code> 在地址 <code>80000</code>。</p>
<ul>
<li>偏移量（字节） = <code>80000 - 80020 = -20</code>。</li>
<li>指令中编码的立即数 = <code>-20 / 2 = -10</code>。</li>
<li>当CPU执行这条指令时，会计算 <code>PC + (-10 &lt;&lt; 1) = 80020 - 20 = 80000</code>，从而正确跳转。</li>
</ul>
<h4 id="92-%E4%BC%AA%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-pseudodirect-addressing"><strong>9.2 伪直接寻址 (Pseudodirect Addressing)</strong></h4>
<p>用于**<code>jal</code> 指令**。</p>
<p><strong>动机</strong>：<code>jal</code> 需要比条件分支更大的跳转范围，以支持调用程序中任意位置的函数。
                <strong>原理</strong>：</p>
<ul>
<li><code>jal</code> 指令（UJ-type）中有一个20位的立即数。</li>
<li>目标地址由 <strong>PC + 20位立即数符号扩展后左移1位</strong> 得到。
                <code>Target Address = PC + sign_extend(imm[20:1] &lt;&lt; 1)</code></li>
<li>这提供了一个大约 $\pm 1 \text{MB}$ 的跳转范围。</li>
</ul>
<h4 id="93-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9B%B4%E8%BF%9C%E7%9A%84%E8%B7%B3%E8%BD%AC"><strong>9.3 如何实现更远的跳转？</strong></h4>
<p>如果需要跳转到超过 $\pm 1 \text{MB}$ 范围之外的地址，或者需要跳转到一个完全由程序动态计算出的32位/64位绝对地址，该怎么办？
                这时需要两条指令的配合：</p>
<ol>
<li><strong><code>lui rd, immediate</code> (Load Upper Immediate)</strong>：将一个20位的立即数加载到一个寄存器 <code>rd</code> 的<strong>高20位</strong>，低12位清零。</li>
<li><strong><code>jalr rd, offset(rs1)</code></strong>：
                <ul>
<li><code>lui</code> 先构建出目标地址的高位部分并存入一个临时寄存器（比如 <code>t0</code>）。</li>
<li><code>jalr</code> 再利用其 <code>基址+偏移量</code> 的寻址方式，将 <code>t0</code> 作为基址，用12位的偏移量补上目标地址的低12位，从而构成一个完整的32位地址并跳转。</li>
</ul>
</li>
</ol>
<p>这个两步过程可以实现对整个32位地址空间的任意跳转。</p>
<p><strong>本讲小结</strong></p>
<p>在这一讲，我们完成了对计算机指令集核心功能的探索。</p>
<ol>
<li><strong>过程调用支持</strong>：我们详细学习了实现过程调用所需的软硬件协同机制，理解了 <code>jal</code> 和 <code>jalr</code> 指令的精妙设计，掌握了栈在参数传递、局部变量存储和寄存器保存中的关键作用，并明确了调用者和被调用者之间的寄存器使用规约。</li>
<li><strong>指令寻址</strong>：我们总结了RISC-V的寻址模式，重点分析了用于条件分支的<strong>PC相对寻址</strong>和用于函数调用的<strong>伪直接寻址</strong>，理解了它们的设计动机和实现原理。
                。</li>
</ol>
</article><div class="share-buttons">
<p>分享到：</p>
<a class="share-btn weibo" href="#" onclick="sharePost(event, 'weibo')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Sina Weibo</title><path d="M10.098 20.323c-3.977.391-7.414-1.406-7.672-4.02-.259-2.609 2.759-5.047 6.74-5.441 3.979-.394 7.413 1.404 7.671 4.018.259 2.6-2.759 5.049-6.737 5.439l-.002.004zM9.05 17.219c-.384.616-1.208.884-1.829.602-.612-.279-.793-.991-.406-1.593.379-.595 1.176-.861 1.793-.601.622.263.82.972.442 1.592zm1.27-1.627c-.141.237-.449.353-.689.253-.236-.09-.313-.361-.177-.586.138-.227.436-.346.672-.24.239.09.315.36.18.601l.014-.028zm.176-2.719c-1.893-.493-4.033.45-4.857 2.118-.836 1.704-.026 3.591 1.886 4.21 1.983.64 4.318-.341 5.132-2.179.8-1.793-.201-3.642-2.161-4.149zm7.563-1.224c-.346-.105-.57-.18-.405-.615.375-.977.42-1.804 0-2.404-.781-1.112-2.915-1.053-5.364-.03 0 0-.766.331-.571-.271.376-1.217.315-2.224-.27-2.809-1.338-1.337-4.869.045-7.888 3.08C1.309 10.87 0 13.273 0 15.348c0 3.981 5.099 6.395 10.086 6.395 6.536 0 10.888-3.801 10.888-6.82 0-1.822-1.547-2.854-2.915-3.284v.01zm1.908-5.092c-.766-.856-1.908-1.187-2.96-.962-.436.09-.706.511-.616.932.09.42.511.691.932.602.511-.105 1.067.044 1.442.465.376.421.466.977.316 1.473-.136.406.089.856.51.992.405.119.857-.105.992-.512.33-1.021.12-2.178-.646-3.035l.03.045zm2.418-2.195c-1.576-1.757-3.905-2.419-6.054-1.968-.496.104-.812.587-.706 1.081.104.496.586.813 1.082.707 1.532-.331 3.185.15 4.296 1.383 1.112 1.246 1.429 2.943.947 4.416-.165.48.106 1.007.586 1.157.479.165.991-.104 1.157-.586.675-2.088.241-4.478-1.338-6.235l.03.045z"></path></svg>
<span>微博</span>
</a>
<a class="share-btn twitter" href="#" onclick="sharePost(event, 'twitter')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M21.543 7.104c.015.211.015.423.015.636 0 6.507-4.954 14.01-14.01 14.01v-.003A13.94 13.94 0 0 1 0 19.539a9.88 9.88 0 0 0 7.287-2.041 4.93 4.93 0 0 1-4.6-3.42 4.916 4.916 0 0 0 2.223-.084A4.926 4.926 0 0 1 .96 9.167v-.062a4.887 4.887 0 0 0 2.235.616A4.928 4.928 0 0 1 1.67 3.148 13.98 13.98 0 0 0 11.82 8.292a4.929 4.929 0 0 1 8.39-4.49 9.868 9.868 0 0 0 3.128-1.196 4.941 4.941 0 0 1-2.165 2.724A9.828 9.828 0 0 0 24 4.555a10.019 10.019 0 0 1-2.457 2.549z"></path></svg>
<span>Twitter</span>
</a>
<a class="share-btn linkedin" href="#" onclick="sharePost(event, 'linkedin')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg>
<span>LinkedIn</span>
</a>
<a class="share-btn wechat" href="#" onclick="sharePost(event, 'wechat')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>WeChat</title><path d="M8.691 2.188C3.891 2.188 0 5.476 0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59 0 0 1 .213.665l-.39 1.48c-.019.07-.048.141-.048.213 0 .163.13.295.29.295a.326.326 0 0 0 .167-.054l1.903-1.114a.864.864 0 0 1 .717-.098 10.16 10.16 0 0 0 2.837.403c.276 0 .543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178A1.17 1.17 0 0 1 4.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813 0c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178 1.17 1.17 0 0 1-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826 0 1.622-.12 2.361-.336a.722.722 0 0 1 .598.082l1.584.926a.272.272 0 0 0 .14.047c.134 0 .24-.111.24-.247 0-.06-.023-.12-.038-.177l-.327-1.233a.582.582 0 0 1-.023-.156.49.49 0 0 1 .201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.97-.982zm4.844 0c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.969-.982z"></path></svg>
<span>微信</span>
</a>
<a class="share-btn qq" href="#" onclick="sharePost(event, 'qq')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Tencent QQ</title><path d="M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673"></path></svg>
<span>QQ</span>
</a>
<a class="share-btn facebook" href="#" onclick="sharePost(event, 'facebook')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Facebook</title><path d="M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z"></path></svg>
<span>Facebook</span>
</a>
</div>
<div class="giscus-container" style="margin-top: 50px;">
<script async="" crossorigin="anonymous" data-category="Announcements" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-mapping="pathname" data-reactions-enabled="1" data-repo="forliage/forliage.github.io" data-repo-id="R_kgDONjzd4w" data-strict="0" data-theme="https://forliage.github.io/giscus.css" src="https://giscus.app/client.js">
</script>
</div>


</main>
</div>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
<script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
<div class="dock">
  <a href="https://forliage.github.io/index.html">🏠</a>
  <a href="https://forliage.github.io/posts.html">📚</a>
  <a href="https://forliage.github.io/about.html">👤</a>
</div>
<script src="../script.js"></script>
<!-- The Modal -->
<div class="modal" id="about-me-modal">
<!-- Modal content -->
<div class="modal-content">
<span class="close-button">×</span>
<h2>About Me</h2>
<p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
<p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
<p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
<p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
<p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
<p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
<hr/>
<h3>订阅我的博客</h3>
<p>订阅功能正在建设中，敬请期待！</p>
</div>
</div>
<script src="../modal.js"></script><script src="../trail.js"></script>
<!-- Highlight.js Core -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- Highlight.js Copy Plugin -->
<script src="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.js"></script>
<!-- Initialize Highlight.js and Copy Plugin -->
<script>
  hljs.highlightAll();
  hljs.addPlugin(new CopyButtonPlugin());
</script>
</body>
</html>