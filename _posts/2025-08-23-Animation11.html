<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<title>计算机动画11:布料动画</title>
<link href="../style.css" rel="stylesheet"/>
<link href="../modal.css" rel="stylesheet"/>
<script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" type="text/javascript">
</script>
<!-- Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
<script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
</head>
<body>
<audio id="bg-music" loop="" src="../music.mp3"></audio>
<button class="music-control" id="music-toggle">♪</button><button class="dark-mode-control" id="dark-mode-toggle">🌙</button>
<header>
<h1>forliage的blog</h1>
<nav>
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../posts.html">文章</a></li>
<li><a href="../about.html">关于</a></li>
<li><a href="../category.html?category=技术文章">技术文章</a></li>
<li><a href="../category.html?category=生活随笔">生活随笔</a></li>
<li><a href="../category.html?category=学习笔记">学习笔记</a></li>
<li><a href="../category.html?category=心情日记">心情日记</a></li>
<li><a href="#" id="about-me-btn">ABOUT ME</a></li>
</ul>
</nav>
</header>
<div class="container">
<div id="sidebar-container"></div>
<main>
<article>
<h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A8%E7%94%BB12%E5%B8%83%E6%96%99%E5%8A%A8%E7%94%BB">计算机动画11:布料动画</h1>
<h3 id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%B8%83%E6%96%99%E5%8A%A8%E7%94%BB"><strong>第一部分：为什么我们需要布料动画？</strong></h3>
<p>在我们深入技术细节之前，首先要明白，我们为什么要投入如此多的精力来研究布料动画。</p>
<h4 id="11-%E5%B8%83%E6%96%99%E7%9A%84%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E4%B8%8E%E7%9C%9F%E5%AE%9E%E6%84%9F%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><strong>1.1 布料的无处不在与真实感的重要性</strong></h4>
<p>布料在我们的日常生活中随处可见：衣服、窗帘、桌布、旗帜等等。在计算机动画中，这些元素同样频繁出现。想象一个游戏角色，如果他穿着一件像钢板一样坚硬的袍子，那整个场景的真实感都会大打折扣。</p>
<p>据统计，<strong>衣服平均覆盖了人体80%以上的表面积</strong>。因此，要让一个虚拟角色的动画达到令人满意的细节和真实感，逼真的布料动画是不可或缺的一环。它能够极大地提升视觉效果的沉浸感。</p>
<p>我们可以通过一个简单的对比来感受技术的进步。</p>
<p>早期（大约2002年）的效果，人物身上的大衣显得比较僵硬，动态不足。而近年（2020年左右）的效果，这件连帽衫的褶皱、光影和动态都非常自然。这种飞跃式的提升，正是布料模拟技术不断发展的结果。</p>
<p>同样，在电影工业中，这种进步也显而易见。比较2005年的《极地快车》和2019年的《阿丽塔：战斗天使》，我们可以看到后者中角色的衣物在质感、褶皱和与身体的交互上都达到了新的高度。</p>
<h4 id="12-%E5%B9%BF%E6%B3%9B%E7%9A%84%E8%A1%8C%E4%B8%9A%E5%BA%94%E7%94%A8"><strong>1.2 广泛的行业应用</strong></h4>
<p>布料动画不仅仅是为了好看，它在许多行业都有着至关重要的应用：</p>
<ul>
<li><strong>动画与游戏产业</strong>：这是最直观的应用。从《精灵鼠小弟2》中那只小老鼠身上的毛衣，到《上古卷轴》系列中角色华丽的法袍，逼真的布料效果是构建可信虚拟世界的基石。</li>
<li><strong>时装与纺织工业</strong>：传统服装设计需要制作实体样衣，成本高、周期长。而借助如 <code>Marvelous Designer</code> 或 <code>CLO 3D</code> 这样的软件，设计师可以直接在虚拟模特身上进行3D服装设计，实时看到面料的悬垂和褶皱效果，极大地改变了设计流程。</li>
<li><strong>电子商务与虚拟试衣</strong>：大家网购衣服时最大的痛点是什么？无法试穿！而虚拟试衣技术正在解决这个问题。2014年，电商巨头eBay就收购了3D虚拟试衣公司PhiSix。这项技术允许用户上传自己的照片或三维模型，在线“试穿”衣服，直观地看到上身效果，从而提升购物体验。</li>
</ul>
<h3 id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%B8%83%E6%96%99%E5%8A%A8%E7%94%BB%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98"><strong>第二部分：布料动画的核心挑战</strong></h3>
<p>既然布料动画如此重要，为什么它又被认为是图形学中最具挑战性的问题之一呢？这主要源于布料自身复杂的物理特性和模拟过程中的技术难点。</p>
<p>我们可以将生成一套完整的服装动画分解为四个核心步骤，每一步都充满了挑战。</p>
<div class="mermaid">graph TD
                    A["1. 服装设计与建模<br/>(Modeling)"] --&gt; B["2. 布料物理模型与求解<br/>(Physics &amp; Solving)"];
                    B --&gt; C["3. 布料与人体碰撞检测<br/>(Collision Detection)"];
                    B -- 仿真模拟 --&gt; C;
                    C --&gt; D["4. 服装布料渲染<br/>(Rendering)"];

                    style A fill:#cde4ff
                    style B fill:#e5d4ff
                    style C fill:#f8d5d5
                    style D fill:#d4e8d4
                </div>
<h4 id="21-%E6%8C%91%E6%88%98%E4%B8%80%E5%BB%BA%E6%A8%A1-modeling"><strong>2.1 挑战一：建模 (Modeling)</strong></h4>
<p>与真实的服装制作类似，虚拟服装也需要从2D的裁片（Pattern）开始，然后将这些裁片“缝合”起来。这要求动画师理解服装的结构。同时，衣服有各种款式、尺寸，甚至还有厚度，这些都增加了建模的复杂性。</p>
<h4 id="22-%E6%8C%91%E6%88%98%E4%BA%8C%E6%B8%B2%E6%9F%93-rendering"><strong>2.2 挑战二：渲染 (Rendering)</strong></h4>
<p>布料的视觉外观极其复杂。</p>
<ul>
<li><strong>复杂的材质</strong>：不同质地的衣服（如棉、丝、毛呢）对光的反射、散射方式完全不同。图形学中理想化的光照模型（如Phong模型）往往难以真实再现这些细节。</li>
<li><strong>微观结构</strong>：布料是由纱线编织而成的，这种微观结构会产生独特的视觉效果，例如各向异性的高光（Anisotropic Highlights），即高光会沿着纱线方向延伸。</li>
<li><strong>半透明与次表面散射</strong>：一些薄纱类的材质具有半透明效果，光线可以穿透并被散射，这需要更复杂的渲染算法来模拟。</li>
</ul>
<h4 id="23-%E6%8C%91%E6%88%98%E4%B8%89%E5%8A%A8%E7%94%BB%E4%B8%8E%E4%BB%BF%E7%9C%9F-animation--simulation"><strong>2.3 挑战三：动画与仿真 (Animation &amp; Simulation)</strong></h4>
<p>这是所有挑战中的核心。布料的动态行为是由其复杂的物理力学性质决定的。</p>
<ul>
<li><strong>建立物理模型</strong>：我们需要一个数学模型来描述布料如何响应力。这个模型必须能体现布料的<strong>拉伸（Stretch）</strong>、**剪切（Shear）<strong>和</strong>弯曲（Bend）**等特性。</li>
<li><strong>求解物理模型</strong>：布料的运动可以用一组复杂的偏微分方程来描述。求解这些方程需要强大的数值方法，并且对计算速度和稳定性有很高的要求。</li>
<li><strong>碰撞检测与响应</strong>：这是最棘手的部分之一。
                <ul>
<li>衣服需要与角色身体发生碰撞。</li>
<li>衣服自身可能会发生折叠，即<strong>自碰撞（Self-collision）</strong>。</li>
<li>当角色穿着多层衣服时（如衬衫外套着夹克），层与层之间的碰撞处理起来异常复杂。</li>
<li>像胳肢窝这样狭窄且活动剧烈的区域，是碰撞检测的“重灾区”。</li>
</ul>
</li>
</ul>
<p>这三个环节，物理模型、数值求解、碰撞处理，是<strong>密切相关、互相影响</strong>的。一个环节处理不好，整个模拟就会失败。</p>
<h4 id="24-%E6%B7%B1%E5%B1%82%E6%8C%91%E6%88%98%E4%BB%8E%E6%9D%90%E6%96%99%E7%A7%91%E5%AD%A6%E8%A7%92%E5%BA%A6%E7%9C%8B%E5%B8%83%E6%96%99"><strong>2.4 深层挑战：从材料科学角度看布料</strong></h4>
<p>为什么布料的物理模型如此难建？因为<strong>织物本质上不是一种均质的材料 (Material)，而是一种精巧的结构 (Structure)。</strong></p>
<ul>
<li><strong>不同的织法，不同的结构</strong>：
                <ul>
<li><strong>编织布 (Woven Cloth)</strong>：由两组互相垂直的纱线（经纱和纬纱）交织而成，像棋盘格一样。这种结构在经纬方向上抗拉伸能力强，但容易发生剪切变形（想象一下斜着拉扯一块方巾）。</li>
<li><strong>针织布 (Knit Cloth)</strong>：由一根或多根纱线弯曲成线圈，再相互串套而成。这种结构弹性好，易于拉伸，我们日常穿的T恤、毛衣大多是针织物。</li>
</ul>
</li>
</ul>
<div class="mermaid">graph TD
                    subgraph "布料的种类"
                        subgraph "编织布 (Woven)"
                            W1("经纱 (Warp)")
                            W2("纬纱 (Weft)")
                            W1 -- 垂直交织 --&gt; W2
                        end
                        subgraph "针织布 (Knit)"
                            K1("纱线弯曲成线圈")
                            K2("线圈相互串套")
                            K1 --&gt; K2
                        end
                    end
                </div>
<ul>
<li><strong>多层次的复杂性</strong>：
                <ul>
<li><strong>宏观 (Macro)</strong>：我们看到的是由不同织造方法形成的薄板形柔性材料。</li>
<li><strong>细观 (Meso)</strong>：构成布料的是短纤或长丝组成的纱线。纱线的捻度、纤维的抱合方式都影响着其力学性能。</li>
<li><strong>微观 (Micro)</strong>：纱线由高分子材料构成（如棉纤维是纤维素，毛纤维是蛋白质）。</li>
</ul>
</li>
</ul>
<p>这就导致了一个根本性的难题：<strong>即使是同样材料（如棉）、同样粗细的纱线，如果织法不同，最终得到的布料力学性能也会千差万别。</strong> 这种“结构决定性能”的特性，使得从第一性原理精确预测织物的力学性能成为一个自1937年以来都未能完美解决的难题。</p>
<p>我们目前在图形学中使用的模型，都是对这种复杂结构的高度简化。</p>
<h3 id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><strong>第三部分：布料模拟技术发展历程</strong></h3>
<p>了解了挑战之后，我们来看看图形学界的先驱们是如何一步步攻克这些难题的。布料模拟方法大致可以分为三类：几何方法、物理方法和混合方法。</p>
<div class="mermaid">graph LR
                    A[几何方法] --&gt; B[物理方法];
                    B --&gt; C[混合方法];
                    subgraph 物理方法
                        B1[连续体模型 / 有限元法]
                        B2[质点-弹簧模型]
                        B3[隐式积分法]
                        B4[近似隐式法]
                        B5[PBD]
                    end
                </div>
<h4 id="31-%E5%87%A0%E4%BD%95%E6%96%B9%E6%B3%95-geometric-methods"><strong>3.1 几何方法 (Geometric Methods)</strong></h4>
<p>在计算机硬件性能孱弱的早期，直接进行物理仿真是不可想象的。因此，研究者们另辟蹊径。几何方法<strong>不关心真实的物理动力学</strong>，而是用一些几何约束和规则来“伪造”出布料的外观，特别是静态的褶皱和悬垂。</p>
<ul>
<li><strong>优点</strong>：计算效率极高，不需要求解微分方程。</li>
<li><strong>缺点</strong>：表现力有限，真实感不足，无法模拟布料的动态过程。</li>
</ul>
<p><strong>经典案例：Weil的悬链线模型 (1986)</strong></p>
<p>J. Weil提出了一种非常巧妙的方法来模拟悬垂的布料。他观察到，一根绳子在重力作用下自然下垂时形成的曲线，在数学上被称为<strong>悬链线 (Catenary)</strong>，其函数形式是<strong>双曲余弦函数</strong> $\cosh(x)$。</p>
<p>Weil 的核心思想是：将一块布料看作是由无数悬链线组成的网络。</p>
<ol>
<li><strong>基本单元</strong>：将布料网格中的一些顶点（约束点）固定住。</li>
<li><strong>计算悬垂</strong>：任意两个约束点之间的布料，可以近似看作一条悬链线。通过计算这条悬链线的形状，就可以确定布料的下垂形态。</li>
<li><strong>递归细分</strong>：为了增加细节，他将一个大三角形细分成两个小三角形，沿着新的边再生成一条悬链线，如此往复，最终得到非常自然的悬垂效果。</li>
</ol>
<p>这个方法虽然简单，但效果在当时非常惊艳。不过它的局限性也很明显：只能生成静态的悬垂形态，无法响应外部的力或者动起来。</p>
<h4 id="32-%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95-physical-methods"><strong>3.2 物理方法 (Physical Methods)</strong></h4>
<p>随着计算能力的提升，基于物理的模拟方法成为了主流。这类方法根据布料的物理性质（质量、弹性等）和牛顿运动定律来构建数学模型，从而计算出布料的动态行为。</p>
<h5 id="321-%E6%97%A9%E6%9C%9F%E7%9A%84%E7%89%A9%E7%90%86%E6%A8%A1%E5%9E%8B-%E8%83%BD%E9%87%8F%E6%9C%80%E5%B0%8F%E5%8C%96"><strong>3.2.1 早期的物理模型 (能量最小化)</strong></h5>
<p><strong>Feynman的模型 (1986)</strong></p>
<p>C. Feynman（是的，就是那位著名物理学家的儿子）在他的硕士论文中提出了一个基于能量最小化的模型。其核心思想是：<strong>系统在平衡状态时，其总能量最低。</strong></p>
<p>他定义了布料的总能量 $E$ 为三个部分之和：
                $$E(P_{i,j}) = k_e E_{\text{elast}}^{i,j} + k_b E_{\text{blend}}^{i,j} + k_g E_{\text{grav}}^{i,j}$$</p>
<ul>
<li>$E_{\text{elast}}$: <strong>弹性能量</strong>，与布料的拉伸有关。</li>
<li>$E_{\text{blend}}$: <strong>弯曲能量</strong>，与布料的弯曲有关。</li>
<li>$E_{\text{grav}}$: <strong>重力势能</strong>，与布料的高度有关。</li>
<li>$k_e, k_b, k_g$: 分别是弹性、弯曲和密度的常数。</li>
</ul>
<p>通过使用数值优化算法（如梯度下降法）找到使总能量 $E$ 最小的顶点位置，就可以得到布料的平衡形态。</p>
<p><strong>Breen的粒子系统模型 (1994)</strong></p>
<p>Breen等人将布料表示为一套相互作用的粒子系统。每个粒子代表布料上的一小块质量。粒子之间存在各种能量项（排斥、拉伸、弯曲等）。同样，通过最小化整个系统的总能量来求解布料的悬垂形态。</p>
<p>这些早期方法的共同点是，它们主要用于求解<strong>静态平衡</strong>问题，即布料最终悬垂的样子，而无法模拟其<strong>动态过程</strong>。</p>
<h5 id="322-%E5%8A%A8%E6%80%81%E6%A8%A1%E6%8B%9F%E7%9A%84%E5%BC%80%E7%AB%AF%E8%BF%9E%E7%BB%AD%E4%BB%8B%E8%B4%A8%E5%8A%9B%E5%AD%A6"><strong>3.2.2 动态模拟的开端：连续介质力学</strong></h5>
<p><strong>Terzopoulos的动力学模型 (1987)</strong></p>
<p>Terzopoulos等人的工作是该领域的里程碑。他们首次将布料视为一个<strong>弹性连续体 (Elastically Deformable Body)</strong>，并用一个二阶偏微分方程来描述其运动：
                $$\mu \frac{\partial^2 \mathbf{r}}{\partial t^2} + \gamma \frac{\partial \mathbf{r}}{\partial t} + \frac{\delta E(\mathbf{r})}{\delta \mathbf{r}} = \mathbf{f}(\mathbf{r}, t)$$
                这个方程其实就是牛顿第二定律的连续介质版本，让我们逐项解析：</p>
<ul>
<li>$\mathbf{r}$: 布料上某一点的位置。</li>
<li>$\mu \frac{\partial^2 \mathbf{r}}{\partial t^2}$: <strong>惯性力</strong>（质量 $\times$ 加速度）。</li>
<li>$\gamma \frac{\partial \mathbf{r}}{\partial t}$: <strong>阻尼力</strong>（阻尼系数 $\times$ 速度），模拟能量耗散，如空气阻力。</li>
<li>$\frac{\delta E(\mathbf{r})}{\delta \mathbf{r}}$: <strong>内力</strong>，由布料变形（拉伸、弯曲）产生的恢复力，是弹性能量 $E$ 的梯度。</li>
<li>$\mathbf{f}(\mathbf{r}, t)$: <strong>外力</strong>，如重力、风力等。</li>
</ul>
<p>这个方程提供了模拟变形体的坚实物理基础。为了在计算机上求解，通常使用<strong>有限元法 (FEM)</strong> 或<strong>有限差分法 (FDM)</strong> 将连续的布料离散化为网格，然后进行数值求解。</p>
<ul>
<li><strong>优点</strong>：物理基础扎实，理论上可以达到很高的精度。</li>
<li><strong>缺点</strong>：算法复杂，计算量巨大，稳定性差，在当时很难做到实时。</li>
</ul>
<h5 id="323-%E8%B4%A8%E7%82%B9-%E5%BC%B9%E7%B0%A7%E6%A8%A1%E5%9E%8B-mass-spring-system"><strong>3.2.3 质点-弹簧模型 (Mass-Spring System)</strong></h5>
<p>由于连续介质力学模型过于复杂，一种更简单、更直观的模型——<strong>质点-弹簧模型</strong>应运而生，并迅速成为业界和学界的主流。Xavier Provot (1995) 的工作是其中的经典。</p>
<p><strong>模型构造</strong></p>
<p>其核心思想非常简单：将布料离散化为一系列<strong>质点 (Mass)</strong>，质点之间用无质量的<strong>弹簧 (Spring)</strong> 连接。</p>
<p>为了模拟布料的不同力学特性，我们通常需要三种类型的弹簧：</p>
<ol>
<li><strong>结构弹簧 (Structural Springs)</strong>：连接相邻的质点（水平和垂直方向）。它们主要抵抗<strong>拉伸</strong>。</li>
<li><strong>剪切弹簧 (Shear Springs)</strong>：连接对角线的质点。它们主要抵抗<strong>剪切</strong>变形，防止菱形变成平行四边形。</li>
<li><strong>弯曲弹簧 (Bending Springs)</strong>：跨越一个质点连接更远的质点（例如，连接 <code>(i, j)</code> 和 <code>(i+2, j)</code>）。它们主要抵抗<strong>弯曲</strong>，让布料有一定的硬度，不会像纸一样轻易折叠。</li>
</ol>
<div class="mermaid">graph TD
                    subgraph "质点-弹簧模型"
                        A((i, j-1)); B((i, j)); C((i, j+1));
                        D((i-1, j)); E((i+1, j));
                        F((i-1, j-1)); G((i+1, j-1)); H((i-1, j+1)); I((i+1, j+1));
                        J((i, j-2)); K((i, j+2)); L((i-2, j)); M((i+2, j));

                        %% 结构弹簧 (Structural)
                        B --&gt; A;
                        B --&gt; C;
                        B --&gt; D;
                        B --&gt; E;

                        %% 剪切弹簧 (Shear)
                        B -.-&gt; F;
                        B -.-&gt; G;
                        B -.-&gt; H;
                        B -.-&gt; I;

                        %% 弯曲弹簧 (Bending)
                        B --- J;
                        B --- K;
                        B --- L;
                        B --- M;
                        
                        %% 样式定义
                        linkStyle 0,1,2,3 stroke:red,stroke-width:2px;
                        linkStyle 4,5,6,7 stroke:blue,stroke-width:2px,stroke-dasharray: 3 3;
                        linkStyle 8,9,10,11 stroke:green,stroke-width:2px,stroke-dasharray: 8 4;
                    end
                </div>
<p><strong>数据结构</strong></p>
<p>在代码实现中，我们需要定义质点和弹簧的结构：</p>
<pre class="hljs"><code><div><span class="hljs-comment">// C++</span>
                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Particle</span> {</span>
                    <span class="hljs-keyword">float</span> mass;         <span class="hljs-comment">// 质量</span>
                    <span class="hljs-keyword">bool</span> is_fixed;      <span class="hljs-comment">// 是否固定不动</span>
                    glm::vec3 position;   <span class="hljs-comment">// 当前位置</span>
                    glm::vec3 velocity;   <span class="hljs-comment">// 当前速度</span>
                    glm::vec3 force;      <span class="hljs-comment">// 累加的力</span>
                    glm::vec3 old_position; <span class="hljs-comment">// 用于Verlet积分等</span>
                };

                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Spring</span> {</span>
                    Particle* p1;       <span class="hljs-comment">// 连接的质点1</span>
                    Particle* p2;       <span class="hljs-comment">// 连接的欠点2</span>
                    <span class="hljs-keyword">float</span> rest_length;  <span class="hljs-comment">// 弹簧静止长度</span>
                    <span class="hljs-keyword">float</span> stiffness;    <span class="hljs-comment">// 弹簧劲度系数 (k)</span>
                    <span class="hljs-keyword">float</span> damping;      <span class="hljs-comment">// 阻尼系数</span>
                };
                </div></code></pre>
<p><strong>物理计算</strong></p>
<p>对于连接质点 $i$ 和 $j$ 的弹簧，它在质点 $i$ 上产生的力 $\mathbf{f}_{i,j}$ 可以用<strong>胡克定律 (Hooke's Law)</strong> 来计算：
                $$\mathbf{f}_{i,j} = -k_{ij} (|\mathbf{x}_j - \mathbf{x}_i| - l_{ij}^0) \frac{\mathbf{x}_j - \mathbf{x}_i}{|\mathbf{x}_j - \mathbf{x}_i|}$$</p>
<ul>
<li>$k_{ij}$: 弹簧的劲度系数（stiffness）。</li>
<li>$\mathbf{x}_i, \mathbf{x}_j$: 质点 $i$ 和 $j$ 的位置向量。</li>
<li>$l_{ij}^0$: 弹簧的静止长度（rest length）。</li>
<li>$|\mathbf{x}_j - \mathbf{x}_i|$: 弹簧的当前长度。</li>
<li>$\frac{\mathbf{x}_j - \mathbf{x}_i}{|\mathbf{x}_j - \mathbf{x}_i|}$: 从 $i$ 指向 $j$ 的单位向量，表示力的方向。</li>
</ul>
<p>这个公式的含义是：弹簧的力与它的形变量（当前长度 - 静止长度）成正比。如果被拉长，力是拉力；如果被压缩，力是推力。</p>
<p>一个质点 $i$ 受到的总内力 $\mathbf{f}_i$ 就是所有与之相连的弹簧施加的力的矢量和：
                $$\mathbf{f}_i = \sum_{(i,j) \in E} \mathbf{f}_{i,j}$$
                其中 $E$ 是所有弹簧的集合。</p>
<p><strong>如何确定弹簧参数？</strong></p>
<p>$k$ 值（劲度系数）如何设置？这是一个关键问题。我们可以手动调试，但这非常不直观。在工业界，会使用专门的仪器，如 <strong>FAST织物客观力学物理性能测试系统</strong>，来测量真实布料的拉伸、弯曲、剪切等性能，然后将这些物理数据映射为我们模型中的弹簧参数。例如，<code>弯曲强度</code> 这个参数，在软件中通常表现为一个滑块，它直接影响弯曲弹簧的劲度系数。</p>
<ul>
<li><strong>加大弯曲强度</strong>：布料变硬，像牛仔布和皮革。</li>
<li><strong>减小弯曲强度</strong>：布料变软，垂顺感好，像丝绸。</li>
</ul>
<p><strong>时间积分 (Time Integration)</strong></p>
<p>有了力，我们就可以根据牛顿第二定律 $\mathbf{F} = m\mathbf{a}$ 来更新每个质点的状态（位置和速度）。这个随时间更新状态的过程叫做<strong>时间积分</strong>。</p>
<p>最简单的方法是<strong>显式欧拉法 (Explicit Euler Method)</strong>。
                假设我们知道在时间 $t$ 的状态，我们想要求解时间 $t+h$ (其中 $h$ 是一个很小的时间步长) 的状态：</p>
<ol>
<li><strong>计算总力</strong>：$\mathbf{f}^t = \sum \mathbf{f}_{\text{springs}} + \mathbf{f}_{\text{gravity}} + \dots$</li>
<li><strong>计算加速度</strong>：$\mathbf{a}^t = \mathbf{f}^t / m$</li>
<li><strong>更新速度</strong>：$\mathbf{v}^{t+h} = \mathbf{v}^t + h \cdot \mathbf{a}^t$</li>
<li><strong>更新位置</strong>：$\mathbf{x}^{t+h} = \mathbf{x}^t + h \cdot \mathbf{v}^t$</li>
</ol>
<p>注意，更新位置用的是旧的速度 $\mathbf{v}^t$。一个小的改进是使用<strong>半隐式欧拉法 (Semi-implicit Euler)</strong>，也叫 <strong>Symplectic Euler</strong>，在更新位置时使用新的速度 $\mathbf{v}^{t+h}$，这样系统能量更稳定：
                4. (改进) <strong>更新位置</strong>：$\mathbf{x}^{t+h} = \mathbf{x}^t + h \cdot \mathbf{v}^{t+h}$</p>
<p>整合起来，更新公式为：
                $$\begin{cases} \mathbf{a}^{t+h} = \mathbf{M}^{-1}\mathbf{f}^t \\ \mathbf{v}^{t+h} = \mathbf{v}^t + h\mathbf{a}^{t+h} \\ \mathbf{x}^{t+h} = \mathbf{x}^t + h\mathbf{v}^{t+h} \end{cases} \implies \begin{pmatrix} \mathbf{v}^{t+h} \\ \mathbf{x}^{t+h} \end{pmatrix} = \begin{pmatrix} \mathbf{v}^{t} + h\mathbf{M}^{-1}\mathbf{f}^t \\ \mathbf{x}^{t} + h\mathbf{v}^{t+h} \end{pmatrix}$$</p>
<p><strong>显式方法的优点</strong>：</p>
<ul>
<li><strong>简单快速</strong>：每一步的计算非常直接，没有复杂的方程求解。</li>
<li><strong>易于并行</strong>：每个质点的状态更新可以独立计算。</li>
</ul>
<p><strong>显式方法的致命缺点：不稳定性</strong></p>
<p>显式欧拉法是<strong>有条件稳定</strong>的。这意味着时间步长 $h$ 必须足够小。存在一个临界值 $H$，一旦 $h &gt; H$，数值计算就会发散，导致模拟结果“爆炸”。</p>
<p>这个临界值 $H$ 与系统中弹簧的最大劲度系数 $K$ 和质点的质量 $M$ 有关，大致满足：
                $H \approx \pi \sqrt{\frac{M}{K}}$
                这意味着：<strong>弹簧越硬 (K越大)，允许的时间步长就越小。</strong></p>
<p>这就造成了一个两难的困境：</p>
<ul>
<li>为了模拟硬朗的布料（如牛仔布），我们需要设置很大的 $K$ 值。</li>
<li>这迫使我们必须使用极小的时间步长 $h$，导致计算量剧增，动画变得非常缓慢。</li>
<li>如果我们为了提高效率而使用较大的 $h$，又想保持较大的 $K$，模拟就会不稳定。</li>
<li>如果我们为了稳定而减小 $K$ 值，布料又会变得异常柔软和拉伸，产生 Provot 称之为**“超弹性” (Super-elasticity)** 的不真实现象。</li>
</ul>
<p><strong>Provot的约束变形模型</strong></p>
<p>为了解决这个问题，Provot 提出了一种实用的妥协方案：</p>
<ol>
<li>在模拟时使用较小的弹簧刚度，以保证可以使用一个较大的时间步长 $h$ 而不失稳。</li>
<li>在每个时间步计算完成后，检查所有弹簧的长度。</li>
<li>如果发现某个弹簧被过度拉伸（超过其静止长度的一定比例，比如10%），就<strong>强制地</strong>将两个质点沿弹簧方向拉近，使其长度回到允许的范围内。</li>
</ol>
<p>这个方法本质上是在模拟之后进行一个几何校正，它将超弹性效应分散到整块布料中，虽然物理上不完全精确，但在视觉上取得了很好的效果。</p>
<h5 id="324-%E5%A4%A7%E6%AD%A5%E9%95%BF%E6%A8%A1%E6%8B%9F%E9%9A%90%E5%BC%8F%E7%A7%AF%E5%88%86%E6%B3%95-implicit-methods"><strong>3.2.4 大步长模拟：隐式积分法 (Implicit Methods)</strong></h5>
<p>要从根本上解决稳定性问题，我们需要更强大的数学工具——<strong>隐式积分法</strong>。这方面的开创性工作由 Baraff 和 Witkin (1998) 完成，他们的论文《Large steps in cloth simulation》是该领域的必读经典。</p>
<p><strong>核心思想</strong></p>
<p>显式欧拉法不稳定的根源在于，它使用<strong>当前</strong>的力来预测<strong>未来</strong>的状态。想象一下一个被过度拉伸的弹簧，它会产生巨大的拉力，这个拉力作用于整个时间步 $h$，导致质点以极高的速度飞向对方，在下一个时刻可能就飞过头了，导致弹簧被极度压缩，产生更大的反向力，如此往复，振荡越来越大，最终崩溃。</p>
<p>隐式欧拉法的思想则完全不同：<strong>它使用未来的力来计算未来的状态。</strong>
                公式如下：
                $$\mathbf{v}^{t+h} = \mathbf{v}^t + h \cdot \mathbf{a}^{t+h} = \mathbf{v}^t + h \mathbf{M}^{-1}\mathbf{f}^{t+h}$$
                $$\mathbf{x}^{t+h} = \mathbf{x}^t + h \cdot \mathbf{v}^{t+h}$$</p>
<p>这里的关键是 $\mathbf{f}^{t+h}$，即在<strong>未来时刻 $t+h$</strong> 的力。这个力取决于未来时刻的位置 $\mathbf{x}^{t+h}$ 和速度 $\mathbf{v}^{t+h}$。这就形成了一个<strong>循环依赖</strong>：为了求未来的状态，需要知道未来的力；而未来的力又依赖于未来的状态。</p>
<p><strong>数学推导与求解</strong></p>
<ol>
<li>
<p><strong>线性化</strong>：由于 $\mathbf{f}$ 是关于 $\mathbf{x}$ 和 $\mathbf{v}$ 的复杂非线性函数，我们无法直接求解。我们可以用一阶泰勒展开来近似 $\mathbf{f}^{t+h}$：
                $$\mathbf{f}^{t+h} \approx \mathbf{f}^t + \frac{\partial \mathbf{f}}{\partial \mathbf{x}} \Delta \mathbf{x} + \frac{\partial \mathbf{f}}{\partial \mathbf{v}} \Delta \mathbf{v}$$
                其中，$\Delta \mathbf{x} = \mathbf{x}^{t+h} - \mathbf{x}^t = h \mathbf{v}^{t+h}$，$\Delta \mathbf{v} = \mathbf{v}^{t+h} - \mathbf{v}^t$。</p>
</li>
<li>
<p><strong>构建方程</strong>：将这个近似代入到隐式欧拉法的速度更新公式中：
                $$\mathbf{v}^{t+h} = \mathbf{v}^t + h \mathbf{M}^{-1} \left( \mathbf{f}^t + \frac{\partial \mathbf{f}}{\partial \mathbf{x}} (h \mathbf{v}^{t+h}) + \frac{\partial \mathbf{f}}{\partial \mathbf{v}} (\mathbf{v}^{t+h} - \mathbf{v}^t) \right)$$</p>
</li>
<li>
<p><strong>整理未知数</strong>：我们的目标是求解 $\mathbf{v}^{t+h}$。我们将所有包含 $\mathbf{v}^{t+h}$ 的项移到等式左边，已知的项留在右边：
                $$\left( \mathbf{I} - h^2 \mathbf{M}^{-1} \frac{\partial \mathbf{f}}{\partial \mathbf{x}} - h \mathbf{M}^{-1} \frac{\partial \mathbf{f}}{\partial \mathbf{v}} \right) \mathbf{v}^{t+h} = \mathbf{v}^t + h \mathbf{M}^{-1} \mathbf{f}^t - h \mathbf{M}^{-1} \frac{\partial \mathbf{f}}{\partial \mathbf{v}} \mathbf{v}^t$$</p>
</li>
<li>
<p><strong>线性系统</strong>：这是一个形如 $\mathbf{A}\mathbf{x} = \mathbf{b}$ 的大型线性方程组。</p>
<ul>
<li>$\mathbf{A} = \left( \mathbf{I} - h^2 \mathbf{M}^{-1} \frac{\partial \mathbf{f}}{\partial \mathbf{x}} - h \mathbf{M}^{-1} \frac{\partial \mathbf{f}}{\partial \mathbf{v}} \right)$ 是一个巨大的矩阵（如果有个 $N$ 质点，每个质点3个坐标，那么这个矩阵就是 $3N \times 3N$）。</li>
<li>$\mathbf{x} = \mathbf{v}^{t+h}$ 是我们要求解的未知量（所有质点的未来速度）。</li>
<li>$\mathbf{b}$ 是右侧的已知量。</li>
</ul>
<p>矩阵 $\frac{\partial \mathbf{f}}{\partial \mathbf{x}}$ 和 $\frac{\partial \mathbf{f}}{\partial \mathbf{v}}$ 是雅可比矩阵（Jacobian Matrix），它们描述了力如何随位置和速度的变化而变化。幸运的是，由于每个质点的力只受近邻质点的影响，这个 $\mathbf{A}$ 矩阵是<strong>稀疏</strong>的（大部分元素为零）。</p>
</li>
<li>
<p><strong>求解</strong>：我们可以使用为稀疏矩阵优化的迭代求解器，如<strong>共轭梯度法 (Conjugate Gradient)</strong>，来高效地求解这个线性系统。</p>
</li>
</ol>
<p><strong>优缺点</strong>：</p>
<ul>
<li><strong>优点</strong>：<strong>无条件稳定</strong>。理论上，无论时间步长 $h$ 取多大，系统都不会“爆炸”。这使得我们可以用远大于显式法的步长进行模拟（例如，直接使用动画帧率对应的步长，如1/30秒），极大地提高了效率。</li>
<li><strong>缺点</strong>：<strong>计算开销大</strong>。每一步都需要构建并求解一个大型线性方程组，这比显式法要复杂和耗时得多。</li>
</ul>
<p><strong>自适应步长</strong>：在实践中，虽然理论上稳定，但过大的步长会导致精度下降（能量耗散），模拟看起来不自然。因此，Baraff 和 Witkin 还采用了<strong>自适应调整步长</strong>的策略：在每一步计算后检查数值误差，如果误差过大，就减小步长重新计算；如果误差很小，则可以尝试增 大步长。</p>
<h5 id="325-%E5%AE%9E%E6%97%B6%E4%BA%A4%E4%BA%92%E7%9A%84%E6%8E%A2%E7%B4%A2%E8%BF%91%E4%BC%BC%E9%9A%90%E5%BC%8F%E6%B3%95%E4%B8%8Epbd"><strong>3.2.5 实时交互的探索：近似隐式法与PBD</strong></h5>
<p>隐式方法虽然稳定，但对于需要实时交互的游戏等场景，每帧求解线性方程组的开销还是太大了。于是，研究者们开始寻找更快的替代方案。</p>
<p><strong>近似隐式法 (Desbrun et al. 1999)</strong></p>
<p>Desbrun 等人观察到，在很多情况下，那个巨大的系统矩阵 $\mathbf{A}$ 的变化并不剧烈。他们提出一个大胆的简化：<strong>假设 $\mathbf{A}$ 是一个常量矩阵！</strong>
                这样，我们就可以<strong>预先计算</strong>出它的逆矩阵 $\mathbf{A}^{-1}$。
                那么，每一步的求解就变成了一个简单的矩阵-向量乘法：
                $$\Delta \mathbf{v} = \mathbf{A}^{-1} \mathbf{b}$$
                这个计算速度极快，可以满足实时要求。</p>
<ul>
<li><strong>优点</strong>：速度快，可以实时。</li>
<li><strong>缺点</strong>：近似误差较大，物理真实性下降，且当模型很大时，预计算和存储稠密的逆矩阵 $\mathbf{A}^{-1}$ 的开销变得无法承受。</li>
</ul>
<p><strong>位置动力学 (Position Based Dynamics, PBD) (Müller et al. 2007)</strong></p>
<p>PBD 是近年来游戏和实时应用领域的一场革命。它完全抛弃了基于力的思考方式，转向了一种更直接、更几何的思路。</p>
<p><strong>核心思想</strong>：
                传统的模拟流程是：<strong>力 $\rightarrow$ 加速度 $\rightarrow$ 速度 $\rightarrow$ 位置</strong>。
                PBD 的流程是：</p>
<ol>
<li><strong>预测位置</strong>：忽略力，直接根据当前速度预测出一个“试探性”的新位置：$\mathbf{x}_{\text{pred}} = \mathbf{x}^t + h \mathbf{v}^t$。</li>
<li><strong>满足约束</strong>：这个预测的位置很可能违反了物理约束（比如，弹簧被拉长了）。PBD 的核心就在于，通过一个迭代过程，<strong>直接调整质点的位置</strong>，使其尽可能地满足所有的约束。</li>
<li><strong>更新速度</strong>：所有约束都满足后，根据位置的实际变化来反推出新的速度：$\mathbf{v}^{t+h} = (\mathbf{x}^{t+h} - \mathbf{x}^t) / h$。</li>
</ol>
<p><strong>约束求解</strong>
                以一个简单的距离约束（弹簧）为例：</p>
<ul>
<li>两个质点 $p_1, p_2$ 应该保持距离 $d$。</li>
<li>在预测步骤后，它们的距离变成了 $d'$, 位置分别是 $\mathbf{x}_1, \mathbf{x}_2$。</li>
<li>我们需要计算一个位移修正量 $\Delta \mathbf{x}_1, \Delta \mathbf{x}_2$，使得 <code>| (x1 + Δx1) - (x2 + Δx2) | = d</code>。</li>
<li>最简单的修正方法是沿着两点连线方向，将它们各自推开或拉近半个误差的距离。</li>
</ul>
<p>PBD 采用一个类似<strong>高斯-赛德尔 (Gauss-Seidel)</strong> 的迭代方法：在一个循环中，依次遍历所有的约束，并立即应用位置修正。重复这个循环几次（通常3-10次），系统就会收敛到一个所有约束都被较好满足的状态。</p>
<pre class="hljs"><code><div><span class="hljs-comment">// PBD 模拟循环伪代码</span>
                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">simulation_step</span><span class="hljs-params">(<span class="hljs-keyword">float</span> h)</span> </span>{
                    <span class="hljs-comment">// 1. 预测位置 (Predict positions)</span>
                    <span class="hljs-keyword">for</span> (Particle&amp; p : particles) {
                        <span class="hljs-keyword">if</span> (!p.is_fixed) {
                            p.velocity += h * gravity;
                            p.predicted_position = p.position + h * p.velocity;
                        }
                    }

                    <span class="hljs-comment">// 2. 迭代求解约束 (Solve constraints)</span>
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; solver_iterations; ++i) {
                        <span class="hljs-keyword">for</span> (Constraint&amp; c : constraints) {
                            c.project(particles); <span class="hljs-comment">// 直接修改 predicted_position</span>
                        }
                    }

                    <span class="hljs-comment">// 3. 更新速度和位置 (Update velocity and position)</span>
                    <span class="hljs-keyword">for</span> (Particle&amp; p : particles) {
                        <span class="hljs-keyword">if</span> (!p.is_fixed) {
                            p.velocity = (p.predicted_position - p.position) / h;
                            p.position = p.predicted_position;
                        }
                    }
                }
                </div></code></pre>
<ul>
<li><strong>优点</strong>：<strong>非常快速、稳定且易于控制</strong>。即使在极端情况下也不会“爆炸”。可以轻松处理各种复杂的约束（碰撞、体积保持等）。因此，成为了现代游戏引擎（如 Bullet, PhysX）的首选方法。</li>
<li><strong>缺点</strong>：<strong>物理不精确</strong>。它的行为依赖于迭代次数和约束处理顺序，缺乏坚实的力学基础，但对于追求视觉可信度的实时应用来说，这完全可以接受。</li>
</ul>
<h3 id="%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><strong>第四部分：前沿技术与未来展望</strong></h3>
<p>布料模拟领域的研究远未停止，新的思想和方法层出不穷。</p>
<h4 id="41-%E6%8F%90%E5%8D%87%E7%89%A9%E7%90%86%E7%9C%9F%E5%AE%9E%E6%84%9F%E8%80%83%E8%99%91%E5%B1%88%E6%9B%B2"><strong>4.1 提升物理真实感：考虑屈曲</strong></h4>
<p><strong>Choi &amp; Ko 的稳定但反应灵敏的布料模型 (2002)</strong></p>
<p>传统的质点-弹簧模型有一个问题：它对拉伸和压缩的处理是对称的。但真实的薄布料在受到压缩时，并不会产生很大的抵抗力，而是会立刻<strong>屈曲 (Buckling)</strong>，形成褶皱。</p>
<p>Choi 和 Ko 的模型专门解决了这个问题。</p>
<ul>
<li>他们认为，用于表示面内作用关系的弹簧（结构弹簧和剪切弹簧），<strong>不应该表现出大的压缩抗力</strong>。</li>
<li>他们设计了一种非线性的弹簧模型，该模型在受拉时表现正常，但在受压时，其抵抗力非常小，能量会迅速转移到弯曲模式上，从而产生自然的褶皱。</li>
<li>为了实现这一点，他们使用了两种弹簧连接：<strong>顺序连接</strong>（抗拉伸和剪切）和<strong>隔行连接</strong>（抗弯曲和微弱的抗压缩）。</li>
</ul>
<p>这个模型能产生非常丰富和逼真的织物褶皱效果。</p>
<h4 id="42-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><strong>4.2 数据驱动与机器学习</strong></h4>
<p>近年来，随着机器学习的兴起，数据驱动的方法也进入了布料模拟领域。</p>
<ul>
<li><strong>基于实例的合成 (Example-based Synthesis)</strong>：预先对一件衣服在各种姿态下的变形进行物理模拟，并存入数据库。在运行时，根据角色的新姿态，从数据库中快速检索和融合最相似的几个样本，从而“合成”出新的服装形态。这种方法可以非常快，但依赖于高质量的预计算数据。</li>
<li><strong>基于深度学习的仿真</strong>：训练一个深度神经网络来学习布料的动态行为。输入是当前衣物的状态和角色的动作，输出是下一帧衣物的状态。这种方法绕过了复杂的物理方程求解，直接学习输入到输出的映射。例如，2022年Siggraph的一篇论文就使用了骨骼驱动的运动网络来预测宽松衣物的变形。</li>
</ul>
<h4 id="43-%E6%9C%8D%E8%A3%85%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%81%E7%A7%BB"><strong>4.3 服装设计与迁移</strong></h4>
<p>研究者们还在探索更智能的服装设计工具，例如：</p>
<ul>
<li><strong>特征保持的服装放码</strong>：如何自动地将A模特的衣服以合体的方式“穿”到体型不同的B模特身上，同时保持衣服原有的设计特征（如褶皱样式、轮廓）。</li>
<li><strong>设计保持的服装迁移</strong>：将一件为成人设计的复杂服装，自动迁移到儿童模型上，并保持其核心设计语言。</li>
</ul>
<h4 id="44-gpu%E5%8A%A0%E9%80%9F%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><strong>4.4 GPU加速与并行计算</strong></h4>
<p>布料模拟涉及大量质点和弹簧的计算，非常适合并行化。利用GPU的强大计算能力，可以极大地加速模拟过程。像 I-cloth 这样的技术专门研究了如何在GPU上高效地处理布料的碰撞检测。</p>
<h4 id="45-%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93"><strong>4.5 方法比较总结</strong></h4>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">动画形式</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>几何方法</strong></td>
<td style="text-align:left">几何曲线</td>
<td style="text-align:left">速度快</td>
<td style="text-align:left">真实感差，无法模拟动态</td>
</tr>
<tr>
<td style="text-align:left"><strong>物理方法(显式)</strong></td>
<td style="text-align:left">动力学</td>
<td style="text-align:left">真实感好，单步计算快</td>
<td style="text-align:left">稳定性差，总体效率不高</td>
</tr>
<tr>
<td style="text-align:left"><strong>物理方法(隐式)</strong></td>
<td style="text-align:left">动力学</td>
<td style="text-align:left">稳定性好</td>
<td style="text-align:left">需要求解线性方程，单步计算复杂</td>
</tr>
<tr>
<td style="text-align:left"><strong>近似隐式法</strong></td>
<td style="text-align:left">近似动力学</td>
<td style="text-align:left">速度快，稳定性好</td>
<td style="text-align:left">近似误差大，真实感较差</td>
</tr>
<tr>
<td style="text-align:left"><strong>PBD</strong></td>
<td style="text-align:left">几何约束</td>
<td style="text-align:left">速度极快，稳定可控</td>
<td style="text-align:left">物理不精确</td>
</tr>
<tr>
<td style="text-align:left"><strong>混合方法</strong></td>
<td style="text-align:left">动力学+几何</td>
<td style="text-align:left">速度快</td>
<td style="text-align:left">真实感较差，适用范围有限</td>
</tr>
</tbody>
</table>
<h3 id="%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93"><strong>第五部分：总结</strong></h3>
<p>我们从布料动画的重要性出发，深入探讨了它所面临的建模、渲染和仿真三大挑战，并回顾了从早期的几何方法到现代的PBD和机器学习方法的演进历程。</p>
<p><strong>核心要点总结</strong>：</p>
<ul>
<li><strong>布料动画</strong>是一个具有巨大应用前景的方向，是提升虚拟世界真实感的关键。</li>
<li>目前，<strong>基于物理的模拟方法（特别是PBD）与GPU加速</strong>是业界的主流技术。</li>
<li>这是一个<strong>多学科交叉</strong>的领域，在实际应用中，需要综合考虑物理、几何、材料科学和数值计算等多种因素。</li>
</ul>
<p><strong>未来的目标</strong>：</p>
<p>一个激动人心的目标是实现完美的<strong>虚拟试衣</strong>。想象一下，未来你可以在家中，通过摄像头捕捉你的三维模型，然后在一个虚拟商店里，实时、逼真地试穿任何一件衣服，看到它在你身上的悬垂、褶皱和动态效果，就像在实体店一样。</p>
<p><strong>学习资源</strong>：</p>
<p>对于有兴趣深入研究的同学，推荐一个优秀的开源项目：<strong><a href="https://github.com/mmmovania/opencloth">OpenCloth</a></strong></p>
<ul>
<li>它用OpenGL实现了一系列经典的布料模拟算法，包括我们今天提到的显式欧拉、隐式积分（Baraff &amp; Witkin模型）、PBD等，是学习和实践的绝佳资源。</li>
</ul>
</article><div class="share-buttons">
<p>分享到：</p>
<a class="share-btn weibo" href="#" onclick="sharePost(event, 'weibo')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Sina Weibo</title><path d="M10.098 20.323c-3.977.391-7.414-1.406-7.672-4.02-.259-2.609 2.759-5.047 6.74-5.441 3.979-.394 7.413 1.404 7.671 4.018.259 2.6-2.759 5.049-6.737 5.439l-.002.004zM9.05 17.219c-.384.616-1.208.884-1.829.602-.612-.279-.793-.991-.406-1.593.379-.595 1.176-.861 1.793-.601.622.263.82.972.442 1.592zm1.27-1.627c-.141.237-.449.353-.689.253-.236-.09-.313-.361-.177-.586.138-.227.436-.346.672-.24.239.09.315.36.18.601l.014-.028zm.176-2.719c-1.893-.493-4.033.45-4.857 2.118-.836 1.704-.026 3.591 1.886 4.21 1.983.64 4.318-.341 5.132-2.179.8-1.793-.201-3.642-2.161-4.149zm7.563-1.224c-.346-.105-.57-.18-.405-.615.375-.977.42-1.804 0-2.404-.781-1.112-2.915-1.053-5.364-.03 0 0-.766.331-.571-.271.376-1.217.315-2.224-.27-2.809-1.338-1.337-4.869.045-7.888 3.08C1.309 10.87 0 13.273 0 15.348c0 3.981 5.099 6.395 10.086 6.395 6.536 0 10.888-3.801 10.888-6.82 0-1.822-1.547-2.854-2.915-3.284v.01zm1.908-5.092c-.766-.856-1.908-1.187-2.96-.962-.436.09-.706.511-.616.932.09.42.511.691.932.602.511-.105 1.067.044 1.442.465.376.421.466.977.316 1.473-.136.406.089.856.51.992.405.119.857-.105.992-.512.33-1.021.12-2.178-.646-3.035l.03.045zm2.418-2.195c-1.576-1.757-3.905-2.419-6.054-1.968-.496.104-.812.587-.706 1.081.104.496.586.813 1.082.707 1.532-.331 3.185.15 4.296 1.383 1.112 1.246 1.429 2.943.947 4.416-.165.48.106 1.007.586 1.157.479.165.991-.104 1.157-.586.675-2.088.241-4.478-1.338-6.235l.03.045z"></path></svg>
<span>微博</span>
</a>
<a class="share-btn twitter" href="#" onclick="sharePost(event, 'twitter')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M21.543 7.104c.015.211.015.423.015.636 0 6.507-4.954 14.01-14.01 14.01v-.003A13.94 13.94 0 0 1 0 19.539a9.88 9.88 0 0 0 7.287-2.041 4.93 4.93 0 0 1-4.6-3.42 4.916 4.916 0 0 0 2.223-.084A4.926 4.926 0 0 1 .96 9.167v-.062a4.887 4.887 0 0 0 2.235.616A4.928 4.928 0 0 1 1.67 3.148 13.98 13.98 0 0 0 11.82 8.292a4.929 4.929 0 0 1 8.39-4.49 9.868 9.868 0 0 0 3.128-1.196 4.941 4.941 0 0 1-2.165 2.724A9.828 9.828 0 0 0 24 4.555a10.019 10.019 0 0 1-2.457 2.549z"></path></svg>
<span>Twitter</span>
</a>
<a class="share-btn linkedin" href="#" onclick="sharePost(event, 'linkedin')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg>
<span>LinkedIn</span>
</a>
<a class="share-btn wechat" href="#" onclick="sharePost(event, 'wechat')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>WeChat</title><path d="M8.691 2.188C3.891 2.188 0 5.476 0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59 0 0 1 .213.665l-.39 1.48c-.019.07-.048.141-.048.213 0 .163.13.295.29.295a.326.326 0 0 0 .167-.054l1.903-1.114a.864.864 0 0 1 .717-.098 10.16 10.16 0 0 0 2.837.403c.276 0 .543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178A1.17 1.17 0 0 1 4.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813 0c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178 1.17 1.17 0 0 1-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826 0 1.622-.12 2.361-.336a.722.722 0 0 1 .598.082l1.584.926a.272.272 0 0 0 .14.047c.134 0 .24-.111.24-.247 0-.06-.023-.12-.038-.177l-.327-1.233a.582.582 0 0 1-.023-.156.49.49 0 0 1 .201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.97-.982zm4.844 0c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.969-.982z"></path></svg>
<span>微信</span>
</a>
<a class="share-btn qq" href="#" onclick="sharePost(event, 'qq')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Tencent QQ</title><path d="M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673"></path></svg>
<span>QQ</span>
</a>
<a class="share-btn facebook" href="#" onclick="sharePost(event, 'facebook')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Facebook</title><path d="M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z"></path></svg>
<span>Facebook</span>
</a>
</div>
</main>
</div>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
<script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
<script src="../script.js"></script>
<!-- The Modal -->
<div class="modal" id="about-me-modal">
<!-- Modal content -->
<div class="modal-content">
<span class="close-button">×</span>
<h2>About Me</h2>
<p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
<p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
<p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
<p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
<p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
<p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
<hr/>
<h3>订阅我的博客</h3>
<p>订阅功能正在建设中，敬请期待！</p>
</div>
</div>
<script src="../modal.js"></script>
</body>
</html>