<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<title>计算机动画05:群组动画(上)</title>
<link href="../style.css" rel="stylesheet"/>
<link href="../modal.css" rel="stylesheet"/>
<script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" type="text/javascript">
</script>
<!-- Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
<script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
<!-- Highlight.js Themes -->
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/rose-pine-dawn.min.css" id="highlight-theme-link" rel="stylesheet"/>
<!-- Highlight.js Copy Plugin CSS -->
<link href="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.css" rel="stylesheet"/>
</head>
<body>
<audio id="bg-music" loop="" src="../music.mp3"></audio>
<button class="music-control" id="music-toggle">♪</button><button class="dark-mode-control" id="dark-mode-toggle">🌙</button>
<header>
<h1>forliage的blog</h1>
<nav>
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../posts.html">文章</a></li>
<li><a href="../about.html">关于</a></li>
<li><a href="../category.html?category=技术文章">技术文章</a></li>
<li><a href="../category.html?category=生活随笔">生活随笔</a></li>
<li><a href="../category.html?category=学习笔记">学习笔记</a></li>
<li><a href="../category.html?category=心情日记">心情日记</a></li>
<li><a href="#" id="about-me-btn">ABOUT ME</a></li>
</ul>
</nav>
</header>
<div class="container">
<div id="sidebar-container"></div>
<main>
<article>
<h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A8%E7%94%BB05%E7%BE%A4%E7%BB%84%E5%8A%A8%E7%94%BB%E4%B8%8A">计算机动画05:群组动画(上)</h1>
<h3 id="1-%E5%A4%A7%E8%87%AA%E7%84%B6%E7%9A%84%E4%BA%A4%E5%93%8D%E6%9B%B2%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E9%9B%86%E4%BD%93%E8%A1%8C%E4%B8%BA"><strong>1. 大自然的交响曲：无处不在的集体行为</strong></h3>
<ul>
<li><strong>海洋中的芭蕾</strong>：一群热带鱼在珊瑚礁中同步穿梭，它们形成整齐的队形，仿佛有一个无形的指挥官在引导。它们如何做到在高速游动中既不互相碰撞，又能协同一致地躲避天敌？</li>
<li><strong>天空中的墨舞</strong>：黄昏时分，成千上万只椋鸟在空中汇聚成一团变幻莫测的“黑云”。这种现象被称为“<strong>Murmuration</strong>”，是一种令人叹为观止的空中舞蹈。它们没有领导，没有预设的编排，每一个个体都只是在响应它身边的同伴，却共同创造出了一场宏大的、流动的视觉盛宴。</li>
<li><strong>生命的漩涡</strong>：在海洋中，当沙丁鱼群面临捕食者的威胁时，它们会迅速聚集，形成一个巨大的、旋转的“鱼球”。这是一种防御机制，通过集体的力量迷惑敌人，增加个体存活的几率。图中那名潜水员的存在，让我们得以一窥这个生命漩涡内部的壮观景象。</li>
<li><strong>草原上的秩序</strong>：广袤的牧场上，羊群悠闲地吃草或迁徙。它们总能保持一种微妙的平衡——既聚集在一起以获得安全感，又为彼此留出足够的空间。</li>
</ul>
<p>这些例子，都展示了一种强大的、自下而上形成的组织力量——<strong>集体行为 (Collective Behavior)</strong>。</p>
<p>这种力量不仅限于动物世界。在我们人类社会中，它同样无处不在：</p>
<ul>
<li><strong>历史的洪流</strong>：想象一下古代战场的冲锋陷阵，或是现代城市中繁忙的交通枢纽。在东京涩谷那著名的十字路口，每当绿灯亮起，来自四面八方的人潮交汇穿行，每个人都在独立地走向自己的目的地，却共同构成了一幅高效而有序的流动图景。</li>
<li><strong>城市的脉搏</strong>：高速公路立交桥上川流不息的车辆，大型集会上人群情绪的共振与传递。这些都是由无数个体的决策汇聚而成的宏观现象。</li>
</ul>
<p>所有这些，都向我们提出了一个深刻的挑战：<strong>我们如何用计算机来模拟这些由大量自主个体组成的复杂动态系统？</strong> 这正是群组动画所要解答的核心命题。</p>
<h3 id="2-%E9%93%B6%E5%B9%95%E4%B8%8A%E7%9A%84%E9%AD%94%E6%B3%95%E7%BE%A4%E7%BB%84%E5%8A%A8%E7%94%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><strong>2. 银幕上的魔法：群组动画的应用实例</strong></h3>
<p>让我们将目光从现实世界转向光影的艺术，看看群组动画技术是如何在电影和游戏中施展魔法的。</p>
<ul>
<li>
<p><strong>《狮子王》的里程碑</strong>
                大家一定都记得迪士尼经典动画《狮子王》中那个令人心悸的片段——牛羚大奔逃。年幼的辛巴被困在峡谷中，成千上万的牛羚从他身边雷鸣般地奔腾而过。在那个年代，要让每一头牛羚都看起来独一无二、动态自然，是一项巨大的技术挑战。这正是群组动画技术的早期应用，通过算法赋予每个个体基本的行为逻辑，从而生成了这场动画史上的经典场面。</p>
</li>
<li>
<p><strong>游戏世界的虚拟军团</strong>
                在现代电子游戏中，无论是《全面战争》系列里的万人同屏厮杀，还是《魔兽世界》里的团队副本，大规模的NPC（非玩家角色）互动已经成为常态。要让这些虚拟士兵看起来训练有素，懂得列队、冲锋、包抄和躲避，而不是一群混乱的乌合之众，就需要高效的群组AI和动画系统在背后支撑。这一切都必须在玩家的设备上实时演算，对算法的效率提出了极高的要求。</p>
</li>
</ul>
<h3 id="3-%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA%E8%A7%A3%E6%9E%84%E9%9B%86%E4%BD%93%E8%A1%8C%E4%B8%BA"><strong>3. 核心理论：解构集体行为</strong></h3>
<p>我们已经欣赏了许多集体行为的现象，现在，让我们深入其科学内核，给它一个更精确的定义。</p>
<p><strong>什么是集体行为 (Collective Behavior)？</strong></p>
<p>"成群的动物——如鱼群、鸟群和昆虫群——通常会展现出由<strong>个体间社会互动 (social interactions among individuals)</strong> 产生的<strong>复杂而协调的行为 (complex and coordinated behaviours)</strong>。"</p>
<p>这个定义中有两个关键词：<strong>互动</strong>与<strong>涌现</strong>。</p>
<ul>
<li><strong>互动</strong>：行为的根源不是来自一个中央大脑的命令，而是来自个体与它局部邻居之间的简单互动。</li>
<li><strong>涌现 (Emergence)</strong>：这是整个领域最迷人、也最重要的概念。所谓“涌现”，指的是<strong>由许多微观、简单的单元通过互动，在宏观层面自发地、不可预知地产生出全新的、复杂的属性和规律的现象。</strong>
<ul>
<li><strong>一个神经元没有智慧，但亿万个神经元连接起来，就涌现出了“意识”。</strong></li>
<li><strong>一个水分子没有“流动性”，但无数个水分子聚集起来，就涌现出了“波浪”和“漩涡”。</strong></li>
<li>同样，在群组动画中，<strong>一个Boid（我们稍后会讲到的虚拟生物）只遵循三条简单规则，但成千上万个Boids聚集起来，就能涌现出逼真的鸟群飞行行为。</strong></li>
</ul>
</li>
</ul>
<p>这是一种“整体大于部分之和”的哲学思想在科学和工程领域的体现。我们的目标，就是去设计那些简单的<strong>局部规则</strong>，以便在全局层面“涌现”出我们想要的宏大效果。</p>
<p>这个领域的研究是高度交叉的，它吸引了生物学、物理学、计算机科学等领域的顶尖学者。其中，<strong>德国马克斯·普朗克集体行为研究所的Iain Couzin教授</strong>是该领域的泰山北斗。他的团队通过精密的实验和数学建模，揭示了鱼群、蝗虫群等生物群体的决策机制。他们的研究成果常常登上《自然》和《科学》等顶级期刊的封面，极大地启发了计算机图形学中的群组模拟算法。我强烈推荐同学们去访问他的实验室网站，那里有大量精彩的论文和演示视频。</p>
<h3 id="4-%E7%BE%A4%E7%BB%84%E5%8A%A8%E7%94%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><strong>4. 群组动画的基本框架</strong>
<p>现在，让我们回到计算机图形学的语境下，为“群组”建立一个清晰的工程框架。</p>
<p><strong>群组的定义</strong></p>
<p>在同一物理环境下，拥有一致或相似目标的一群个体，其行为模式会因群体的存在而显著区别于其独处时的行为。</p>
<p><strong>行为的层次结构</strong></p>
<p>为了管理复杂性，我们将群组行为分解为三个层次：</p>
<ul>
<li><strong>群 (Crowd) 层次</strong>：关注最高层的宏观表现，如人群的整体流向、密度变化、形成的队形。</li>
<li><strong>组 (Group) 层次</strong>：关注由若干个体组成的小团体行为，比如一家人手拉手在公园散步，或是一队士兵在战场上协同作战。</li>
<li><strong>个体 (Individual) 层次</strong>：关注最基础单元的行为，即单个角色的动画、物理和基本决策，如行走、跑步、避开障碍物。</li>
</ul>
<p><strong>核心区别：粒子系统 vs. 智能体系统</strong></p>
<p>请大家务必记住这个关键区别：</p>
<ul>
<li><strong>粒子系统 (Particle System)</strong>：其中的每个“粒子”是<strong>没有智能</strong>的。它们就像尘埃，只被动地遵循全局的物理力（如重力、风力）。适合模拟火花、雨雪、瀑布等。</li>
<li><strong>群组系统 (Agent-based System)</strong>：其中的每个“个体”是一个<strong>智能体 (Agent)</strong>。它拥有自己的“感知-思考-行动”循环。它能“看到”周围的环境和邻居，并据此<strong>自主决策</strong>。这才是模拟生命群体的正确方法。</li>
</ul>
<p><strong>我们今天要讨论的所有技术，都属于智能体系统的范畴。</strong></p>
<h3 id="5-%E9%9C%80%E6%B1%82%E7%9A%84%E9%A9%B1%E5%8A%A8%E4%B8%BA%E4%BD%95%E8%A6%81%E6%94%BB%E5%85%8B%E7%BE%A4%E7%BB%84%E5%8A%A8%E7%94%BB"><strong>5. 需求的驱动：为何要攻克群组动画？</strong>
<p>投入如此巨大的精力去研究这项技术，其背后有着强大的工业需求：</p>
<ol>
<li><strong>创造视觉奇观</strong>：在电影和游戏中，宏大的群体场面是营造史诗感和沉浸感的关键。没有群组动画，我们就不可能看到《指环王》里的半兽人大军，也不可能体验到《僵尸世界大战》里令人窒息的尸潮。</li>
<li><strong>解放生产力</strong>：让动画师手动去调整成千上万个角色的动作是一项无法完成的任务。群组动画通过<strong>程序化生成 (Procedural Generation)</strong> 的方式，将动画师的角色从“操作工”提升为“导演”。他们只需设定好宏观规则和行为逻辑，剩下的细节就交给计算机自动完成。</li>
<li><strong>降低制作成本与风险</strong>：如果要在现实中拍摄上万人的战争场面，所需要的人力、物力和财力是天文数字，而且危险性极高。通过CG技术，我们能以更低的成本、更高的效率和绝对的安全性，实现比实拍更壮观、更具想象力的效果。</li>
</ol>
<p>从《阿凡达》到《猩球崛起》，从《长城》到《流浪地球》，几乎所有视觉大片的背后，都有群组动画技术在默默贡献力量。</p>
<h3 id="6-%E6%8A%80%E6%9C%AF%E7%9A%84%E6%8C%91%E6%88%98%E7%BE%A4%E7%BB%84%E5%8A%A8%E7%94%BB%E7%9A%84%E7%A1%AC%E9%AA%A8%E5%A4%B4"><strong>6. 技术的挑战：群组动画的“硬骨头”</strong>
<p>实现逼真的群组动画，我们需要啃下几块“硬骨头”：</p>
<ul>
<li><strong>海量数据与计算</strong>：成千上万个智能体，每个都包含模型、骨骼、动画和AI数据，这对内存和计算资源是巨大的考验。</li>
<li><strong>秩序与混乱的统一</strong>：群体运动既要有整体的规律性（如大方向一致），又要有局部的随机性（每个个体细微的差异），如何完美平衡这两者，是艺术和技术的双重挑战。</li>
</ul>
<p>这些宏观特点，具体到技术实现上，就分解为以下几个核心问题：</p>
<ul>
<li><strong>运动控制 (Motion Control)</strong>：如何设计算法，让每个智能体都能自主导航、避免碰撞、并表现出符合角色设定的行为？<strong>这是我们本次讲座的重中之重。</strong></li>
<li><strong>高效渲染 (Rendering)</strong>：如何在一帧的时间内（通常是1/60秒）渲染出成千上万个高质量的角色？</li>
<li><strong>艺术创作 (Authoring)</strong>：如何为艺术家提供直观、高效的工具，让他们能够轻松地“导演”一场群体大戏？</li>
<li><strong>细节层次 (Level of Detail, LOD)</strong>：远处的角色不需要那么精细。如何根据距离动态切换不同复杂度的模型和动画，以节省计算资源？</li>
<li><strong>碰撞处理 (Collision Detection &amp; Response)</strong>：如何快速、稳定地处理个体之间、个体与环境之间的碰撞？</li>
</ul>
<h3 id="7-%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%89%E4%BD%8D%E4%B8%80%E4%BD%93%E6%A8%A1%E5%9E%8B"><strong>7. 运动控制的“三位一体”模型</strong></h3>
<p>为了解决最核心的运动控制问题，<strong>Craig Reynolds</strong> 提出了一套经典的分层架构，它将一个智能体的复杂运动行为分解为三个清晰的层次。我们可以称之为运动控制的“三位一体”模型。</p>
<div class="mermaid">
                graph TD
                    A["<b>Action Selection (行为选择)</b><br/><i>战略层：决定做什么？</i><br/>例如：追逐敌人、逃往出口"] --&gt; B;
                    B["<b>Steering (导航)</b><br/><i>战术层：如何到达那里？</i><br/>计算一个期望的力或加速度"] --&gt; C;
                    C["<b>Locomotion (运动)</b><br/><i>执行层：如何移动身体？</i><br/>播放动画、更新物理状态"] --&gt; D[最终的屏幕动画];

                    style A fill:#ffc,stroke:#333,stroke-width:2px
                    style B fill:#cdf,stroke:#333,stroke-width:2px
                    style C fill:#cfc,stroke:#333,stroke-width:2px
                </div>
<ol>
<li>
<p><strong>行为选择 (Action Selection) - 战略层</strong></p>
<ul>
<li>这是智能体的“<strong>大脑</strong>”。它基于高级AI逻辑（如状态机、行为树）来做出决策。它回答的问题是：“<strong>我应该做什么？</strong>” 例如，一个士兵在战场上，它的状态可能是“巡逻”、“发现敌人”、“攻击”、“寻找掩体”或“撤退”。这一层决定了当前的目标和意图。</li>
</ul>
</li>
<li>
<p><strong>导航 (Steering) - 战术层</strong></p>
<ul>
<li>这是智能体的“<strong>驾驶员</strong>”。一旦大脑确定了目标（比如“攻击那个敌人”），导航层就负责计算出为了实现这个目标，在当前这一帧应该施加一个怎样的<strong>力 (Steering Force)</strong> 或加速度。它处理的是抽象的运动行为，如“追逐(Seek)”、“躲避(Flee)”、“跟随路径(Path Following)”等。它回答的问题是：“<strong>我该如何前往那里？</strong>” <strong>我们接下来要详细讲解的Boids模型和各种导航行为，都属于这一层。</strong></li>
</ul>
</li>
<li>
<p><strong>运动 (Locomotion) - 执行层</strong></p>
<ul>
<li>这是智能体的“<strong>身体</strong>”。它接收来自导航层的指令（那个力），并将其应用到角色的物理模型上，更新其在世界中的位置和朝向。同时，它会根据当前的速度和状态，选择并播放最合适的动画片段（如行走、跑步、攻击动画）。它回答的问题是：“<strong>我该如何具体地移动我的四肢？</strong>”</li>
</ul>
</li>
</ol>
<p>这种分层的好处是<strong>解耦</strong>。我们可以独立地设计和替换每一层的算法。例如，我们可以用同一套导航算法，来驱动人形角色、汽车或者飞船，只需要为它们更换不同的运动层实现即可。</p>
<p><strong>两种核心控制思想</strong></p>
<p>在实现群体运动时，主要有两种哲学：</p>
<ul>
<li><strong>自下而上 (Bottom-up)</strong>：通过为每个个体设定简单的局部规则，让宏观的群体行为<strong>自然涌现</strong>。这就像一个自由发展的社会，充满了生机和不可预测性。<strong>Boids模型是其典型代表。</strong></li>
<li><strong>自上而下 (Top-down)</strong>：由设计者直接定义一个全局的“场”（如速度场或密度场），来<strong>强制引导</strong>个体的运动。这就像一个规划好的城市交通系统，高效且可控。<strong>流场跟随 (Flow Field Following) 是其典型代表。</strong></li>
</ul>
<p>在现代的工业应用中，往往是<strong>两者结合</strong>，用“自上而下”的方法进行宏观引导，用“自下而上”的规则处理局部细节，以兼顾可控性与真实感。</p>
<h3 id="8-%E5%B7%A5%E4%B8%9A%E7%95%8C%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8"><strong>8. 工业界的“神兵利器”</strong></h3>
<p>在深入算法的海洋之前，让我们先参观一下工业界的“军火库”，看看艺术家和工程师们都在使用哪些强大的商业软件。</p>
<ul>
<li>
<p><strong>Golaem Crowd</strong>、<strong>Atoms Crowd</strong>、<strong>Anima</strong>：这些是当今影视和建筑可视化领域的主流选择，它们通常作为插件深度集成在Maya、Houdini等软件中，提供了友好的艺术家工作流和强大的功能集。</p>
</li>
<li>
<p><strong>Massive：群组模拟的传奇</strong>
                这款软件在群组动画领域的地位，如同Photoshop在图像处理领域的地位一样，是开创性的。它正是为了制作**《指环王》三部曲**中史诗般的战争场面而诞生的。</p>
<ul>
<li><strong>它的缔造者</strong>，是来自新西兰的天才工程师<strong>Stephen Regelous</strong>。他花了两年时间，为导演Peter Jackson打造了这把“神兵”，并因此获得了奥斯卡科学与工程奖。</li>
<li><strong>Massive的核心理念</strong>，就是为每个数字角色赋予一个基于<strong>模糊逻辑</strong>的“大脑”。这个大脑能够处理复杂的感知信息（“我看到了什么？”、“我听到了什么？”），并做出近似人类的、非二元的决策。它为艺术家提供了一套可视化的AI创建工具，使得没有编程背景的人也能“设计灵魂”。</li>
<li>可以说，Massive不仅是一款软件，它更是一套关于如何创造大规模、可信的数字生命的完整哲学。</li>
</ul>
</li>
</ul>
<p>从《金刚》中的恐龙奔逃，到《阿凡达》里潘多拉星球的生态，再到《僵尸世界大战》中堆积如山的尸潮，这些令人印象深刻的画面背后，都有Massive或类似技术的强大支持。</p>
<h3 id="9-%E4%B8%87%E7%89%A9%E4%B9%8B%E6%BA%90boids%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><strong>9. 万物之源：Boids模型深度解析</strong></h3>
<p>好了，铺垫了这么多，现在让我们正式进入本次讲座的硬核部分。我们将一起从零开始，推导和理解群组动画历史上最重要、最基础的模型——<strong>Boids模型</strong>。</p>
<p>这个模型由我们反复提到的Craig W. Reynolds于1987年在SIGGRAPH上发表。论文标题是《Flocks, Herds, and Schools: A Distributed Behavioral Model》。截至今天，这篇论文的谷歌学术引用量已经超过了15000次，是计算机图形学领域引用次数最高的论文之一，其影响力可见一斑。</p>
<p><strong>Boids的核心思想</strong></p>
<p>Reynolds的洞见是革命性的：<strong>我们不必去模拟整个鸟群，我们只需要模拟一只鸟，然后让成千上万只这样的“鸟”在一起互动，真实的鸟群行为就会奇迹般地涌现出来。</strong></p>
<p>这里的“鸟”，他称之为 <strong>Boid</strong> (bird-oid object的缩写，意为“类鸟物体”)。</p>
<p><strong>如何模拟一只Boid？</strong></p>
<p>Reynolds提出，每个Boid的行为都由三条简单到不可思议的、基于其局部邻居的规则来驱动。这三条规则是优先级递减的：</p>
<ol>
<li><strong>碰撞避免 (Collision Avoidance) / 分离 (Separation)</strong>：避免与附近的同伴撞在一起。</li>
<li><strong>速度匹配 (Velocity Matching) / 对齐 (Alignment)</strong>：尝试与附近同伴的平均速度和方向保持一致。</li>
<li><strong>群体聚集 (Flock Centering) / 内聚 (Cohesion)</strong>：尝试朝附近同伴的平均位置移动，以保持群体的聚集性。</li>
</ol>
<p>就是这三条简单的规则，构成了所有复杂群体行为的<strong>数字DNA</strong>。现在，让我们用数学和代码的语言，将它们精确地表达出来。</p>
<p>首先，定义我们的基础数据结构。</p>
<p><strong>Boid的数据结构 (C++)</strong></p>
<div class="code-container">
<pre><code class="language-cpp">#include &lt;vector&gt;

struct Vector3 {
    float x, y, z;
    // ... 向量的各种运算，如加、减、数乘、点积、叉积、归一化、求长度等
};

class Boid {
public:
    Vector3 position;      // 位置
    Vector3 velocity;      // 速度 (方向和大小)
    Vector3 acceleration;  // 加速度
    
    float max_speed;       // 最大速度限制
    float max_force;       // 最大转向力限制
    float perception_radius; // 感知半径
    
    void update() {
        // 更新物理状态：速度 += 加速度, 位置 += 速度
        velocity += acceleration;
        // 限制速度
        velocity.limit(max_speed); 
        position += velocity;
        // 每帧重置加速度
        acceleration *= 0; 
    }
    
    void applyForce(const Vector3&amp; force) {
        acceleration += force;
    }
    
    // ... 其他方法
};
</code></pre>
</div>
<p>我们的主循环将是：对于场景中的每一个Boid，计算它基于三条规则所受到的合力，然后更新它的物理状态。</p>
<h4 id="%E8%A7%84%E5%88%99%E4%B8%80%E5%88%86%E7%A6%BB-separation"><strong>规则一：分离 (Separation)</strong></h4>
<p><strong>目标</strong>：避免与邻居挤作一团。</p>
<p><strong>直觉</strong>：检查所有在感知范围内的邻居。如果某个邻居离我太近，我就产生一个远离它的力。离得越近，这个排斥力就越强。</p>
<p><strong>数学推导</strong>：
                假设当前Boid为 $b_i$，其位置为 $\vec{P}_i$。对于感知范围内的任意一个邻居 $b_j$ (位置为 $\vec{P}_j$)，它们之间的距离向量是 $\vec{D} = \vec{P}_i - \vec{P}_j$。
                我们想要一个排斥力，方向与 $\vec{D}$ 相同，大小与距离成反比。一个常见的做法是让力的大小与距离的平方成反比，即 $1/|\vec{D}|^2$。
                所以，来自邻居 $b_j$ 的排斥力可以表示为 $\frac{\hat{D}}{|\vec{D}|}$ 或者更简单的 $\frac{\vec{D}}{|\vec{D}|^2}$。
                将所有邻居产生的排斥力相加，就得到了总的分离力。</p>
<p><strong>伪代码</strong>：</p>
<div class="code-container">
<pre><code>function separation(boids):
  steering_force = Vector3(0, 0, 0)
  total = 0
  
  for each other_boid in boids:
    distance = distance(self.position, other_boid.position)
    
    // 检查邻居是否在感知范围内且距离大于0
    if distance &gt; 0 and distance &lt; self.perception_radius:
      // 计算一个与距离成反比的排斥力
      diff = self.position - other_boid.position
      diff.normalize()
      diff = diff / distance // 距离越近，力越大
      steering_force += diff
      total += 1
      
  if total &gt; 0:
    steering_force /= total // 求平均力
    
  // 如果平均力不为零，将其调整到期望的大小
  if steering_force.length() &gt; 0:
    steering_force.normalize()
    steering_force *= self.max_speed
    steering_force -= self.velocity // 转向力 = 期望速度 - 当前速度
    steering_force.limit(self.max_force)
    
  return steering_force
</code></pre>
</div>
<p><strong>可视化</strong>：</p>
<div class="mermaid">
                graph TD
                    subgraph Separation
                        Boid_i((Boid i));
                        Neighbor_1((Neighbor 1));
                        Neighbor_2((Neighbor 2));
                        Boid_i -- "Repulsion Force 1" --&gt; F1( );
                        Boid_i -- "Repulsion Force 2" --&gt; F2( );
                        F1 --&gt; Resultant{Resultant Force};
                        F2 --&gt; Resultant;
                        style F1 fill:#fff,stroke:#fff
                        style F2 fill:#fff,stroke:#fff
                        linkStyle 0 stroke:red,stroke-width:2px,stroke-dasharray: 5 5;
                        linkStyle 1 stroke:red,stroke-width:2px,stroke-dasharray: 5 5;
                        linkStyle 2 stroke:blue,stroke-width:3px;
                        linkStyle 3 stroke:blue,stroke-width:3px;
                    end
                </div>
<h4 id="%E8%A7%84%E5%88%99%E4%BA%8C%E5%AF%B9%E9%BD%90-alignment"><strong>规则二：对齐 (Alignment)</strong></h4>
<p><strong>目标</strong>：与邻居飞向同一个方向。</p>
<p><strong>直觉</strong>：观察我感知范围内的所有邻居，计算出它们的平均飞行速度（方向和速率），然后调整我自己的速度，使其趋向于这个平均速度。</p>
<p><strong>数学推导</strong>：
                假设在Boid $b_i$ 的感知范围内有 $N$ 个邻居，它们的速度分别是 $\vec{V}<em>1, \vec{V}<em>2, ..., \vec{V}<em>N$。
                它们的平均速度是 $\vec{V}</em>{avg} = \frac{1}{N} \sum</em>{j=1}^{N} \vec{V}<em>j$。
                对齐行为的目标就是让Boid $b_i$ 产生一个转向力，使其自身的速度 $\vec{V}<em>i$ 逐渐靠近 $\vec{V}</em>{avg}$。这个期望的转向力 (Steering Force) 就是 $\vec{F}</em>{align} = \vec{V}</em>{avg} - \vec{V}_i$。</p>
<p><strong>伪代码</strong>：</p>
<div class="code-container">
<pre><code>function alignment(boids):
  steering_velocity = Vector3(0, 0, 0)
  total = 0
  
  for each other_boid in boids:
    distance = distance(self.position, other_boid.position)
    
    if distance &gt; 0 and distance &lt; self.perception_radius:
      steering_velocity += other_boid.velocity
      total += 1
      
  if total &gt; 0:
    steering_velocity /= total // 求平均速度
    steering_velocity.normalize()
    steering_velocity *= self.max_speed // 期望以最大速度朝该方向前进
    
    steering_force = steering_velocity - self.velocity
    steering_force.limit(self.max_force)
    return steering_force
    
  return Vector3(0, 0, 0)
</code></pre>
</div>
<p><strong>可视化</strong>：</p>
<div class="mermaid">
                graph TD
                    subgraph Alignment
                        Boid_i((Boid i));
                        Neighbor_1["Neighbor 1 --&gt;"];
                        Neighbor_2["Neighbor 2 --&gt;"];
                        Neighbor_3["Neighbor 3 --&gt;"];
                        
                        Neighbor_1 --&gt; Avg_Vel{Avg Velocity};
                        Neighbor_2 --&gt; Avg_Vel;
                        Neighbor_3 --&gt; Avg_Vel;
                        
                        Boid_i -- "Steering towards Avg" --&gt; Avg_Vel;
                        
                        linkStyle 0 stroke:green;
                        linkStyle 1 stroke:green;
                        linkStyle 2 stroke:green;
                        linkStyle 3 stroke:blue,stroke-width:3px,stroke-dasharray: 5 5;
                    end
                </div>
<h4 id="%E8%A7%84%E5%88%99%E4%B8%89%E5%86%85%E8%81%9A-cohesion"><strong>规则三：内聚 (Cohesion)</strong></h4>
<p><strong>目标</strong>：保持群体的紧凑，向群体中心靠拢。</p>
<p><strong>直觉</strong>：找到我感知范围内的所有邻居，计算出它们的几何中心点，然后产生一个朝向该中心点的力。</p>
<p><strong>数学推导</strong>：
                假设在Boid $b_i$ 的感知范围内有 $N$ 个邻居，它们的位置分别是 $\vec{P}<em>1, \vec{P}<em>2, ..., \vec{P}<em>N$。
                它们的几何中心（质心）是 $\vec{P}</em>{center} = \frac{1}{N} \sum</em>{j=1}^{N} \vec{P}<em>j$。
                Boid $b_i$ 想要朝这个中心点移动，所以目标位置是 $\vec{P}</em>{center}$。从当前位置 $\vec{P}<em>i$ 指向目标位置的期望速度向量是 $\vec{V}</em>{desired} = \vec{P}</em>{center} - \vec{P}<em>i$。
                相应的转向力就是 $\vec{F}</em>{cohesion} = \vec{V}_{desired} - \vec{V}_i$。</p>
<p><strong>伪代码</strong>：</p>
<div class="code-container">
<pre><code>function cohesion(boids):
  center_of_mass = Vector3(0, 0, 0)
  total = 0
  
  for each other_boid in boids:
    distance = distance(self.position, other_boid.position)
    
    if distance &gt; 0 and distance &lt; self.perception_radius:
      center_of_mass += other_boid.position
      total += 1
      
  if total &gt; 0:
    center_of_mass /= total // 计算几何中心
    
    // 计算朝向中心的期望速度
    desired_velocity = center_of_mass - self.position
    desired_velocity.normalize()
    desired_velocity *= self.max_speed
    
    // 计算转向力
    steering_force = desired_velocity - self.velocity
    steering_force.limit(self.max_force)
    return steering_force
    
  return Vector3(0, 0, 0)
</code></pre>
</div>
<h4 id="%E7%BB%84%E5%90%88%E8%A7%84%E5%88%99-arbitration"><strong>组合规则 (Arbitration)</strong></h4>
<p>现在我们有了三个独立的力，如何将它们组合起来应用到Boid上？</p>
<p>最简单的方法是<strong>加权求和</strong>：
                $$\vec{F}<em>{total} = w</em>{sep}\vec{F}<em>{sep} + w</em>{align}\vec{F}<em>{align} + w</em>{coh}\vec{F}_{coh}$$
                其中 $w$ 是权重系数，可以由艺术家调整以获得不同的群体效果（比如，增加内聚权重会让群体更紧密，增加分离权重会让群体更松散）。</p>
<p><strong>主循环伪代码</strong>：</p>
<div class="code-container">
<pre><code class="language-cpp">// 在主程序中
std::vector&lt;Boid&gt; flock;
// ... 初始化flock ...

// 每一帧的更新循环
void update_simulation() {
  for (Boid&amp; b : flock) {
    // 计算三个规则的力
    Vector3 separation_force = b.separation(flock);
    Vector3 alignment_force = b.alignment(flock);
    Vector3 cohesion_force = b.cohesion(flock);
    
    // 施加权重
    separation_force *= 1.5; // 分离的优先级通常最高
    alignment_force *= 1.0;
    cohesion_force *= 1.0;
    
    // 应用合力
    b.applyForce(separation_force);
    b.applyForce(alignment_force);
    b.applyForce(cohesion_force);
    
    // 更新boid的物理状态
    b.update();
  }
}
</code></pre>
</div>
<p>一个更健壮的方法是<strong>优先级仲裁</strong>。因为“避免碰撞”通常比“保持队形”更紧急。我们可以设置一个力的上限 <code>max_force</code>。优先分配给分离力，如果还有余量，再分配给对齐力，以此类推。</p>
<h3 id="%E6%8B%93%E5%B1%95%E4%B8%8E%E8%A1%A5%E5%85%85"><strong>拓展与补充</strong></h3>
<p>Boids模型虽然简单，但它为整个领域奠定了基础。后来的无数研究都是在它的基础上进行扩展和改进的：</p>
<ul>
<li><strong>障碍物躲避 (Obstacle Avoidance)</strong>：除了躲避同伴，Boids还需要能躲避环境中的柱子、墙壁等。这通常通过在其前方投射一个“感知触须”来实现，如果触须碰到障碍物，就产生一个法向的排斥力。</li>
<li><strong>领导者跟随 (Leader Following)</strong>：可以指定一个或几个Boid为领导者，其他Boid的行为规则里增加一条“跟随领导者”的力。</li>
<li><strong>路径跟随 (Path Following)</strong>：让整个群体沿着一条预设的路径前进。</li>
<li><strong>流场 (Flow Field)</strong>：如前所述的自上而下的控制方法，可以与Boids的局部规则结合，实现宏观可控、微观生动的效果。</li>
<li><strong>更复杂的行为</strong>：如捕食者(Predator)与猎物(Prey)的行为。捕食者会有一个“追逐”力，而猎物会有一个强大的“逃离”力，并且猎物看到捕食者时，它的分离、对齐、内聚规则的权重会发生动态变化。</li>
</ul>
</h3></h3></h3></article><div class="share-buttons">
<p>分享到：</p>
<a class="share-btn weibo" href="#" onclick="sharePost(event, 'weibo')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Sina Weibo</title><path d="M10.098 20.323c-3.977.391-7.414-1.406-7.672-4.02-.259-2.609 2.759-5.047 6.74-5.441 3.979-.394 7.413 1.404 7.671 4.018.259 2.6-2.759 5.049-6.737 5.439l-.002.004zM9.05 17.219c-.384.616-1.208.884-1.829.602-.612-.279-.793-.991-.406-1.593.379-.595 1.176-.861 1.793-.601.622.263.82.972.442 1.592zm1.27-1.627c-.141.237-.449.353-.689.253-.236-.09-.313-.361-.177-.586.138-.227.436-.346.672-.24.239.09.315.36.18.601l.014-.028zm.176-2.719c-1.893-.493-4.033.45-4.857 2.118-.836 1.704-.026 3.591 1.886 4.21 1.983.64 4.318-.341 5.132-2.179.8-1.793-.201-3.642-2.161-4.149zm7.563-1.224c-.346-.105-.57-.18-.405-.615.375-.977.42-1.804 0-2.404-.781-1.112-2.915-1.053-5.364-.03 0 0-.766.331-.571-.271.376-1.217.315-2.224-.27-2.809-1.338-1.337-4.869.045-7.888 3.08C1.309 10.87 0 13.273 0 15.348c0 3.981 5.099 6.395 10.086 6.395 6.536 0 10.888-3.801 10.888-6.82 0-1.822-1.547-2.854-2.915-3.284v.01zm1.908-5.092c-.766-.856-1.908-1.187-2.96-.962-.436.09-.706.511-.616.932.09.42.511.691.932.602.511-.105 1.067.044 1.442.465.376.421.466.977.316 1.473-.136.406.089.856.51.992.405.119.857-.105.992-.512.33-1.021.12-2.178-.646-3.035l.03.045zm2.418-2.195c-1.576-1.757-3.905-2.419-6.054-1.968-.496.104-.812.587-.706 1.081.104.496.586.813 1.082.707 1.532-.331 3.185.15 4.296 1.383 1.112 1.246 1.429 2.943.947 4.416-.165.48.106 1.007.586 1.157.479.165.991-.104 1.157-.586.675-2.088.241-4.478-1.338-6.235l.03.045z"></path></svg>
<span>微博</span>
</a>
<a class="share-btn twitter" href="#" onclick="sharePost(event, 'twitter')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M21.543 7.104c.015.211.015.423.015.636 0 6.507-4.954 14.01-14.01 14.01v-.003A13.94 13.94 0 0 1 0 19.539a9.88 9.88 0 0 0 7.287-2.041 4.93 4.93 0 0 1-4.6-3.42 4.916 4.916 0 0 0 2.223-.084A4.926 4.926 0 0 1 .96 9.167v-.062a4.887 4.887 0 0 0 2.235.616A4.928 4.928 0 0 1 1.67 3.148 13.98 13.98 0 0 0 11.82 8.292a4.929 4.929 0 0 1 8.39-4.49 9.868 9.868 0 0 0 3.128-1.196 4.941 4.941 0 0 1-2.165 2.724A9.828 9.828 0 0 0 24 4.555a10.019 10.019 0 0 1-2.457 2.549z"></path></svg>
<span>Twitter</span>
</a>
<a class="share-btn linkedin" href="#" onclick="sharePost(event, 'linkedin')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg>
<span>LinkedIn</span>
</a>
<a class="share-btn wechat" href="#" onclick="sharePost(event, 'wechat')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>WeChat</title><path d="M8.691 2.188C3.891 2.188 0 5.476 0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59 0 0 1 .213.665l-.39 1.48c-.019.07-.048.141-.048.213 0 .163.13.295.29.295a.326.326 0 0 0 .167-.054l1.903-1.114a.864.864 0 0 1 .717-.098 10.16 10.16 0 0 0 2.837.403c.276 0 .543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178A1.17 1.17 0 0 1 4.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813 0c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178 1.17 1.17 0 0 1-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826 0 1.622-.12 2.361-.336a.722.722 0 0 1 .598.082l1.584.926a.272.272 0 0 0 .14.047c.134 0 .24-.111.24-.247 0-.06-.023-.12-.038-.177l-.327-1.233a.582.582 0 0 1-.023-.156.49.49 0 0 1 .201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.97-.982zm4.844 0c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.969-.982z"></path></svg>
<span>微信</span>
</a>
<a class="share-btn qq" href="#" onclick="sharePost(event, 'qq')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Tencent QQ</title><path d="M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673"></path></svg>
<span>QQ</span>
</a>
<a class="share-btn facebook" href="#" onclick="sharePost(event, 'facebook')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Facebook</title><path d="M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z"></path></svg>
<span>Facebook</span>
</a>
</div>
<div class="giscus-container" style="margin-top: 50px;">
  <script src="https://giscus.app/client.js"
  data-repo="forliage/forliage.github.io"
  data-repo-id="R_kgDONjzd4w"
  data-category="Announcements"
  data-category-id="DIC_kwDONjzd484Cus1G"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"
  data-theme="https://forliage.github.io/giscus.css"
  data-lang="zh-CN"
  crossorigin="anonymous"
  async>
</script>
</div>


</main>
</div>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
<script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
<div class="dock">
  <a href="https://forliage.github.io/index.html">🏠</a>
  <a href="https://forliage.github.io/posts.html">📚</a>
  <a href="https://forliage.github.io/about.html">👤</a>
</div>
<script src="../script.js"></script>
<!-- The Modal -->
<div class="modal" id="about-me-modal">
<!-- Modal content -->
<div class="modal-content">
<span class="close-button">×</span>
<h2>About Me</h2>
<p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
<p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
<p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
<p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
<p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
<p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
<hr/>
<h3>订阅我的博客</h3>
<p>订阅功能正在建设中，敬请期待！</p>
</div>
</div>
<script src="../modal.js"></script><script src="../trail.js"></script>
<!-- Highlight.js Core -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- Highlight.js Copy Plugin -->
<script src="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.js"></script>
<!-- Initialize Highlight.js and Copy Plugin -->
<script>
  hljs.highlightAll();
  hljs.addPlugin(new CopyButtonPlugin());
</script>
</body>
</html>