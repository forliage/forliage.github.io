<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>计算机组成4-1:处理器-数据通路与控制</title>
    
    <link rel="stylesheet" href="../style.css">
    
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%904-1%E5%A4%84%E7%90%86%E5%99%A8-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E4%B8%8E%E6%8E%A7%E5%88%B6">计算机组成4-1:处理器-数据通路与控制</h1>
                <p>在前面的章节中，我们学习了计算机的“语言”——指令集体系结构（ISA），以及计算机如何表示和运算数字。现在，我们将进入最激动人心的部分：将这些零散的知识组合起来，构建一个真正能够执行指令的计算机核心——<strong>处理器 (Processor)</strong>。</p>
                <p>本章的目标是理解一个简化的RISC-V处理器是如何工作的。我们将从最基本的组件开始，像搭积木一样，一步步构建出处理器的<strong>数据通路 (Datapath)</strong>，然后设计指挥这些通路工作的<strong>控制器 (Control)</strong>。</p>
                <h3 id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><strong>第一部分：处理器设计基础</strong></h3>
                <h4 id="11-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E6%A6%82%E8%BF%B0"><strong>1.1 指令执行周期概述</strong></h4>
                <p>无论多么复杂的程序，其在CPU中的执行都可以分解为一系列基本步骤的循环。这个循环通常被称为<strong>指令周期 (Instruction Cycle)</strong>。对于一个简单的单周期处理器，执行一条指令的所有操作都在一个时钟周期内完成。</p>
                <p>我们将专注于一个简化的RISC-V指令子集，它包含了最核心的几类指令：</p>
                <ul>
                <li><strong>算术逻辑指令 (R-Type):</strong> <code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>slt</code></li>
                <li><strong>访存指令 (Load/Store):</strong> <code>ld</code>, <code>sd</code></li>
                <li><strong>条件分支指令 (Branch):</strong> <code>beq</code></li>
                </ul>
                <p>我们的目标就是设计一个能够正确执行这些指令的数据通路和控制器。</p>
                <h4 id="12-%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%83%E4%BB%B6"><strong>1.2 构建数据通路的基本元件</strong></h4>
                <p>一个处理器的数据通路是由一系列的<strong>组合逻辑元件 (Combinational Elements)</strong> 和<strong>状态元件 (State Elements)</strong> 构成的。</p>
                <ul>
                <li><strong>状态元件 (也称时序逻辑元件):</strong> 它们内部含有存储单元，其输出不仅取决于当前的输入，还与内部存储的状态有关。它们的状态只在<strong>时钟边沿 (clock edge)</strong> 发生变化。
                <ul>
                <li><strong>程序计数器 (Program Counter, PC):</strong> 一个寄存器，存放当前正在执行指令的内存地址。</li>
                <li><strong>指令存储器 (Instruction Memory):</strong> 存放程序指令。</li>
                <li><strong>寄存器堆 (Register File):</strong> 包含32个通用寄存器。</li>
                <li><strong>数据存储器 (Data Memory):</strong> 存放程序数据。</li>
                </ul>
                </li>
                <li><strong>组合逻辑元件:</strong> 其输出仅由当前输入决定，没有记忆功能。
                <ul>
                <li><strong>算术逻辑单元 (ALU):</strong> 执行算术（加、减）和逻辑（与、或）运算。</li>
                <li><strong>加法器 (Adder):</strong> 专门用于地址计算等。</li>
                <li><strong>多路选择器 (Multiplexer, MUX):</strong> 根据控制信号，从多个输入中选择一个作为输出。</li>
                </ul>
                </li>
                </ul>
                <div class="mermaid">graph TD
                    subgraph "处理器核心组件"
                        direction LR
                        A["状态元件 (有记忆)"]
                        B["组合逻辑元件 (无记忆)"]
                    end
                    A --> PC["程序计数器 (PC)"];
                    A --> IM["指令存储器"];
                    A --> RF["寄存器堆"];
                    A --> DM["数据存储器"];
                    B --> ALU["ALU"];
                    B --> Adder["加法器"];
                    B --> MUX["多路选择器"];
                </div>
                <h3 id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><strong>第二部分：构建一个简单的数据通路</strong></h3>
                <p>我们将采用一种增量式的方法，逐一满足各类指令的需求，最终将它们组合成一个完整的数据通路。</p>
                <h4 id="21-%E5%8F%96%E6%8C%87-instruction-fetch"><strong>2.1 取指 (Instruction Fetch)</strong></h4>
                <p>任何指令执行的第一步都是<strong>取指</strong>。这个过程需要：</p>
                <ol>
                <li><strong>PC：</strong> 提供当前指令的地址。</li>
                <li><strong>指令存储器：</strong> 根据PC提供的地址，读出对应的32位指令。</li>
                <li><strong>加法器：</strong> 计算下一条指令的地址，即 <code>PC + 4</code>。</li>
                </ol>
                <p>在每个时钟周期的上升沿，PC的值会被更新为 <code>PC + 4</code>，从而为下一个周期的取指做好准备。</p>
                <div class="mermaid">graph LR
                    PC -- "指令地址" --> IM[指令存储器];
                    IM -- "32位指令" --> Others[...]
                    PC -- "+4" --> Adder
                    Adder -- "下一指令地址" --> PC
                </div>
                <h4 id="22-r-%E5%9E%8B%E6%8C%87%E4%BB%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><strong>2.2 R-Type指令的数据通路</strong></h4>
                <p>R-Type指令，如 <code>add x5, x6, x7</code>，需要执行以下操作：</p>
                <ol>
                <li>从寄存器堆中读出两个源寄存器 (<code>rs1</code>, <code>rs2</code>) 的值。指令中的<code>rs1</code>和<code>rs2</code>字段（各5位）作为寄存器堆的读地址输入。</li>
                <li>将这两个值送入ALU进行运算。ALU的操作类型由指令的<code>funct3</code>和<code>funct7</code>字段决定。</li>
                <li>将ALU的运算结果写回到目标寄存器 (<code>rd</code>)。指令中的<code>rd</code>字段作为寄存器堆的写地址输入。</li>
                </ol>
                <div class="mermaid">graph TD
                    A[指令] --> B{解码};
                    B -- rs1地址 --> C[寄存器堆];
                    B -- rs2地址 --> C;
                    C -- rs1数据 --> D[ALU];
                    C -- rs2数据 --> D;
                    B -- funct3/7 --> D;
                    D -- 结果 --> C;
                    B -- rd地址 --> C;
                </div>
                <h4 id="23-%E8%AE%BF%E5%AD%98%E6%8C%87%E4%BB%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><strong>2.3 访存指令的数据通路</strong></h4>
                <p>访存指令，如 <code>ld x5, 40(x6)</code> 或 <code>sd x5, 40(x6)</code>，需要：</p>
                <ol>
                <li><strong>地址计算：</strong>
                <ul>
                <li>读出基址寄存器 (<code>rs1</code>, 即<code>x6</code>) 的值。</li>
                <li>将指令中的12位立即数偏移量 (<code>40</code>) 进行<strong>符号扩展 (Sign-extension)</strong> 到64位。</li>
                <li>将两者送入ALU相加，得到有效的内存地址。</li>
                </ul>
                </li>
                <li><strong>数据传输：</strong>
                <ul>
                <li>对于<strong>加载 (ld)</strong>：使用计算出的地址从数据存储器中读取数据，然后将数据写回目标寄存器 (<code>rd</code>, 即<code>x5</code>)。</li>
                <li>对于<strong>存储 (sd)</strong>：使用计算出的地址，将源寄存器 (<code>rs2</code>, 即<code>x5</code>) 的值写入数据存储器。</li>
                </ul>
                </li>
                </ol>
                <div class="mermaid">graph TD
                    A[指令] --> B{解码};
                    B -- rs1地址 --> RF[寄存器堆];
                    RF -- 基址 --> ALU;
                    B -- 立即数 --> SE[符号扩展];
                    SE -- 偏移量 --> ALU;
                    ALU -- 内存地址 --> DM[数据存储器];
                    
                    subgraph "Load (ld)"
                        DM -- 读出数据 --> RF;
                        B -- rd地址 --> RF;
                    end

                    subgraph "Store (sd)"
                        B -- rs2地址 --> RF;
                        RF -- 写入数据 --> DM;
                    end
                </div>
                <h4 id="24-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><strong>2.4 条件分支指令的数据通路</strong></h4>
                <p>条件分支指令，如 <code>beq x5, x6, Label</code>，需要：</p>
                <ol>
                <li><strong>比较：</strong> 读出两个源寄存器 (<code>rs1</code>, <code>rs2</code>) 的值，送入ALU进行减法运算。</li>
                <li><strong>判断：</strong> 检查ALU的<code>Zero</code>输出。如果为1，说明两个寄存器相等，分支应该发生。</li>
                <li><strong>目标地址计算：</strong>
                <ul>
                <li>将指令中的12位立即数偏移量进行符号扩展并<strong>左移1位</strong>（因为偏移量是以半字为单位的）。</li>
                <li>将这个偏移量与<strong>当前PC+4</strong>的值相加，得到分支目标地址。</li>
                </ul>
                </li>
                <li><strong>更新PC：</strong> 如果分支发生，则用分支目标地址更新PC；否则，PC正常更新为 <code>PC + 4</code>。这需要一个MUX来选择下一个PC的值。</li>
                </ol>
                <div class="mermaid">graph TD
                    A[指令] --> B{解码};
                    B -- rs1 --> RF[寄存器堆];
                    B -- rs2 --> RF;
                    RF -- 数据1 --> ALU;
                    RF -- 数据2 --> ALU;
                    ALU -- Zero信号 --> MUX_PC[PC MUX];
                    
                    subgraph "分支目标地址计算"
                       PC -- "+4" --> Adder1
                       B -- 立即数 --> SE[符号扩展] -- "左移1位" --> Shift
                       Adder1 -- PC+4 --> Adder2
                       Shift -- 偏移量 --> Adder2
                       Adder2 -- 目标地址 --> MUX_PC
                    end
                    
                    Adder1 -- 正常PC+4 --> MUX_PC;
                    MUX_PC -- "下一个PC地址" --> PC;
                </div>
                <h3 id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%8D%95%E5%91%A8%E6%9C%9F%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><strong>第三部分：建立一个单周期数据通路</strong></h3>
                <p>现在，我们需要将上面为不同类型指令设计的独立数据通路**合并**成一个统一的数据通路。合并的关键在于使用<strong>多路选择器 (MUX)</strong> 来根据指令类型选择正确的数据来源。</p>
                <p><strong>关键的合并点：</strong></p>
                <ol>
                <li><strong>ALU的第二个输入：</strong> 它可以来自寄存器堆的第二个读端口（用于R-Type和beq），也可以来自经过符号扩展的立即数（用于I-Type和S-Type）。我们需要一个MUX（称为<code>ALUSrc</code>）来选择。</li>
                <li><strong>写回寄存器堆的数据：</strong> 它可以来自ALU的运算结果（用于R-Type和I-Type），也可以来自数据存储器的输出（用于ld）。我们需要一个MUX（称为<code>MemtoReg</code>）来选择。</li>
                <li><strong>PC的下一个值：</strong> 它可以是 <code>PC+4</code>（正常执行），也可以是分支目标地址。我们需要一个MUX来选择，其选择信号由<code>beq</code>指令的比较结果和另一个控制信号（<code>Branch</code>）共同决定。</li>
                </ol>
                <p>将所有这些组件和MUX连接起来，我们就得到了一个可以处理我们指令子集的单周期数据通路。</p>
                <div class="mermaid">graph TD
                    subgraph "统一数据通路"
                        PC -- 地址 --> IM[指令存储器]
                        IM -- 指令 --> CU[控制器]
                        IM -- 指令[31-0] --> Dec{解码}
                        
                        Dec -- rs1 --> RF[寄存器堆]
                        Dec -- rs2 --> RF
                        Dec -- rd --> RF
                        
                        RF -- 读数据1 --> ALU
                        RF -- 读数据2 --> MUX_ALU
                        Dec -- 立即数 --> SE[符号扩展]
                        SE --> MUX_ALU
                        
                        MUX_ALU -- ALU输入2 --> ALU
                        ALU -- 结果 --> MUX_WB
                        ALU -- Zero --> BranchLogic
                        
                        ALU -- 地址 --> DM[数据存储器]
                        RF -- 写数据 --> DM
                        DM -- 读数据 --> MUX_WB
                        
                        MUX_WB -- 写回数据 --> RF
                        
                        CU -- 控制信号 --> MUX_ALU
                        CU -- 控制信号 --> MUX_WB
                        CU -- 控制信号 --> RF
                        CU -- 控制信号 --> ALUControl
                        CU -- 控制信号 --> DM
                        CU -- 控制信号 --> BranchLogic
                        
                        PC -- "+4" --> PC_ADD4
                        PC_ADD4 --> MUX_PC
                        SE -- "左移1位" --> SHIFT_BRANCH
                        PC_ADD4 -- "+偏移" --> ADD_BRANCH
                        SHIFT_BRANCH --> ADD_BRANCH
                        ADD_BRANCH -- 分支目标 --> MUX_PC
                        
                        BranchLogic -- 选择 --> MUX_PC
                        MUX_PC -- 新PC值 --> PC
                    end
                </div>
                <p><em>(上图是一个简化的单周期数据通路与控制逻辑的示意图)</em></p>
                <h3 id="%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E5%99%A8"><strong>第四部分：设计控制器</strong></h3>
                <p>数据通路已经搭建好了，但它还是一堆“死”的硬件。我们需要一个“大脑”——<strong>控制器 (Control Unit)</strong>——来根据当前指令，生成正确的控制信号，指挥数据通路中的各个MUX选择正确的输入，并告诉ALU、寄存器堆和存储器应该执行什么操作（读、写、运算类型等）。</p>
                <p>控制器的输入是指令的<strong>操作码 (opcode)</strong> 字段。它是一个组合逻辑电路，其输出就是数据通路上所有的控制信号。</p>
                <h4 id="41-alu-%E6%8E%A7%E5%88%B6%E5%99%A8"><strong>4.1 ALU 控制器</strong></h4>
                <p>ALU本身可能支持很多种运算（如AND, OR, ADD, SUB, SLT等），它需要一个几位的控制信号来选择具体执行哪一种。</p>
                <p>主控制器并不需要关心指令的具体运算是什么（例如，它不知道<code>add</code>和<code>sub</code>的区别）。它只需要根据<code>opcode</code>生成一个更上层的、2位的<code>ALUOp</code>信号：</p>
                <ul>
                <li><code>00</code>：用于访存指令（需要加法来计算地址）</li>
                <li><code>01</code>：用于分支指令（需要减法来进行比较）</li>
                <li><code>10</code>：用于R-Type指令</li>
                </ul>
                <p>然后，一个专门的<strong>ALU控制器</strong>，会结合这个2位的<code>ALUOp</code>信号和指令的<code>funct</code>字段（对于R-Type指令），生成最终送给ALU的、具体的4位操作选择信号。</p>
                <div class="mermaid">graph TD
                    A[主控制器] -- ALUOp(2位) --> B[ALU控制器];
                    C[指令funct字段] --> B;
                    B -- ALU控制信号(4位) --> D[ALU];
                </div>
                <p>这种分层设计使得主控制器更简单，并将与运算细节相关的逻辑局部化到了ALU控制器中。</p>
                <h4 id="42-%E4%B8%BB%E6%8E%A7%E5%88%B6%E5%99%A8"><strong>4.2 主控制器</strong></h4>
                <p>主控制器的设计可以通过一个<strong>真值表</strong>来完成。这个表的输入是指令的6位<code>opcode</code>，输出是数据通路上所有的控制信号（如<code>RegWrite</code>, <code>ALUSrc</code>, <code>MemtoReg</code>, <code>MemRead</code>, <code>MemWrite</code>, <code>Branch</code>, <code>ALUOp</code>等）。</p>
                <p>例如：</p>
                <ul>
                <li>对于<strong>R-Type</strong>指令：<code>RegWrite=1</code>, <code>ALUSrc=0</code>, <code>MemtoReg=0</code>, <code>Branch=0</code>, <code>ALUOp=10</code>...</li>
                <li>对于<strong>ld</strong>指令：<code>RegWrite=1</code>, <code>ALUSrc=1</code>, <code>MemtoReg=1</code>, <code>MemRead=1</code>, <code>MemWrite=0</code>, <code>Branch=0</code>, <code>ALUOp=00</code>...</li>
                <li>对于<strong>sd</strong>指令：<code>RegWrite=0</code>, <code>ALUSrc=1</code>, <code>MemWrite=1</code>...</li>
                <li>对于<strong>beq</strong>指令：<code>Branch=1</code>, <code>ALUOp=01</code>...</li>
                </ul>
                <p>这个真值表可以直接用逻辑门电路来实现，从而构成一个完整的、能够根据指令自动工作的控制器。</p>
                <h3 id="%E6%80%BB%E7%BB%93"><strong>总结</strong></h3>
                <p>在本讲中，我们从零开始，成功地构建了一个简化的单周期RISC-V处理器的数据通路和控制器。</p>
                <ol>
                <li>我们理解了处理器的基本组成部分：<strong>状态元件</strong>和<strong>组合逻辑元件</strong>。</li>
                <li>我们通过增量式的方法，分别为<strong>取指、R-Type、访存和分支</strong>指令设计了数据通路。</li>
                <li>我们学习了如何使用<strong>多路选择器 (MUX)</strong> 将这些独立的数据通路合并成一个统一的、功能完备的数据通路。</li>
                <li>我们设计了分层的<strong>控制器</strong>，包括一个根据<code>opcode</code>生成高级控制信号的<strong>主控制器</strong>，和一个根据<code>funct</code>字段生成具体ALU操作信号的<strong>ALU控制器</strong>。</li>
                </ol>
                <p>虽然我们设计的只是一个简单的单周期处理器，但它已经包含了现代处理器最核心的设计思想和组件。在接下来的章节中，我们将在此基础上，学习如何通过<strong>流水线 (Pipelining)</strong> 技术来大幅提升处理器的性能。</p>
            </article>
        </main>
    </div>
    
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
</body>
</html>