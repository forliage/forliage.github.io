<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>x86汇编10-2:保护模式进阶</title>
    
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../modal.css">
    
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
                <li><a href="#" id="about-me-btn">ABOUT ME</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="x86%E6%B1%87%E7%BC%9610-2%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6">x86汇编10-2:保护模式进阶</h1>
                <h3 id="%E5%BC%95%E8%A8%80"><strong>引言</strong></h3>
                <p>想象一下两个国家，一个是平民区（Ring 3），一个是戒备森严的中央政务区（Ring 0）。平民不能随意闯入政务区，否则会被卫兵（CPU硬件异常）立即逮捕。但是，平民需要办事，比如办理护照（文件IO）。</p>
                <p>解决方案是什么？在两个区域的边界上设立一个**“大使馆”或“政务服务大厅”**。这个大厅本身有明确的地址，平民被允许进入。进入后，你不能乱跑，只能到指定的窗口，提交你的申请，由内部的工作人员（高权限代码）为你办理，办完后将结果交给你，然后你离开。</p>
                <p>在x86保护模式中，这个“服务大厅”就是<strong>门描述符（Gate Descriptor）</strong>。</p>
                <h3 id="1-%E8%B0%83%E7%94%A8%E9%97%A8-call-gate"><strong>1 调用门 (Call Gate)</strong></h3>
                <p>调用门是为**应用程序主动请求操作系统服务（即系统调用）**而设计的。</p>
                <h4 id="11-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B0%83%E7%94%A8%E9%97%A8"><strong>1.1 什么是调用门？</strong></h4>
                <ul>
                <li>
                <p><strong>定义</strong>: 调用门是一个<strong>系统段描述符</strong>（S=0，Type=12），它不指向一段内存，而是定义了一个受控的<strong>远过程调用（Far Call）</strong>。它本质上是一个安全的“传送门”，其描述符中包含了传送的目标地址和规则。</p>
                </li>
                <li>
                <p><strong>位置</strong>: 调用门描述符可以存放在GDT或LDT中。</p>
                </li>
                <li>
                <p><strong>结构 (8字节)</strong>:</p>
                <ul>
                <li><strong>目标代码段选择子 (Destination Selector)</strong>: 目标过程（通常是Ring 0）的代码段选择子。</li>
                <li><strong>目标偏移 (Destination Offset)</strong>: 目标过程在代码段内的32位入口地址。</li>
                <li><strong>DPL (Descriptor Privilege Level)</strong>: <strong>门本身的权限</strong>。这至关重要，它规定了<strong>谁有资格使用这个门</strong>。通常设置为3，表示Ring 3的应用程序可以使用。</li>
                <li><strong>参数数量 (Parameter Count)</strong>: 指定在发生特权级切换时，需要从调用者（低权限）的堆栈上复制多少个参数（以<code>DWORD</code>为单位）到被调用者（高权限）的堆栈上。</li>
                <li><strong>P (Present) 位</strong>: 该门是否有效。</li>
                </ul>
                </li>
                <li>
                <p><strong>设计哲学</strong>: 调用门的设计体现了<strong>最小权限原则</strong>和<strong>接口封装</strong>。</p>
                <ol>
                <li><strong>受控入口</strong>: 应用程序不能跳转到内核的任意位置，只能跳转到调用门指定的<strong>唯一入口点</strong>。这防止了恶意代码绕过安全检查，直接执行内核的危险代码。</li>
                <li><strong>权限隔离</strong>: 应用程序只是“使用”门（<code>CALL</code>一个门选择子），它对门背后的Ring 0代码一无所知，也无法修改。</li>
                </ol>
                </li>
                </ul>
                <h4 id="12-%E8%B0%83%E7%94%A8%E9%97%A8%E7%9B%B8%E5%85%B3%E7%9A%84call%E5%92%8Cretf%E6%8C%87%E4%BB%A4"><strong>1.2 调用门相关的<code>CALL</code>和<code>RETF</code>指令</strong></h4>
                <p>当一个<code>CALL FAR</code>指令的操作数指向一个调用门选择子时，CPU会执行一套极其复杂的、由硬件固化的操作流程。</p>
                <p><strong><code>CALL FAR gate_selector:offset</code> (offset会被忽略) 的硬件执行流程:</strong></p>
                <ol>
                <li><strong>权限检查</strong>:
                <ul>
                <li><strong>检查1 (访问门)</strong>: <code>CPL &lt;= Gate DPL</code> 并且 <code>RPL &lt;= Gate DPL</code>。确保当前代码和请求者有权使用这个门。</li>
                <li><strong>检查2 (目标代码段)</strong>: 调用门指向的目标代码段描述符的<code>DPL</code>必须<strong>小于等于</strong><code>CPL</code>。即，只允许通过调用门<strong>转移到同级或更高权限</strong>的代码段。</li>
                </ul>
                </li>
                <li><strong>如果发生特权级提升 (例如，从Ring 3 -&gt; Ring 0):</strong>
                <ul>
                <li><strong>堆栈切换 (Stack Switch)</strong>: 这是最关键的安全机制。CPU不能继续使用Ring 3的堆栈，因为它不安全、不可靠且可能空间不足。CPU会：
                <ol>
                <li>查找当前任务的<strong>任务状态段 (TSS)</strong>（由<code>TR</code>寄存器指向）。</li>
                <li>从TSS中取出为目标特权级（Ring 0）预先准备好的堆栈指针：<code>SS0</code>和<code>ESP0</code>。</li>
                <li>加载<code>SS0</code>和<code>ESP0</code>到<code>SS</code>和<code>ESP</code>寄存器，切换到内核的安全堆栈。</li>
                </ol>
                </li>
                <li><strong>参数复制</strong>:
                <ol>
                <li>CPU将旧的<code>SS</code>和<code>ESP</code>（Ring 3的堆栈指针）压入<strong>新的内核堆栈</strong>。</li>
                <li>根据调用门描述符中的<strong>参数数量</strong>，将指定数量的参数从旧堆栈复制到新堆栈。</li>
                </ol>
                </li>
                <li><strong>压入返回地址</strong>:
                <ol>
                <li>将旧的<code>CS</code>和<code>EIP</code>（Ring 3的返回地址）压入新堆栈。</li>
                </ol>
                </li>
                </ul>
                </li>
                <li><strong>加载并跳转</strong>:
                <ul>
                <li>将调用门中指定的<strong>目标代码段选择子</strong>和<strong>目标偏移</strong>加载到<code>CS</code>和<code>EIP</code>寄存器。</li>
                <li><code>CS</code>中的<code>CPL</code>此时更新为目标代码段的DPL（即0）。</li>
                <li>CPU开始从Ring 0的新地址执行。</li>
                </ul>
                </li>
                </ol>
                <p><strong><code>RETF</code> (Far Return) 的硬件执行流程:</strong>
                当Ring 0的代码执行<code>RETF</code>时，CPU会检查栈上的返回地址<code>CS</code>选择子，发现其<code>RPL</code>为3，就知道这是一次跨级返回。</p>
                <ol>
                <li>CPU执行权限检查。</li>
                <li>从当前（内核）堆栈上弹出<code>EIP</code>, <code>CS</code>, <code>ESP</code>, <code>SS</code>，恢复到Ring 3的状态。</li>
                <li>堆栈切换回用户空间。</li>
                <li>（可选）如果<code>RETF</code>带有操作数（如<code>RETF 8</code>），会在<strong>返回后</strong>调整用户堆栈指针，用于清理参数。</li>
                </ol>
                <h4 id="13-%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5-tss-%E4%B8%8E%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><strong>1.3 任务状态段 (TSS) 与任务切换</strong></h4>
                <ul>
                <li><strong>TSS (Task State Segment)</strong>: 是内存中一个特殊的数据结构，用于保存一个任务（进程或线程）的完整上下文（所有寄存器的值、LDT选择子、I/O权限位图等）。</li>
                <li><strong>在门调用中的核心作用</strong>: TSS在现代操作系统中很少用于硬件任务切换（因为效率不高），但它有一个<strong>不可替代</strong>的作用：为每个任务提供<strong>特权级0、1、2的堆栈指针（<code>SS0/ESP0</code>, <code>SS1/ESP1</code>, <code>SS2/ESP2</code>）</strong>。</li>
                <li><strong>设计哲学</strong>: 操作系统在创建每个进程时，都会为其创建一个TSS，并在TSS中填好该进程的内核堆栈地址。当该进程通过调用门或中断进入内核时，CPU硬件能自动、安全地找到正确的内核堆栈，实现了<strong>进程间的内核堆栈隔离</strong>。</li>
                </ul>
                <h4 id="14-%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E4%BE%8B"><strong>1.4 调用门实例</strong></h4>
                <p>一个Ring 3程序通过调用门调用Ring 0的代码，在屏幕上打印一条消息。</p>
                <pre class="hljs"><code><div>; --- GDT 定义 ---
                ; ... (NULL, Ring0 Code/Data, Ring3 Code/Data 描述符) ...
                GDT_CALL_GATE_SELECTOR EQU $ - GDT_BASE
                gdt_call_gate:
                    DW gate_offset_low      ; 目标偏移 0-15
                    DW GDT_RING0_CODE_SELECTOR ; 目标代码段选择子
                    DB 0                    ; 参数数量 (0-4位) &amp; 保留位
                    DB 11101100b            ; Type=CallGate, S=0, DPL=3, P=1
                    DW gate_offset_high     ; 目标偏移 16-31

                ; --- Ring 3 代码 ---
                CALL FAR [cs:gdt_call_gate] ; 调用门，offset部分会被忽略

                ; --- Ring 0 处理程序 (由门指向) ---
                gate_handler:
                    ; 此时CPL=0, 运行在独立的内核堆栈上
                    ; ... 在屏幕打印 "Hello from Ring 0!" 的代码 ...
                    RETF
                </div></code></pre>
                <h3 id="2-%E4%B8%AD%E6%96%AD%E9%97%A8%E4%B8%8E%E9%99%B7%E9%98%B1%E9%97%A8%E6%84%8F%E5%A4%96%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%B4%A7%E6%80%A5%E9%80%9A%E9%81%93"><strong>2 中断门与陷阱门——意外事件的“紧急通道”</strong></h3>
                <p>硬件中断和CPU异常是不可预知的事件。当中断发生时，如果CPU正运行在Ring 3，而中断处理程序在Ring 0，同样需要一个安全的跨级机制。这个机制就是<strong>中断门</strong>和<strong>陷阱门</strong>。</p>
                <h4 id="21-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD%E9%97%A8%E9%99%B7%E9%98%B1%E9%97%A8"><strong>2.1 什么是中断门/陷阱门？</strong></h4>
                <ul>
                <li><strong>定义</strong>: 它们也是系统段描述符，结构与调用门非常相似，但用于处理中断和异常。</li>
                <li><strong>位置</strong>: 必须存放在<strong>中断描述符表 (IDT - Interrupt Descriptor Table)</strong> 中。CPU通过<code>IDTR</code>寄存器找到IDT。</li>
                <li><strong>区别 (中断类别)</strong>:
                <ul>
                <li><strong>中断门 (Interrupt Gate)</strong>: 当通过此门进入处理程序时，CPU硬件<strong>自动清除<code>IF</code>标志位</strong>，即<strong>关中断</strong>。</li>
                <li><strong>陷阱门 (Trap Gate)</strong>: 进入处理程序时，<strong>不改变<code>IF</code>标志位</strong>。</li>
                </ul>
                </li>
                <li><strong>设计哲学</strong>:
                <ul>
                <li><strong>硬件中断</strong>（如时钟、键盘）应该使用<strong>中断门</strong>。这可以防止在处理一个中断时，被同类型的另一个中断打断，造成堆栈溢出等问题（中断嵌套需要非常小心地手动管理）。</li>
                <li><strong>异常</strong>（如缺页、除零）和<strong>软件中断</strong>(<code>INT n</code>)通常使用<strong>陷阱门</strong>。因为在处理一个异常时，允许响应更紧急的硬件中断是合理的。</li>
                </ul>
                </li>
                </ul>
                <h4 id="22-%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3%E7%9A%84int%E5%92%8Ciretd%E6%8C%87%E4%BB%A4"><strong>2.2 中断相关的<code>INT</code>和<code>IRETD</code>指令</strong></h4>
                <p><strong>中断/异常发生时的硬件执行流程:</strong></p>
                <ol>
                <li>CPU获取中断向量号<code>N</code>。</li>
                <li>CPU用<code>N</code>作为索引，在IDT中查找第<code>N</code>个门描述符。</li>
                <li><strong>权限检查</strong>:
                <ul>
                <li>对于软件中断<code>INT n</code>，检查 <code>CPL &lt;= Gate DPL</code>。允许应用程序触发中断。</li>
                <li>对于硬件中断和异常，通常不检查CPL。</li>
                </ul>
                </li>
                <li><strong>如果发生特权级提升 (Ring 3 -&gt; Ring 0):</strong>
                <ul>
                <li><strong>堆栈切换</strong>: 与调用门完全相同，使用TSS中的<code>SS0/ESP0</code>切换到内核堆栈。</li>
                <li><strong>压栈</strong>: CPU依次将旧的<code>SS</code>, <code>ESP</code>, <code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>压入<strong>新的内核堆栈</strong>。</li>
                <li><strong>（可选）压入错误码</strong>: 某些异常（如缺页、通用保护）会由硬件额外压入一个错误码。</li>
                </ul>
                </li>
                <li><strong>加载并跳转</strong>:
                <ul>
                <li>从门描述符中加载目标<code>CS</code>和<code>EIP</code>。</li>
                <li>如果使用的是中断门，清除<code>IF</code>标志位。</li>
                <li><code>CPL</code>更新为0，开始执行中断处理程序。</li>
                </ul>
                </li>
                </ol>
                <p><strong><code>IRETD</code> (Interrupt Return, 32-bit) 的硬件执行流程:</strong>
                这是从中断/异常处理程序返回的<strong>唯一</strong>指令。</p>
                <ol>
                <li>CPU执行权限检查。</li>
                <li><code>IRETD</code>会从当前堆栈上依次弹出<code>EIP</code>, <code>CS</code>, <code>EFLAGS</code>。</li>
                <li>因为恢复的<code>CS</code>指向了Ring 3，CPU知道发生了特权级切换，于是会继续弹出<code>ESP</code>和<code>SS</code>，恢复用户堆栈。</li>
                <li>执行恢复到Ring 3。<code>EFLAGS</code>的恢复是关键，它<strong>自动恢复了中断前的<code>IF</code>标志位状态</strong>。</li>
                </ol>
                <h4 id="23-%E4%B8%AD%E6%96%AD%E9%97%A8%E5%AE%9E%E4%BE%8B"><strong>2.3 中断门实例</strong></h4>
                <p>一个Ring 3程序通过<code>INT 80h</code>触发一个系统调用。</p>
                <pre class="hljs"><code><div>; --- IDT 定义 ---
                ; 假设IDT位于某处，IDTR已设置
                IDT_ENTRY_80H:
                    DW isr_offset_low      ; 目标偏移
                    DW GDT_RING0_CODE_SELECTOR
                    DB 0
                    DB 11101110b           ; Type=32bit TrapGate, S=0, DPL=3, P=1
                    DW isr_offset_high

                ; --- Ring 3 代码 ---
                INT 80h                     ; 触发中断

                ; --- Ring 0 中断服务程序 (ISR) ---
                isr_handler:
                    ; CPL=0, 运行在内核堆栈
                    ; 堆栈内容: [ESP]=EIP, [ESP+4]=CS, [ESP+8]=EFLAGS, ...
                    ; ... 处理系统调用 ...
                    IRETD                   ; 从中断返回
                </div></code></pre>
            </article>
        </main>
    </div>
    
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
    <!-- The Modal -->
    <div id="about-me-modal" class="modal">
      <!-- Modal content -->
      <div class="modal-content">
        <span class="close-button">&times;</span>
        <h2>About Me</h2>
        <p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
        <p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
        <p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
        <p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
        <p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
        <p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
        <hr>
        <h3>订阅我的博客</h3>
        <p>订阅功能正在建设中，敬请期待！</p>
      </div>
    </div>
    <script src="../modal.js"></script>
</body>
</html>