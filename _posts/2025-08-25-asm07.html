<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>x86汇编07:函数</title>
    
    <link rel="stylesheet" href="../style.css">
    
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="x86%E6%B1%87%E7%BC%9607%E5%87%BD%E6%95%B0">x86汇编07:函数</h1>
                <h3 id="1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89-defining-a-function"><strong>1 函数的定义 (Defining a Function)</strong></h3>
                <p>在汇编中，“定义”一个函数，本质上只是在代码段中标示出一段代码的起点和终点。汇编器提供了两种方式来做到这一点。</p>
                <h4 id="11-%E7%94%A8%E6%A0%87%E5%8F%B7%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><strong>1.1 用标号定义函数</strong></h4>
                <p>这是最简单、最纯粹的方式。一个函数就是一个以唯一标号开始，以<code>RET</code>指令结束的代码块。</p>
                <pre class="hljs"><code><div>my_function:            ; 函数入口点 (标号)
                    ; --- 函数体 ---
                    ...
                    RET                 ; 函数出口点 (返回指令)
                </div></code></pre>
                <ul>
                <li><strong>设计视角</strong>: 这种方式简单直接，但缺乏结构性。汇编器除了知道<code>my_function</code>是一个地址外，对它作为“函数”的身份一无所知。</li>
                </ul>
                <h4 id="12-%E7%94%A8proc%E4%BC%AA%E6%8C%87%E4%BB%A4%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><strong>1.2 用<code>proc</code>伪指令定义函数</strong></h4>
                <p>为了增强代码的可读性和结构性，汇编器（如MASM）提供了<code>PROC</code>和<code>ENDP</code>伪指令来显式地定义一个过程（Procedure）。</p>
                <pre class="hljs"><code><div>my_function PROC [NEAR|FAR] ; 定义过程开始
                    ; --- 函数体 ---
                    ...
                    RET
                my_function ENDP            ; 定义过程结束
                </div></code></pre>
                <ul>
                <li><strong><code>NEAR</code>或<code>FAR</code></strong>: 指定了这个函数是被段内调用（<code>CALL NEAR</code>）还是段间调用（<code>CALL FAR</code>）。这有助于汇编器生成正确的<code>CALL</code>和<code>RET</code>指令（<code>RET</code> vs <code>RETF</code>）。</li>
                <li><strong>设计视角</strong>: <code>PROC</code>/<code>ENDP</code>对汇编器有更丰富的语义。它帮助汇编器进行类型检查，并清晰地界定了函数的范围。对于阅读代码的人来说，这种形式也远比裸标号要清晰。这体现了编程工具从“能用”到“好用”的演进。</li>
                </ul>
                <h3 id="2-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-parameter-passing"><strong>2 函数的参数传递 (Parameter Passing)</strong></h3>
                <p>如何将数据从调用者（Caller）传递给被调用者（Callee）？这是函数设计中最核心的问题。主要有三种方法，各有优劣。</p>
                <h4 id="21-%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><strong>2.1 用寄存器传递参数</strong></h4>
                <ul>
                <li><strong>方法</strong>: 调用者在执行<code>CALL</code>指令前，将参数放入约定的通用寄存器中。被调用者直接从这些寄存器中读取参数。</li>
                <li><strong>优点</strong>: <strong>速度极快</strong>。寄存器是CPU中最快的存储单元，避免了内存访问的开销。</li>
                <li><strong>缺点</strong>:
                <ol>
                <li><strong>数量有限</strong>: 通用寄存器的数量非常少，无法传递大量参数。</li>
                <li><strong>破坏性</strong>: 参数会覆盖寄存器原有的值。如果调用者后续还需要使用这些寄存器，必须提前<code>PUSH</code>保存，调用结束后<code>POP</code>恢复。</li>
                <li><strong>缺乏规范</strong>: 如果没有统一约定，程序员A可能用<code>AX</code>传参，程序员B可能用<code>DX</code>，导致代码无法互操作。</li>
                </ol>
                </li>
                <li><strong>系统层面</strong>: 这种方式非常适合那些被频繁调用、性能要求极高、参数很少的内部辅助函数。现代的 <strong><code>fastcall</code></strong> 调用约定就是一种标准化的寄存器传参规范，它约定前几个参数通过<code>ECX</code>, <code>EDX</code>等传递，以提升性能。</li>
                <li><strong>例子</strong>: 一个计算<code>ax = bx + cx</code>的函数<pre class="hljs"><code><div>; --- 调用者 ---
                MOV BX, 10
                MOV CX, 20
                CALL add_func
                ; 调用后 AX = 30

                add_func PROC
                ; --- 被调用者 ---
                MOV AX, BX
                ADD AX, CX
                RET
                add_func ENDP
                </div></code></pre>
                </li>
                </ul>
                <h4 id="22-%E7%94%A8%E5%8F%98%E9%87%8F%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><strong>2.2 用变量传递参数</strong></h4>
                <ul>
                <li><strong>方法</strong>: 调用者将参数存放在约定的全局变量或内存地址中。被调用者从这些地址读取参数。</li>
                <li><strong>优点</strong>:
                <ol>
                <li><strong>参数数量和大小不受限</strong>。</li>
                <li><strong>非破坏性</strong>: 不会占用宝贵的寄存器。</li>
                </ol>
                </li>
                <li><strong>缺点</strong>:
                <ol>
                <li><strong>速度慢</strong>: 每次参数传递都涉及内存读写，开销较大。</li>
                <li><strong>非可重入 (Not Re-entrant)</strong>: 如果这个函数可能被中断，而中断服务程序又调用了同一个函数，那么后一次调用会覆盖前一次调用的参数，导致程序崩溃。因此，<strong>这种方法在多线程或中断驱动的环境下是极其危险的</strong>。</li>
                </ol>
                </li>
                <li><strong>系统层面</strong>: 适用于参数是大型数据结构（如一个大数组或结构体）的情况，此时通常传递的是这个数据结构的<strong>地址</strong>。</li>
                </ul>
                <h4 id="23-%E7%94%A8%E5%A0%86%E6%A0%88%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0-the-standard-way"><strong>2.3 用堆栈传递参数 (The Standard Way)</strong></h4>
                <p>这是最通用、最强大、也是C语言等高级语言默认采用的方式。</p>
                <ul>
                <li><strong>方法</strong>: 调用者在<code>CALL</code>指令前，将参数<strong>压入堆栈</strong>。被调用者通过访问堆栈来获取参数。</li>
                <li><strong>优点</strong>:
                <ol>
                <li><strong>参数数量和大小几乎不受限</strong>（仅受限于堆栈大小）。</li>
                <li><strong>支持可重入和递归</strong>: 每次函数调用都在堆栈上创建自己独立的“工作区”，互不干扰。</li>
                </ol>
                </li>
                <li><strong>缺点</strong>: 比寄存器传参慢，因为涉及内存操作。</li>
                </ul>
                <p><strong>动态变量与栈帧 (Stack Frame)</strong>
                为了在堆栈上高效、可靠地访问参数和局部变量，几乎所有函数都会在开头建立一个称为<strong>栈帧 (Stack Frame)</strong> 的结构。</p>
                <ul>
                <li><strong>建立栈帧 (Prologue):</strong><pre class="hljs"><code><div>PUSH EBP            ; 1. 保存调用者的栈帧基址
                MOV  EBP, ESP       ; 2. 将当前栈顶设为新的栈帧基址
                SUB  ESP, local_size; 3. 为局部变量(动态变量)分配空间
                </div></code></pre>
                </li>
                <li><strong>销毁栈帧 (Epilogue):</strong><pre class="hljs"><code><div>MOV  ESP, EBP       ; 1. 释放局部变量空间
                POP  EBP            ; 2. 恢复调用者的栈帧基址
                RET
                </div></code></pre>
                </li>
                <li><strong>栈帧结构图:</strong>
                当函数执行到<code>SUB ESP</code>之后，堆栈的布局如下：<pre class="hljs"><code><div>    高地址  +-----------------+
                            |    参数 n       |
                            +-----------------+  &lt;-- [EBP + 4 + 4*n]
                            |      ...        |
                            +-----------------+
                            |    参数 1       |  &lt;-- [EBP + 8]
                            +-----------------+
                            |  返回地址       |  &lt;-- [EBP + 4] (由CALL指令压入)
                    EBP -&gt;  +-----------------+
                            |  旧的 EBP       |  &lt;-- [EBP] (由 PUSH EBP 压入)
                            +-----------------+
                            |  局部变量 1     |  &lt;-- [EBP - 4]
                            +-----------------+
                            |      ...        |
                            +-----------------+
                            |  局部变量 m     |
                    ESP -&gt;  +-----------------+  &lt;-- 栈顶
                    低地址
                </div></code></pre>
                </li>
                <li><strong>设计与CPU架构</strong>: <code>EBP</code>寄存器的作用是提供一个在函数执行期间<strong>稳定不变的基准点</strong>。<code>ESP</code>作为栈顶指针，在<code>PUSH</code>/<code>POP</code>操作中会不断变化，如果直接用<code>[ESP + offset]</code>来访问参数，<code>offset</code>的值会非常难以计算。而有了<code>EBP</code>，无论<code>ESP</code>如何变化，<code>[EBP + 8]</code>永远指向第一个参数，<code>[EBP - 4]</code>永远指向第一个局部变量。这极大地简化了编译器的代码生成和程序员的手动编码。</li>
                </ul>
                <h4 id="%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-calling-conventions"><strong>调用约定 (Calling Conventions)</strong></h4>
                <p>谁负责将参数<code>PUSH</code>入栈？谁负责在函数返回后清理堆栈？这些问题由<strong>调用约定</strong>来规范。</p>
                <h5 id="231-cdecl"><strong>2.3.1 <code>__cdecl</code></strong></h5>
                <ul>
                <li><strong>C语言默认约定</strong>。</li>
                <li><strong>规则</strong>:
                <ol>
                <li>参数<strong>从右到左</strong>依次压栈。</li>
                <li><strong>调用者 (Caller)</strong> 负责清理堆栈。</li>
                </ol>
                </li>
                <li><strong>优点</strong>: 支持<strong>可变参数函数</strong>（如<code>printf</code>）。因为调用者知道自己压入了多少个参数，所以它可以正确地清理堆栈。被调用者（如<code>printf</code>）则从左到右读取参数，直到遇到格式化字符串的结尾。</li>
                <li><strong>例子</strong>: <code>my_func(1, 2, 3)</code><pre class="hljs"><code><div>; --- 调用者 ---
                PUSH 3
                PUSH 2
                PUSH 1
                CALL my_func
                ADD ESP, 12   ; 调用者清理3个4字节参数

                ; --- 被调用者 (my_func) ---
                ...
                RET           ; 直接返回
                </div></code></pre>
                </li>
                </ul>
                <h5 id="232-pascal"><strong>2.3.2 <code>__pascal</code></strong></h5>
                <ul>
                <li><strong>Pascal语言约定</strong>。</li>
                <li><strong>规则</strong>:
                <ol>
                <li>参数<strong>从左到右</strong>依次压栈。</li>
                <li><strong>被调用者 (Callee)</strong> 负责清理堆Stacks。</li>
                </ol>
                </li>
                <li><strong>缺点</strong>: 不支持可变参数。因为被调用者在编译时必须知道参数的总大小，才能生成正确的<code>RET n</code>指令。</li>
                <li><strong>优点</strong>: 生成的代码比<code>cdecl</code>稍微紧凑一些，因为多条<code>CALL</code>指令可以共用一次堆栈清理，而不是每条<code>CALL</code>后都跟一条<code>ADD ESP, n</code>。</li>
                </ul>
                <h5 id="233-stdcall"><strong>2.3.3 <code>__stdcall</code></strong></h5>
                <ul>
                <li><strong>Win32 API 标准约定</strong>。</li>
                <li><strong>规则</strong>:
                <ol>
                <li>参数<strong>从右到左</strong>依次压栈（同<code>cdecl</code>）。</li>
                <li><strong>被调用者 (Callee)</strong> 负责清理堆栈（同<code>pascal</code>）。</li>
                </ol>
                </li>
                <li><strong>设计哲学</strong>: 这是<code>cdecl</code>和<code>pascal</code>的折衷。它比<code>cdecl</code>代码尺寸小，同时“从右到左”的压栈顺序在某些架构上被认为更自然。这是Windows平台上最常见的调用约定。</li>
                <li><strong>例子</strong>: <code>my_func(1, 2, 3)</code><pre class="hljs"><code><div>; --- 调用者 ---
                PUSH 3
                PUSH 2
                PUSH 1
                CALL my_func
                ; (调用者什么也不做)

                ; --- 被调用者 (my_func) ---
                ...
                RET 12        ; 被调用者清理12字节堆栈
                </div></code></pre>
                </li>
                </ul>
                <h3 id="3-%E9%80%92%E5%BD%92-recursion"><strong>3递归 (Recursion)</strong></h3>
                <p>递归函数就是一个会直接或间接调用自身的函数。在高级语言中，这是一个强大的抽象工具。那么，它在底层是如何实现的呢？</p>
                <p><strong>递归的CPU架构层面合理性</strong>:
                递归之所以能够在x86架构上（以及几乎所有现代架构上）完美实现，完全得益于<strong>基于堆栈的函数调用机制</strong>。</p>
                <ol>
                <li><strong>独立的上下文</strong>: 每一次递归调用，都会在堆栈上创建一个<strong>全新的、独立的栈帧</strong>。</li>
                <li><strong>状态隔离</strong>: 这个新的栈帧包含了它自己的<strong>返回地址、旧EBP、局部变量和参数</strong>。它与上一次调用的栈帧在内存上是完全隔离的。</li>
                <li><strong>LIFO行为</strong>: <code>CALL</code>和<code>RET</code>指令天生就是后进先出（LIFO）的。最后一次调用最先返回，正好符合递归“层层深入，再层层返回”的模式。</li>
                </ol>
                <p>可以说，<strong>CPU的堆栈架构就是为实现递归而生的</strong>。没有堆栈，递归几乎无法实现。</p>
                <ul>
                <li><strong>例子</strong>: 计算阶乘 <code>factorial(n)</code><pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
                    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)
                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">else</span>
                        <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>);
                }
                </div></code></pre>
                </li>
                <li><strong>汇编实现 (<code>cdecl</code>):</strong><pre class="hljs"><code><div>factorial PROC
                    ; --- 栈帧建立 ---
                    PUSH EBP
                    MOV EBP, ESP
                    
                    MOV EAX, [EBP+8]    ; 获取参数 n

                    ; --- 基本情况 (Base Case) ---
                    CMP EAX, 1
                    JLE return_one      ; if (n &lt;= 1) goto return_one

                    ; --- 递归步骤 (Recursive Step) ---
                    DEC EAX             ; EAX = n - 1
                    PUSH EAX            ; 压入参数 (n - 1)
                    CALL factorial      ; 递归调用 factorial(n - 1)
                    ADD ESP, 4          ; 调用者清理堆栈

                    ; 此时 EAX 中是 factorial(n - 1) 的结果
                    MOV EBX, [EBP+8]    ; 重新获取参数 n 到 EBX
                    IMUL EAX, EBX       ; EAX = n * factorial(n - 1)
                    
                    JMP cleanup         ; 跳转到函数结尾

                return_one:
                    MOV EAX, 1          ; 返回 1

                cleanup:
                    ; --- 栈帧销毁 ---
                    MOV ESP, EBP
                    POP EBP
                    RET
                factorial ENDP
                </div></code></pre>
                当调用<code>factorial(3)</code>时，堆栈会像这样增长和收缩，每一层都有自己独立的<code>n</code>值和返回地址，互不干扰：
                <ol>
                <li><code>CALL factorial(3)</code> -&gt; 创建<code>n=3</code>的栈帧。</li>
                <li><code>CALL factorial(2)</code> -&gt; 创建<code>n=2</code>的栈帧。</li>
                <li><code>CALL factorial(1)</code> -&gt; 创建<code>n=1</code>的栈帧。</li>
                <li><code>factorial(1)</code>返回1。</li>
                <li><code>factorial(2)</code>的栈帧恢复，计算 <code>2 * 1</code>，返回2。</li>
                <li><code>factorial(3)</code>的栈帧恢复，计算 <code>3 * 2</code>，返回6。</li>
                </ol>
                </li>
                </ul>
            </article>
        </main>
    </div>
    
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
</body>
</html>