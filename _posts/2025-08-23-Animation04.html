<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>计算机动画04：三维Morphing技术</title>
    <link rel="stylesheet" href="../style.css">
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A8%E7%94%BB04%E4%B8%89%E7%BB%B4morphing%E6%8A%80%E6%9C%AF">计算机动画04：三维Morphing技术</h1>
                <h3 id="1-%E5%BC%80%E7%AF%87%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BB%B4morphing">1. 开篇：什么是三维Morphing？</h3>
                <p>首先，让我们通过几个生动的例子，直观地感受一下这项技术的魅力。</p>
                <p>想象一下，一个游戏角色，在我们的注视下，从一个普通人的形态，平滑、无缝地转变为一个充满力量的恶魔形态。或者，在一个汽车设计展示中，一辆概念车的设计方案，在不同的空气动力学外形之间流畅地演变。这些就是Morphing的魔力所在。</p>
                <p>那么，到底什么是三维Morphing呢？</p>
                <p><strong>定义</strong>：所谓三维Morphing（三维形状渐变），是指将一个三维物体的形状（我们称之为<strong>源物体</strong>），通过一个光滑、连续的变换，演变为另一个三维物体的形状（我们称之为<strong>目标物体</strong>）的过程。</p>
                <p>这个过程绝非简单的两个物体淡入淡出，而是几何结构本身的“生长”和“演化”。</p>
                <p>让我们来看一个经典的范例：一头三维的恐龙模型，它的每一个顶点、每一条边、每一个面，都在发生连续的变化，最终变成了我们日常生活中常见的电熨斗。在这个变换过程中的任何一个瞬间，我们所看到的都不是模糊的重影，而是一个完整、独立、全新的三维模型。</p>
                <h3 id="2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E4%B8%89%E7%BB%B4morphing%E4%B8%8E%E4%BA%8C%E7%BB%B4morphing%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB">2. 为什么要用三维Morphing？与二维Morphing的本质区别</h3>
                <p>大家可能会问，我们平时在很多软件里也见过二维图片的Morphing，比如把一个人的脸变成另一个人的脸，它们和我们今天要讲的技术有什么本质区别呢？</p>
                <p>这是一个非常关键的问题，也是理解3D Morphing巨大优势的核心。</p>
                <ul>
                <li>
                <p><strong>二维Morphing的局限</strong>：</p>
                <ul>
                <li>二维Morphing技术处理的对象是<strong>图像</strong>。图像的本质是像素的集合，它本身<strong>不包含任何三维几何信息</strong>。</li>
                <li>这意味着，当你对两张图片做Morphing时，你只是在像素层面进行扭曲和色彩混合。</li>
                <li>其最大的局限在于，生成的中间结果仍然是二维图像。你<strong>无法改变观察的视角</strong>，也无法重新对场景进行光照计算。如果源动画和目标动画的摄像机在运动，二维Morphing就束手无策了。</li>
                </ul>
                </li>
                <li>
                <p><strong>三维Morphing的优势</strong>：</p>
                <ul>
                <li>三维Morphing处理的对象是<strong>三维模型</strong>。我们操作的是模型的顶点坐标、拓扑结构等真实的几何数据。</li>
                <li>它生成的中间帧是<strong>完整的、全新的三维模型</strong>，而不仅仅是一张图片。</li>
                <li>这意味着，一旦我们得到了从源模型到目标模型的中间模型序列，我们就可以：
                <ul>
                <li>从<strong>任意摄像机角度</strong>去观察这个变换过程。</li>
                <li>在<strong>任意光照条件</strong>下对中间模型进行重新渲染，生成精确的光照和阴影效果。</li>
                <li>将这个变换过程无缝地<strong>融入到其他复杂的三维场景</strong>中。</li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
                <p>尽管三维Morphing的算法要复杂得多，但正是因为它能生成如此逼真和生动的特技效果，才吸引了无数图形学研究者的投入。</p>
                <p>在电影工业中，这项技术早已大放异彩。例如，在《史酷比2》中，那个由一滩黏液构成的怪兽，其形态变化，从手掌变成怪脸，就是典型的3D Morphing应用。而在《变形金刚》系列中，每一个变形过程都经过了艺术家和工程师的精心设计，是3D Morphing技术应用的典范。</p>
                <h3 id="3-%E4%B8%89%E7%BB%B4morphing%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB">3. 三维Morphing技术分类</h3>
                <p>理解了3D Morphing的“是什么”和“为什么”之后，我们来看看“怎么做”。学术界通常将3D Morphing技术分为两大类：</p>
                <ol>
                <li>
                <p><strong>基于表面(Surface-based)的表示</strong>：</p>
                <ul>
                <li>这种方法直接操作物体的表面网格（Mesh），比如我们常见的多面体模型。</li>
                <li>其核心挑战在于两个关键步骤：
                <ul>
                <li><strong>建立顶点对应关系</strong>：找到源模型表面上的点与目标模型表面上的点的一一对应关系。这是最困难的一步，我们称之为“<strong>对应问题</strong>”（Correspondence Problem）。</li>
                <li><strong>顶点插值</strong>：建立了对应关系后，对相应顶点的位置、颜色、法向量等属性进行插值。这相对简单，我们称之为“<strong>插值问题</strong>”（Interpolation Problem）。</li>
                </ul>
                </li>
                <li>一个常见的限制是，这类方法通常要求两个模型具有<strong>拓扑一致性</strong>（比如，都是一个封闭的球面，没有洞），或者需要通过复杂的算法来统一它们的拓扑结构。</li>
                </ul>
                </li>
                <li>
                <p><strong>基于体(Volume-based)的表示</strong>：</p>
                <ul>
                <li>这种方法不关心物体的表面，而是将物体看作是三维空间中的一个“体”，通常用三维体素栅格（Voxel Grid）来表示。</li>
                <li>它首先需要将表面模型（如多边形网格）<strong>体素化</strong>，转换成体表示。这个过程可能会带来信息的损失或失真。</li>
                <li>它的核心思想是<strong>扭曲整个空间</strong>，而不仅仅是物体表面。当空间被扭曲时，嵌入在空间中的物体也随之变形。</li>
                <li>这种方法的计算量通常较大，但优点是能够比较自然地处理拓扑结构完全不同的物体。</li>
                </ul>
                </li>
                </ol>
                <p>接下来，我们将深入这两大类方法，详细探讨它们的原理和数学细节。</p>
                <h3 id="4-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%9F%BA%E4%BA%8E%E8%A1%A8%E9%9D%A2%E7%9A%84morphing%E6%96%B9%E6%B3%95">4. 深入剖析：基于表面的Morphing方法</h4>
                <h4 id="41-%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%90%86%E6%83%B3%E6%83%85%E5%86%B5">4.1 一个最简单的理想情况</h4>
                <p>我们从最理想化的情况开始。假设我们有两个三维模型，比如一个球体和一个易拉罐。如果它们满足两个极为苛刻的条件：</p>
                <ol>
                <li><strong>顶点数量完全相同</strong>。</li>
                <li><strong>拓扑结构完全相同</strong>（即顶点的连接关系，也就是边和面的构成，完全一样）。</li>
                </ol>
                <p>那么，Morphing过程就变得异常简单。我们只需要将源模型 $M_S$ 的第 $i$ 个顶点 $V_{S,i}$ 和目标模型 $M_T$ 的第 $i$ 个顶点 $V_{T,i}$ 配对。</p>
                <p>在时间 $t \in [0, 1]$（其中 $t=0$ 对应源模型，$t=1$ 对应目标模型），任意一个中间模型 $M(t)$ 的顶点 $V_i(t)$ 就可以通过线性插值（Linear Interpolation, Lerp）得到：</p>
                <p>$$V_i(t) = (1-t) \cdot V_{S,i} + t \cdot V_{T,i}$$</p>
                <p>这就是一个最简单的3D Morphing。但现实中，几乎没有任何两个有意义的模型会满足这么严格的条件。因此，我们必须寻找更通用的方法。</p>
                <h4 id="42-%E5%9F%BA%E4%BA%8E%E6%98%9F%E5%BD%A2%E7%89%A9%E4%BD%93%E7%9A%84%E5%A4%9A%E9%9D%A2%E4%BD%93morphing%E6%96%B9%E6%B3%95">4.2 基于星形物体的多面体Morphing方法</h4>
                <p>现在，我们来看一个里程碑式的工作。在1992年，Kent、Carlson和Parent提出了一种针对一类特殊多面体——<strong>星形物体</strong>——的Morphing方法。这是早期解决“对应问题”的一个非常巧妙的方案。</p>
                <p>在深入算法之前，我们必须先统一一些<strong>基本概念</strong>。</p>
                <ul>
                <li><strong>物体 (Object)</strong>: 一个具有三维表面几何的实体。</li>
                <li><strong>形状 (Shape)</strong>: 构成物体表面的点的集合。</li>
                <li><strong>模型 (Model)</strong>: 对物体形状的完整描述，比如一个多边形网格模型。</li>
                <li><strong>拓扑 (Topology)</strong>: 模型的连接结构（顶点、边、面如何连接）。它不关心顶点的具体坐标。</li>
                <li><strong>几何 (Geometry)</strong>: 拓扑结构的一个具体实例（Instance），通过为每个顶点指定坐标得到。</li>
                <li><strong>同构 (Homeomorphic)</strong>: 如果两个物体的表面之间存在一个连续且可逆的一一映射，我们就说它们是同构的或拓扑等价的。一个经典的例子是，一个咖啡杯和一个甜甜圈在拓扑上是等价的，因为它们都有一个“洞”。</li>
                <li><strong>欧拉公式 (Euler's Formula)</strong>: 对于一个封闭的、行为良好的多面体，其顶点数(V)、边数(E)和面数(F)满足一个优美的关系：
                $$V - E + F = 2 - 2G$$
                这里的 $G$ 被称为<strong>亏格 (Genus)</strong>，直观上就是物体表面“洞”的数量。一个球体的亏格 $G=0$，一个甜甜圈（环面）的亏格 $G=1$。满足这个公式的模型我们称之为<strong>欧拉有效</strong>的。</li>
                </ul>
                <p>Kent等人的方法主要针对<strong>亏格为0</strong>的多面体，也就是拓扑上等价于球体的物体。</p>
                <h4 id="%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3">算法核心思想</h4>
                <p>该算法的基本思想，正如我们前面提到的，分为两步：</p>
                <ol>
                <li><strong>建立对应关系 (Correspondence)</strong>：这是难点。</li>
                <li><strong>插值 (Interpolation)</strong>：这相对简单。</li>
                </ol>
                <p>对于两个亏格为0的多面体（比如一个立方体和一个由很多面片构成的球体），它们都同构于一个球面。这给了我们一个绝妙的启发：我们可以把<strong>球面</strong>作为一个“公共参考空间”。</p>
                <p>想象一下，这两个多面体就像两个不同形状的气球。我们可以把它们都“吹”成一个标准的球形。在这个过程中，源物体表面上的任意一个点，都会唯一地映射到球面上。</p>
                <ul>
                <li>如果源物体上的点 $V_1$ 和目标物体上的点 $V_2$ 被映射到了球面上的<strong>同一点</strong>，我们就认为 $V_1$ 和 $V_2$ 是一对<strong>对应点</strong>。</li>
                </ul>
                <p>这就是合并拓扑结构的基本思想。</p>
                <h4 id="%E7%AE%97%E6%B3%95%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4">算法具体步骤</h4>
                <p>这个过程可以被分解为优雅的三步：</p>
                <ol>
                <li><strong>投影 (Projection)</strong>: 将源模型 $M_a$ 和目标模型 $M_b$ 分别投影到一个单位球面上，得到两个球面上的拓扑网络 $(M_a)_p$ 和 $(M_b)_p$。</li>
                <li><strong>合并 (Merge)</strong>: 将这两个球面拓扑网络 $(M_a)_p$ 和 $(M_b)_p$ 合并成一个新的、更精细的拓扑网络 $M_c$。这个新网络包含了前两个网络所有的顶点和边。</li>
                <li><strong>映射回溯 (Map Back)</strong>: 将合并后的拓扑网络 $M_c$ 分别映射回原来的两个物体表面，得到两个<strong>新的模型</strong> $M_a^<em>$ 和 $M_b^</em>$。</li>
                </ol>
                <p>至此，神奇的事情发生了：$M_a^<em>$ 和 $M_b^</em>$ 拥有<strong>完全相同的顶点数和拓扑结构</strong>，同时它们的形状又分别和原始模型 $M_a$ 和 $M_b$ 保持一致。</p>
                <p>现在，问题转化为了我们4.1节中的最简单情况！我们可以直接对 $M_a^<em>$ 和 $M_b^</em>$ 的对应顶点进行线性插值了。</p>
                <p>让我们来逐一拆解这些步骤中的细节。</p>
                <p><strong>Step 1: 投影方法 (Projection)</strong></p>
                <p>投影方法必须满足两个条件：一一对应和连续。对于<strong>星形物体</strong>，存在一种非常直观的投影方法。</p>
                <p><strong>定义：星形物体 (Star-shaped Object)</strong>
                一个物体是星形的，如果其内部至少存在一个点（称为<strong>核点</strong>，Kernel Point），从这个点出发的视线可以无遮挡地看到物体所有的内部顶点。凸体是星形物体的特例。</p>
                <p>投影过程如下：</p>
                <ol>
                <li>在星形物体内部选取一个核点 $O$ (通常是物体的质心)。</li>
                <li>对于物体表面的任意顶点 $V$，构造一条从 $O$ 出发经过 $V$ 的射线 $\vec{OV}$。</li>
                <li>该射线与单位球面的交点，就是顶点 $V$ 在球面上的投影点 $(V)_p$。</li>
                </ol>
                <p>数学上，投影点 $(V)_p$ 的坐标可以表示为：
                $$(V)_p = \frac{V - O}{|V - O|}$$</p>
                <p><strong>Step 2: 拓扑合并算法 (Topology Merging)</strong></p>
                <p>当两个拓扑网络 $(M_a)_p$ 和 $(M_b)_p$ 都被投影到球面上后，我们需要将它们合并。这本质上是一个计算几何中的<strong>图叠加 (Map Overlay)</strong> 问题。</p>
                <ul>
                <li><strong>新的顶点集</strong>: 包含 $(M_a)_p$ 的所有顶点、$(M_b)_p$ 的所有顶点，以及 $(M_a)_p$ 的边与 $(M_b)_p$ 的边所有的<strong>交点</strong>。</li>
                <li><strong>新的边集</strong>: 由上述顶点集切分原始边所形成的<strong>所有小边段</strong>。</li>
                <li><strong>新的面集</strong>: 由新的边集所包围形成的<strong>最小区域</strong>。</li>
                </ul>
                <p>这个过程就像是在一个地球仪上，画上了两个国家的地图，然后生成一个包含所有国界和省界的新地图。</p>
                <p><strong>Step 3: 插值问题 (Interpolation)</strong></p>
                <p>在得到具有相同拓扑的 $M_a^<em>$ 和 $M_b^</em>$ 后，我们对顶点进行插值。除了几何位置，其他属性如颜色、纹理坐标、透明度等也可以被插值。对于这些非几何属性，通常采用<strong>面积坐标 (Barycentric Coordinates)</strong> 来插值。</p>
                <ul>
                <li>假设中间帧模型 $M(t)$ 上的一个点 $P(t)$，它位于某个三角面片上。我们可以计算出它在该面片上的面积坐标 $(\alpha, \beta, \gamma)$，其中 $\alpha+\beta+\gamma=1$。</li>
                <li>使用相同的面积坐标，我们可以在 $M_a^<em>$ 和 $M_b^</em>$ 的对应面片上找到相应的点 $P_a^<em>$ 和 $P_b^</em>$。</li>
                <li>$P_a^<em>$ 和 $P_b^</em>$ 的属性（如颜色 $C_a$ 和 $C_b$）就可以被插值，得到 $P(t)$ 的颜色:
                $$C(t) = (1-t)C_a + t C_b$$</li>
                </ul>
                <p><strong>插值过程中的潜在问题</strong>：</p>
                <ul>
                <li><strong>非共面性</strong>：对于多于三个顶点的面，在插值过程中，这些顶点可能不再位于同一个平面上。一个简单的解决方法是在合并拓扑后，对所有面进行<strong>三角化</strong>。</li>
                <li><strong>自交 (Self-intersection)</strong>：在插值过程中，模型的某些部分可能会相互穿过，导致无效的几何。这是一个非常困难的问题，通常需要更复杂的算法，比如能量最小化方法或体积约束来解决。</li>
                </ul>
                <p>这项经典工作为我们展示了Morphing问题的解决思路，从酒杯到人脸、从字母S到人像的平滑过渡，都证明了其有效性。</p>
                <h3 id="5-%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%8B%93%E5%B1%95%E9%80%9A%E7%94%A8%E7%BD%91%E6%A0%BC%E6%A8%A1%E5%9E%8B%E7%9A%84morphing%E4%B8%8E%E5%8F%82%E6%95%B0%E5%8C%96">5. 进一步拓展：通用网格模型的Morphing与参数化</h3>
                <p>Kent等人的方法非常巧妙，但它依赖于“星形物体”和“亏格为0”这两个前提。如何将其推广到任意复杂的Mesh模型（比如有洞的，或者凹凸非常剧烈的模型）呢？</p>
                <p>答案是引入一个更强大、更通用的数学工具——<strong>参数化 (Parameterization)</strong>。</p>
                <p>参数化，本质上是为三维模型表面上的每一个点，都赋予一个二维的坐标。这就像是把一个不规则的地球仪（3D）展开成一张平整的世界地图（2D）。这个2D的“地图”就是我们的<strong>参数域</strong>。一旦两个不同的3D模型被映射到同一个参数域，我们就可以在这个参数域上建立对应关系。</p>
                <p>常见的参数化方法有：</p>
                <ul>
                <li><strong>球面参数化 (Spherical Parameterization)</strong>: 将亏格为0的模型映射到球面上。</li>
                <li><strong>平面参数化 (Planar Parameterization)</strong>: 将拓扑上像一个磁盘（有边界的开放曲面）的模型映射到一个2D平面上。</li>
                <li><strong>分片参数化 (Patch Parameterization)</strong>: 对于亏格大于0的复杂模型（如有洞），先将其切割成若干个拓扑上的磁盘片，再对每个片进行平面参数化。</li>
                <li><strong>Polycube参数化</strong>: 将模型映射到一个由立方体构成的形状上，常用于生成高质量的四边形网格。</li>
                </ul>
                <h4 id="51-%E7%90%83%E9%9D%A2%E5%8F%82%E6%95%B0%E5%8C%96-spherical-parameterization">5.1 球面参数化 (Spherical Parameterization)</h4>
                <p>对于亏格为0的模型，我们可以使用比之前星形投影更鲁棒的算法将其参数化到球面上。一个著名的策略是<strong>从粗到细的渐进网格 (Progressive Mesh) 参数化</strong>。</p>
                <ul>
                <li><strong>步骤1: 简化</strong>。首先通过一系列“边坍缩”操作，将高精度的输入模型不断简化，最终得到一个非常简单的基础网格（比如一个八面体）。</li>
                <li><strong>步骤2: 参数化基础网格</strong>。将这个最简单的基础网格的顶点直接映射到球面上。</li>
                <li><strong>步骤3: 渐进恢复与优化</strong>。然后，逆向执行简化的过程（称为“顶点分裂”），一步步将模型恢复到原始精度。在每一步恢复（即增加一个顶点）时，我们为新顶点在球面上寻找一个最佳位置，目标是使参数化映射的<strong>失真度最小化</strong>。失真度通常用角度或面积的变化来度量。</li>
                </ul>
                <p>这个过程保证了最终得到的球面映射是<strong>全局无重叠</strong>（bijective）且<strong>失真较小</strong>的。</p>
                <p>一旦我们将马模型和牛模型（或者滴水兽和兔子模型）都参数化到球面上，我们就可以像之前一样，在球面上合并它们的拓扑结构，然后进行插值，实现高质量的Morphing。</p>
                <h4 id="52-%E5%B9%B3%E9%9D%A2%E5%8F%82%E6%95%B0%E5%8C%96-planar-parameterization-%E4%B8%8E%E8%B0%83%E5%92%8C%E6%98%A0%E5%B0%84-harmonic-map">5.2 平面参数化 (Planar Parameterization) 与调和映射 (Harmonic Map)</h4>
                <p>当我们的模型有边界时（比如一个人的脸部模型，不包含后脑勺），我们可以将其参数化到一个2D平面上，通常是一个单位圆盘。<strong>调和映射 (Harmonic Map)</strong> 是一种非常流行且效果很好的方法。</p>
                <p>它的物理模型可以想象成一个由无数个小弹簧连接而成的渔网。我们将渔网的边界固定在一个圆环上，然后让它自然松弛达到一个<strong>能量最低</strong>的平衡状态。这个平衡状态下的渔网形状，就是我们想要的平面参数化结果。</p>
                <p><strong>数学推导</strong></p>
                <ol>
                <li>
                <p><strong>边界固定</strong>: 首先，我们将构成模型边界的 $n$ 个顶点，按顺序固定到单位圆盘的边界上。通常，它们在圆盘上的间隔与它们在3D空间中沿边界的边长成正比。</p>
                </li>
                <li>
                <p><strong>能量函数</strong>: 对于内部的顶点，它们的位置是未知的。我们定义一个总能量函数 $E_{harm}$，它表示所有“弹簧”的弹性能量之和：
                $$E_{harm}(\mathbf{v}) = \frac{1}{2} \sum_{{i,j} \in \text{Edges}(H)} k_{i,j} |v_i - v_j|^2$$</p>
                <ul>
                <li>$\mathbf{v}$ 是所有顶点在2D平面上的位置集合。</li>
                <li>$v_i, v_j$ 是顶点 $i$ 和 $j$ 在2D平面上的坐标。</li>
                <li>$k_{i,j}$ 是连接顶点 $i,j$ 的边的“弹簧系数”。这个系数至关重要，它应该反映3D模型中原始的几何信息。一个常用的选择是<strong>余切权重 (Cotangent Weight)</strong>，它能很好地保持角度，减少映射的变形。</li>
                </ul>
                </li>
                <li>
                <p><strong>能量最小化</strong>: 我们的目标是找到一组内部顶点的位置，使得 $E_{harm}$ 最小。根据变分原理，在最优点，能量函数对每个可移动顶点的梯度（偏导数）都必须为0。
                $\nabla E_{harm} = \mathbf{0}$</p>
                </li>
                <li>
                <p><strong>求解线性系统</strong>: 由于 $E_{harm}$ 是关于顶点坐标 $\mathbf{v}$ 的一个二次型函数，它的梯度是一个线性函数。因此，$\nabla E_{harm} = \mathbf{0}$ 构成了一个大型的<strong>稀疏线性方程组</strong>。
                我们可以将所有顶点的未知坐标 $(v_x, v_y)$ 排列成一个长向量 $\mathbf{V}$。方程组可以写成矩阵形式。更精确地，我们可以把顶点分为<strong>自由部分</strong> $V_\alpha$（内部顶点）和<strong>固定部分</strong> $V_\beta$（边界顶点）。能量函数可以展开为：
                $$E_{harm} = \frac{1}{2} \begin{bmatrix} V_\alpha^T & V_\beta^T \end{bmatrix} \begin{bmatrix} H_{\alpha\alpha} & H_{\alpha\beta} \\ H_{\beta\alpha} & H_{\beta\beta} \end{bmatrix} \begin{bmatrix} V_\alpha \\ V_\beta \end{bmatrix}$$
                我们对自由部分 $V_\alpha$ 求偏导并令其为0：
                $$\frac{\partial E_{harm}}{\partial V_\alpha} = H_{\alpha\alpha}V_\alpha + H_{\alpha\beta}V_\beta = \mathbf{0}$$
                这是一个标准的线性方程组：
                $$H_{\alpha\alpha}V_\alpha = -H_{\alpha\beta}V_\beta$$
                由于 $V_\beta$ 是已知的（我们固定在圆盘边界上），我们可以通过求解这个方程组得到所有内部顶点的位置 $V_\alpha$。</p>
                </li>
                </ol>
                <p>通过这种方法，我们可以得到一个平滑且无重叠的平面参数化结果。这为不同模型间的特征对应提供了坚实的基础。</p>
                <p><strong>C++数据结构示例</strong>
                为了让大家更具体地理解，一个简单的网格数据结构可以这样设计：</p>
                <div class="code-container">
                <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;Eigen/Sparse&gt; // A popular library for linear algebra

// Assuming we have a 3D vector class Vector3
struct Vector3 { float x, y, z; };
// And a 2D vector class Vector2
struct Vector2 { float u, v; };

struct Vertex {
    Vector3 position;    // 3D geometric position
    Vector2 uv;          // 2D parameterization coordinates
    bool is_boundary;    // Flag to identify boundary vertices
};

struct Face {
    // Stores indices of vertices that form this face
    std::vector&lt;int&gt; vertex_indices; 
};

class TriangleMesh {
public:
    std::vector&lt;Vertex&gt; vertices;
    std::vector&lt;Face&gt; faces;

    // Method to compute the harmonic map (planar parameterization)
    void compute_harmonic_map() {
        // 1. Identify boundary vertices and map them to a circle.
        // 2. Build the sparse matrix H_alpha_alpha and the vector -H_alpha_beta * V_beta.
        //    The weights k_ij (e.g., cotangent weights) are computed here.
        // 3. Solve the linear system H_alpha_alpha * V_alpha = b using a sparse solver.
        // 4. Store the resulting 2D coordinates in vertices[i].uv.
    }
};
</code></pre>
                </div>
                <h3 id="6-%E5%8F%A6%E8%BE%9F%E8%B9%8A%E5%BE%84%E5%9F%BA%E4%BA%8E%E4%BD%93%E8%A1%A8%E7%A4%BA%E7%9A%84morphing%E6%96%B9%E6%B3%95">6. 另辟蹊径：基于体表示的Morphing方法</h3>
                <p>现在我们换一个思路，不再纠结于复杂的表面对应问题。让我们进入<strong>基于体(Volume-based)的Morphing</strong>世界。</p>
                <p>这种方法的思想源于二维图像处理中的<strong>场变形 (Field Warping)</strong>。在1995年，Lerios等人将其成功地推广到了三维空间。</p>
                <p><strong>核心思想</strong>：</p>
                <ol>
                <li><strong>几何对齐 (Warping)</strong>: 首先，动画师在源体S和目标体T中指定一些成对的<strong>特征元素</strong>（比如，源物体上人的鼻子尖对应目标物体上怪兽的鼻子尖）。然后，算法会生成一个空间变换（Warping函数），这个变换能将源物体S和目标体T“扭曲”成两个在几何上对齐的中间体S'和T'。</li>
                <li><strong>混合 (Blending)</strong>: 对扭曲后的两个体S'和T'的体素属性（如密度、颜色）进行插值混合，得到最终的中间体。</li>
                </ol>
                <h4 id="61-%E5%87%A0%E4%BD%95%E5%AF%B9%E9%BD%90-geometric-alignment">6.1 几何对齐 (Geometric Alignment)</h4>
                <ul>
                <li><strong>特征元素</strong>: 动画师指定的特征可以是<strong>点对、线对、长方形对、长方体对</strong>。</li>
                <li><strong>局部坐标系</strong>: 每个特征都定义了一个局部坐标系。例如，一个特征线段可以定义原点、一个主轴方向和两个垂直方向。</li>
                <li><strong>空间变换</strong>: Morphing的过程，可以看作是源特征的局部坐标系，平滑地<strong>平移、旋转、缩放</strong>到目标特征的局部坐标系的过程。</li>
                <li><strong>Warping函数计算 (逆向映射)</strong>:
                对于最终要渲染的图像中的每一个像素，我们追溯到它在三维空间中的点 $P'$。我们想知道，这个点 $P'$ 应该从源体S中的哪个点 $P_S$ 采样颜色。
                <ol>
                <li>对于每一个特征对，在时间 $t$ 都有一个插值后的特征 $e'$。</li>
                <li>我们计算 $P'$ 在 $e'$ 局部坐标系下的坐标 $(p_x, p_y, p_z)$。</li>
                <li>我们假设这个<strong>局部坐标是不变的</strong>（这是局部参数化的核心假设）。</li>
                <li>使用相同的局部坐标 $(p_x, p_y, p_z)$，我们在源特征 $e_S$ 的坐标系下，就能计算出对应的源空间点 $P_S$ 的位置。
                $$P_S = \mathbf{c}<em>S + p_x s</em>{Sx} \mathbf{x}<em>S + p_y s</em>{Sy} \mathbf{y}<em>S + p_z s</em>{Sz} \mathbf{z}_S$$
                同样的方法可以找到 $P'$ 在目标体T中对应的点 $P_T$。这样，我们就为空间中的任意点 $P'$ 找到了它在源体和目标体中的“前世今生”。</li>
                </ol>
                </li>
                </ul>
                <h4 id="62-%E5%A4%9A%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86">6.2 多特征处理</h4>
                <p>当存在多对特征时，每个特征对都会为点 $P'$ 计算出一个对应的源点 $P_{S,i}$。最终的对应点 $P_S$ 是这些 $P_{S,i}$ 的<strong>加权平均</strong>：
                $$P_S = \frac{\sum\limits_{i=1}^{n} w_i P_{S,i}}{\sum\limits_{i=1}^{n} w_i}$$</p>
                <ul>
                <li><strong>权重 $w_i$</strong>: 权重的大小取决于点 $P'$ 到第 $i$ 个插值特征 $e'_i$ 的<strong>距离</strong> $d_i$。距离越近，影响越大。通常权重与距离的平方成反比：
                $$w_i = \frac{1}{(d_i + \epsilon)^2}$$
                其中 $\epsilon$ 是一个很小的正数，防止分母为零。距离 $d_i$ 的计算方式取决于特征的类型（点-点距离，点-线段距离，点-长方体距离等）。</li>
                </ul>
                <h4 id="63-%E6%B7%B7%E5%90%88-blending">6.3 混合 (Blending)</h4>
                <p>在计算出扭曲后的体S'和T'之后（实际上我们是通过逆向映射隐式地得到了它们），我们进行混合。</p>
                <ul>
                <li><strong>错误的方法</strong>: 分别对S'和T'进行体绘制（Volume Rendering）得到两张图，再对图像进行淡入淡出。这样做会丢失正确的光照和遮挡关系。</li>
                <li><strong>正确的方法</strong>: 对S'和T'中对应体素的<strong>颜色和不透明度</strong>进行插值，得到一个混合后的新体。然后对这个新体进行体绘制。这样可以得到物理上更真实、效果更好的三维Morphing。</li>
                </ul>
                <p>体积Morphing在处理不同形状和拓扑的物体（如飞镖到飞机，狮子到马）时展现了强大的能力。但它的缺点也很明显：体素化可能引入走样（锯齿），精度不如表面方法；为了高精度需要非常大的体数据，计算开销巨大。</p>
                <h3 id="7-%E5%89%8D%E6%B2%BF%E8%BF%9B%E5%B1%95%E5%9F%BA%E4%BA%8E%E5%8F%98%E5%88%86%E9%9A%90%E5%BC%8F%E6%9B%B2%E9%9D%A2%E7%9A%84morphing">7. 前沿进展：基于变分隐式曲面的Morphing</h3>
                <p>最后，我们来了解一种更为先进和数学上更为优雅的方法，它甚至可以轻松处理<strong>拓扑变化</strong>的Morphing。</p>
                <ul>
                <li><strong>隐式曲面</strong>: 一种不通过顶点和面，而是通过一个函数方程 $f(x, y, z) = 0$ 来定义曲面的方法。曲面就是函数值为0的点的集合。</li>
                <li><strong>隐式曲面Morphing</strong>: 如果源物体和目标物体分别由隐式函数 $f_S=0$ 和 $f_T=0$ 定义，那么一个简单的线性插值函数 $f(t) = (1-t)f_S + t f_T = 0$ 就能描述一个Morphing过程。</li>
                </ul>
                <p>但问题是，如何为任意给定的网格模型找到一个“好”的隐式函数呢？</p>
                <p>在1999年的SIGGRAPH会议上，Turk和O'brien提出了一种惊艳的方法，他们将<strong>N维的Morphing问题转化为了一个N+1维的散乱数据插值问题</strong>。</p>
                <p><strong>核心思想 (以2D Morphing为例)</strong></p>
                <ol>
                <li><strong>提升维度</strong>: 我们要在两个2D形状之间做Morphing。我们构建一个3D空间，把源形状的所有约束放在 $z=0$ 平面上，目标形状的约束放在 $z=1$ 平面上。</li>
                <li><strong>设置约束</strong>:
                <ul>
                <li>在形状的<strong>边界</strong>上，我们指定函数值为0。</li>
                <li>在形状<strong>内部</strong>（沿边界法线向内一小段距离），我们指定函数值为1。</li>
                </ul>
                </li>
                <li><strong>变分插值</strong>: 我们寻找一个3D空间中的函数 $f(x, y, z)$，它必须满足我们设置的所有约束点的值，并且自身要<strong>尽可能光滑</strong>。这个“最光滑”是通过最小化一个能量函数（通常是函数梯度的积分，模拟薄板的弯曲能量）来实现的。这个过程被称为<strong>变分插值</strong>。</li>
                <li><strong>切片得到中间帧</strong>: 求得这个3D隐式函数 $f(x,y,z)$ 后，我们用一个平面 $z=t$（其中 $t \in [0, 1]$）去切割它。切面与 $f=0$ 的交线，就是时间 $t$ 时的中间形状！</li>
                </ol>
                <p><strong>数学工具：径向基函数 (RBF)</strong>
                求解上述变分插值问题，其解可以表示为一种特殊函数——<strong>径向基函数 (Radial Basis Function, RBF)</strong> 的线性组合，再加上一个低阶多项式。
                $$f(\mathbf{x}) = \sum_{j=1}^{n} d_j \phi(|\mathbf{x} - \mathbf{c}_j|) + P(\mathbf{x})$$</p>
                <ul>
                <li>$\mathbf{c}_j$ 是约束点的位置。</li>
                <li>$d_j$ 是未知的权重系数。</li>
                <li>$P(\mathbf{x})$ 是一个低阶多项式（比如线性的 $p_0 + p_1x + p_2y + p_3z$）。</li>
                <li>$\phi(r)$ 是RBF，一个常用的选择是 $\phi(r) = r^2 \log(r)$。</li>
                </ul>
                <p>将所有约束条件 $f(\mathbf{c}_i) = h_i$（$h_i$ 是在约束点上的指定值，0或1）代入上式，我们会得到一个大型的<strong>线性方程组</strong>。解出这个方程组，就得到了所有的未知系数，也就确定了唯一的隐式函数 $f$。</p>
                <p>这种方法相比于简单的基于距离场的隐式曲面，可以生成更光滑的中间结果，能有效避免在变换过程中出现不自然的“挤压”或“尖锐”部分。</p>
                <p>这个方法的精髓在于，它将<strong>形状表示</strong>和<strong>形状插值</strong>统一到了一个框架下。对于3D Morphing，我们就构建一个4D的隐式函数 $f(x,y,z,t)=0$，通过求解4D的RBF插值问题得到。中间帧就是 $t \in [0,1]$ 时的3D“切片”。这种方法可以自然地处理拓扑变化，比如一个完整的物体平滑地分裂成两个。</p>
            </article>
        </main>
    </div>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
</body>
</html>