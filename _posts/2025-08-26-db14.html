<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>数据库系统设计09:恢复系统(Recovery System)</title>
    <link rel="stylesheet" href="../style.css">
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A109%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9Frecovery-system">数据库系统设计09:恢复系统(Recovery System)</h1>
                <p>一个数据库系统，无论其查询优化器多么智能，并发控制协议多么精妙，如果它无法在断电、宕机甚至磁盘损坏后，保证数据的安全和正确，那么它就是一文不值的。<strong>可靠性，是数据库最核心的价值主张。</strong> 而实现这份可靠性的重任，就落在了恢复系统的肩上。</p>
                <p>恢复系统的使命，就是坚定不移地捍主ACID中的两大承诺：</p>
                <ul>
                <li><strong>原子性 (Atomicity):</strong> 保证事务“要么全做，要么全不做”。对于未完成的事务，必须撤销其所有影响。</li>
                <li><strong>持久性 (Durability):</strong> 保证已提交的事务，其结果永不丢失。</li>
                </ul>
                <p>今天，我们将扮演灾难恢复工程师的角色，直面各种可能发生的故障。我们将学习数据库是如何通过一种看似简单却无比强大的工具——<strong>日志 (The Log)</strong>，来记录系统的一举一动，并以此为基础，构建起一套能在任何混乱中重建秩序的恢复算法。我们将重点剖析在现代数据库中被广泛采用的<strong>ARIES</strong>算法，理解其<code>Analysis-Redo-Undo</code>三阶段恢复的精髓。</p>
                <h3 id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%9F%BA%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E6%81%A2%E5%A4%8D%E5%9F%BA%E7%A1%80"><strong>第一部分：基于日志的恢复基础</strong></h3>
                <p>一切恢复技术，都始于日志。日志是数据库的“黑匣子”，它以一种<strong>仅追加 (append-only)</strong> 的方式，忠实地记录了所有对数据库状态产生影响的操作。</p>
                <h4 id="11-%E6%95%85%E9%9A%9C%E7%9A%84%E5%88%86%E7%B1%BB"><strong>1.1 故障的分类</strong></h4>
                <ul>
                <li><strong>事务故障 (Transaction Failure):</strong> 逻辑错误（如除以零）、违反完整性约束、死锁牺牲品等。
                <ul>
                <li><strong>恢复动作:</strong> <strong>中止 (Abort)</strong> 并 <strong>撤销 (Undo)</strong> 该事务的所有修改。</li>
                </ul>
                </li>
                <li><strong>系统崩溃 (System Crash):</strong> 软件错误（OS/DBMS bug）、硬件故障（断电、CPU/内存故障）等。
                <ul>
                <li><strong>假设:</strong> <strong>易失性存储（内存）的内容全部丢失</strong>，但<strong>非易失性存储（磁盘）的内容保持完好</strong>（可能处于一个不一致的状态）。</li>
                <li><strong>恢复动作:</strong> 重启后，<strong>撤销</strong>所有在崩溃时<strong>未提交</strong>的事务，并<strong>重做</strong>所有<strong>已提交</strong>但其修改可能未写入磁盘的事务。</li>
                </ul>
                </li>
                <li><strong>介质故障 (Media Failure):</strong> 磁盘磁头损坏、磁盘控制器故障等，导致部分或全部磁盘数据永久丢失。
                <ul>
                <li><strong>恢复动作:</strong> 从最近的<strong>备份 (Backup/Dump)</strong> 中恢复数据库，然后利用日志<strong>重放 (Replay)</strong> 备份点之后的所有已提交事务。</li>
                </ul>
                </li>
                </ul>
                <h4 id="12-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95-log-records"><strong>1.2 日志记录 (Log Records)</strong></h4>
                <p>日志文件由一系列日志记录构成。每条记录都必须包含足够的信息来支持<code>Undo</code>和<code>Redo</code>。</p>
                <ul>
                <li><strong>$&lt;T_i, \text{start}&gt;$:</strong> 事务$T_i$开始。</li>
                <li><strong>$&lt;T_i, X, V_{old}, V_{new}&gt;$:</strong> 事务$T_i$将数据项$X$的值从$V_{old}$（前像, Before Image）修改为$V_{new}$（后像, After Image）。这是最核心的<strong>更新日志记录</strong>。</li>
                <li><strong>$&lt;T_i, \text{commit}&gt;$:</strong> 事务$T_i$成功提交。</li>
                <li><strong>$&lt;T_i, \text{abort}&gt;$:</strong> 事务$T_i$中止。</li>
                <li><strong><code>&lt;checkpoint&gt;</code>:</strong> 检查点记录（稍后详述）。</li>
                </ul>
                <h4 id="13-%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97%E5%8D%8F%E8%AE%AE-write-ahead-logging-wal"><strong>1.3 预写日志协议 (Write-Ahead Logging, WAL)</strong></h4>
                <p><strong>这是整个恢复系统的第一黄金法则，不可动摇！</strong></p>
                <ul>
                <li>
                <p><strong>规则:</strong></p>
                <ol>
                <li>在将一个被修改的数据页<strong>刷新 (flush)</strong> 到磁盘<strong>之前</strong>，必须<strong>首先</strong>确保与该修改相关的<strong>所有日志记录</strong>（特别是包含$V_{old}$的Undo信息）都已经被写入到<strong>稳定的日志存储</strong>中。</li>
                <li>事务只有在其**<code>&lt;commit&gt;</code>日志记录**被写入稳定日志存储后，才能被认为是已提交。</li>
                </ol>
                </li>
                <li>
                <p><strong>为什么？</strong></p>
                <ul>
                <li><strong>保证原子性:</strong> 如果系统在数据页写入磁盘后、事务提交前崩溃，我们需要利用日志中的$V_{old}$来<code>Undo</code>这个修改。如果日志没先写，<code>Undo</code>信息就丢失了，数据库就永久地处于一个“脏”状态。</li>
                <li><strong>保证持久性:</strong> 当事务提交时，我们只需保证<code>&lt;commit&gt;</code>日志落盘即可向用户确认。即使此时数据页还在内存中，系统崩溃后我们也能通过日志中的$V_{new}$来<code>Redo</code>这个修改，确保其持久性。</li>
                </ul>
                </li>
                </ul>
                <h4 id="14-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%E4%B8%8E%E6%81%A2%E5%A4%8D"><strong>1.4 缓冲区管理策略与恢复</strong></h4>
                <p>恢复系统的设计，与缓冲区管理器如何处理脏页（被修改过的页）密切相关。</p>
                <ul>
                <li><strong>STEAL vs. NO-STEAL:</strong>
                <ul>
                <li><strong>STEAL (窃取):</strong> 允许将<strong>未提交事务</strong>修改过的脏页，在事务提交前就写入磁盘。
                <ul>
                <li><strong>优点:</strong> 内存利用率高，不需要为未提交的事务保留所有脏页。</li>
                <li><strong>缺点:</strong> <strong>需要<code>Undo</code>日志。</strong> 如果系统崩溃，这些被“窃取”出去的脏页必须被回滚。</li>
                </ul>
                </li>
                <li><strong>NO-STEAL (不窃取):</strong> <strong>禁止</strong>将未提交事务修改过的脏页写入磁盘。
                <ul>
                <li><strong>优点:</strong> <strong>不需要<code>Undo</code>日志</strong>，恢复简单。</li>
                <li><strong>缺点:</strong> 严重限制了缓冲池的管理，可能需要为长事务缓存大量脏页。</li>
                </ul>
                </li>
                </ul>
                </li>
                <li><strong>FORCE vs. NO-FORCE:</strong>
                <ul>
                <li><strong>FORCE (强制):</strong> 在事务<strong>提交时</strong>，<strong>强制</strong>将该事务修改过的所有脏页都写入磁盘。
                <ul>
                <li><strong>优点:</strong> <strong>不需要<code>Redo</code>日志。</strong> 提交即意味着数据已落盘。</li>
                <li><strong>缺点:</strong> 提交延迟高，将大量随机I/O集中在提交点。</li>
                </ul>
                </li>
                <li><strong>NO-FORCE (不强制):</strong> 事务提交时，<strong>不要求</strong>立即写入脏页。
                <ul>
                <li><strong>优点:</strong> 提交快，可以将多个事务的脏页批量、异步地写入，优化I/O。</li>
                <li><strong>缺点:</strong> <strong>需要<code>Redo</code>日志。</strong> 如果提交后、脏页写入前崩溃，需要重做。</li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
                <p><strong>现代数据库的选择：</strong> 为了高性能，几乎所有现代数据库都采用 <strong><code>STEAL</code> + <code>NO-FORCE</code></strong> 策略。这意味着，<strong>我们的恢复系统必须同时支持<code>Undo</code>和<code>Redo</code>。</strong></p>
                <h3 id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86aries"><strong>第二部分：ARIES</strong></h3>
                <p>ARIES (Algorithm for Recovery and Isolation Exploiting Semantics) 是IBM Almaden研究中心发明的恢复算法，已成为事实上的工业标准。它优雅地处理了<code>STEAL</code>+<code>NO-FORCE</code>策略带来的所有复杂性。</p>
                <h4 id="21-aries%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><strong>2.1 ARIES的核心思想</strong></h4>
                <ol>
                <li><strong>重复历史 (Repeating History):</strong> 恢复的第一步，是通过<code>Redo</code>将数据库恢复到<strong>崩溃前的瞬间状态</strong>，包括所有未提交事务所做的修改。</li>
                <li><strong>撤销未完成的事务 (Undoing losers):</strong> 在恢复到崩溃前状态后，再统一地<code>Undo</code>那些在崩溃时还未提交的“失败者”事务。</li>
                <li><strong>补偿日志记录 (Compensation Log Records, CLRs):</strong> <code>Undo</code>操作本身也是对数据库的修改，也必须记录日志，这种日志就是CLR。CLR记录了<code>Undo</code>操作，它只需要<code>Redo</code>信息，不需要<code>Undo</code>信息（因为我们从不撤销一个撤销操作）。这能防止在<code>Undo</code>过程中再次崩溃时，系统进行重复的、不必要的<code>Undo</code>。</li>
                </ol>
                <h4 id="22-%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E7%9A%84%E5%B7%A5%E4%BD%9C"><strong>2.2 正常运行期间的工作</strong></h4>
                <ul>
                <li><strong>记录日志:</strong> 任何更新操作都会生成一条$&lt;T_i, X, V_{old}, V_{new}&gt;$日志。</li>
                <li><strong>维护事务表 (Transaction Table):</strong> 内存中，记录所有活动事务的状态、最后一条日志记录的指针等。</li>
                <li><strong>维护脏页表 (Dirty Page Table):</strong> 内存中，记录所有在缓冲池中被修改过（变脏）的页。</li>
                <li><strong>定期执行检查点 (Checkpointing):</strong> 这是为了<strong>缩短恢复时间</strong>的关键机制。</li>
                </ul>
                <p><strong>检查点的作用:</strong>
                如果没有检查点，系统崩溃后，我们需要从<strong>日志的起点</strong>开始扫描，这可能非常耗时。检查点告诉恢复系统：“在这个点之前提交的事务，其数据修改肯定已经写入磁盘了，你不需要再为它们<code>Redo</code>了。”</p>
                <p><strong>模糊检查点 (Fuzzy Checkpoint) 流程:</strong></p>
                <ol>
                <li>开始检查点，写入<code>&lt;checkpoint, start&gt;</code>日志，并暂停接收新的事务。</li>
                <li>将当时的<strong>事务表</strong>和<strong>脏页表</strong>的内容，写入到检查点日志记录中。</li>
                <li>写入<code>&lt;checkpoint, end&gt;</code>日志。</li>
                <li>将检查点日志强制刷盘。</li>
                </ol>
                <ul>
                <li><strong>关键:</strong> 在检查点期间，<strong>事务可以继续执行</strong>，脏页也不需要立即刷盘。这使得检查点对系统性能的影响降到最低。</li>
                </ul>
                <h4 id="23-%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E7%9A%84aries%E4%B8%89%E9%98%B6%E6%AE%B5"><strong>2.3 崩溃恢复的ARIES三阶段</strong></h4>
                <p>当系统从崩溃中重启时，恢复管理器开始执行：</p>
                <h5 id="%E9%98%B6%E6%AE%B5%E4%B8%80%E5%88%86%E6%9E%90-analysis-phase"><strong>阶段一：分析 (Analysis Phase)</strong></h5>
                <ul>
                <li><strong>目标:</strong> 确定在崩溃瞬间，哪些事务是<strong>未完成的 (losers)</strong>，哪些页是<strong>脏的</strong>。</li>
                <li><strong>流程:</strong>
                <ol>
                <li>从最近一个<strong>完整的检查点</strong>开始，<strong>向前</strong>扫描日志直到末尾。</li>
                <li>根据日志记录，重建崩溃瞬间的<strong>事务表</strong>和<strong>脏页表</strong>。
                <ul>
                <li>看到$&lt;T_i, \text{start}&gt;$，将$T_i$加入事务表。</li>
                <li>看到$&lt;T_i, \text{commit/abort}&gt;$，将$T_i$从事务表中移除。</li>
                <li>看到更新日志，如果被修改的页不在脏页表中，则加入。</li>
                </ul>
                </li>
                </ol>
                </li>
                <li><strong>产出:</strong>
                <ul>
                <li>一个<strong>失败者事务列表 (Loser List)</strong>。</li>
                <li>一个需要进行恢复检查的<strong>脏页表</strong>。</li>
                <li><code>Redo</code>阶段需要开始扫描的<strong>最早的日志点</strong>（通常是脏页表中最“老”的那个脏页对应的第一条日志）。</li>
                </ul>
                </li>
                </ul>
                <h5 id="%E9%98%B6%E6%AE%B5%E4%BA%8C%E9%87%8D%E5%81%9A-redo-phase"><strong>阶段二：重做 (Redo Phase)</strong></h5>
                <ul>
                <li><strong>目标:</strong> 将数据库恢复到崩溃前的确切状态，确保所有<strong>已提交</strong>事务的持久性，同时也<strong>恢复未提交事务</strong>的修改。</li>
                <li><strong>流程:</strong>
                <ol>
                <li>从分析阶段确定的<code>Redo</code>起始点开始，<strong>向前</strong>扫描日志直到末尾。</li>
                <li>对于每一条<strong>更新日志记录</strong>或<strong>CLR</strong>:
                a. 检查其修改的数据页P是否在脏页表中。
                b. 如果是，并且日志中的LSN（日志序列号）<strong>大于</strong>磁盘上页面P中记录的LSN，则<strong>无条件地重做 (Redo)</strong> 这个修改（将$V_{new}$写入页），并更新页面的LSN。</li>
                </ol>
                </li>
                <li><strong>幂等性 (Idempotency):</strong> <code>Redo</code>操作是幂等的。即使一个修改已经写入磁盘，再次<code>Redo</code>也不会出错。</li>
                <li><strong>结果:</strong> 此阶段结束后，磁盘状态与崩溃前瞬间的内存状态完全一致。</li>
                </ul>
                <h5 id="%E9%98%B6%E6%AE%B5%E4%B8%89%E6%92%A4%E9%94%80-undo-phase"><strong>阶段三：撤销 (Undo Phase)</strong></h5>
                <ul>
                <li><strong>目标:</strong> 撤销所有在<strong>失败者列表</strong>中的事务。</li>
                <li><strong>流程:</strong>
                <ol>
                <li>从<strong>失败者列表</strong>中所有事务的<strong>最后一条日志记录</strong>开始，<strong>向后</strong>扫描日志。</li>
                <li>对于遇到的每一条属于失败者事务的<strong>普通更新日志</strong>:
                a. 执行<code>Undo</code>操作（将$V_{old}$写回数据项）。
                b. 为这个<code>Undo</code>操作，生成一条<strong>CLR</strong>，并写入日志。
                c. 继续处理该事务的前一条日志记录（通过日志记录中的<code>PrevLSN</code>指针可以快速跳转）。</li>
                <li>当一个失败者事务的所有修改都被<code>Undo</code>后（即处理到它的<code>&lt;start&gt;</code>日志），为它写入一条<code>&lt;abort&gt;</code>日志。</li>
                </ol>
                </li>
                <li><strong>CLR的重要性:</strong> 如果在<code>Undo</code>阶段再次崩溃，重启后，分析阶段会看到这些CLR。在<code>Redo</code>阶段，这些CLR会被重做，确保<code>Undo</code>操作本身是持久的。当再次进入<code>Undo</code>阶段时，系统看到CLR就知道这个<code>Undo</code>已经做过了，会跳过它，继续处理更早的日志，从而避免了重复<code>Undo</code>。</li>
                </ul>
                <h3 id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E4%BB%8B%E8%B4%A8%E6%81%A2%E5%A4%8D"><strong>第三部分：介质恢复</strong></h3>
                <p>WAL和ARIES可以处理事务故障和系统崩溃，但如果<strong>承载日志或数据文件的磁盘本身损坏了</strong>，它们就无能为力了。</p>
                <h4 id="31-%E5%A4%87%E4%BB%BD%E4%B8%8E%E5%BD%92%E6%A1%A3-backup--archiving"><strong>3.1 备份与归档 (Backup &amp; Archiving)</strong></h4>
                <ul>
                <li><strong>全量备份 (Full Dump):</strong> 定期地将整个数据库复制到一个独立的、安全的存储介质（如磁带、云存储）上。</li>
                <li><strong>增量备份 (Incremental Backup):</strong> 只备份自上一次备份以来发生变化的数据。</li>
                <li><strong>日志归档 (Log Archiving):</strong> 日志文件是循环使用的。当一个日志文件被写满后，在重用它之前，必须将其内容<strong>归档</strong>到一个安全的长期存储中。这是实现<strong>时间点恢复 (Point-in-Time Recovery, PITR)</strong> 的基础。</li>
                </ul>
                <h4 id="32-%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B"><strong>3.2 介质故障的恢复流程</strong></h4>
                <ol>
                <li><strong>替换硬件:</strong> 首先，更换损坏的磁盘。</li>
                <li><strong>恢复备份:</strong> 将最近一次的<strong>全量备份</strong>恢复到新磁盘上。</li>
                <li><strong>应用增量备份:</strong> 按顺序应用后续的增量备份。</li>
                <li><strong>前滚日志 (Roll Forward):</strong>
                <ul>
                <li>从备份点开始，获取所有后续的<strong>归档日志</strong>和<strong>当前日志</strong>。</li>
                <li><strong>重放 (Replay)</strong> 这些日志中所有<strong>已提交事务</strong>的**<code>Redo</code>**部分。</li>
                <li>这个过程就像一个长时间的ARIES <code>Redo</code>阶段，将数据库的状态“前滚”到崩溃前的最新时刻。</li>
                </ul>
                </li>
                </ol>
                <h4 id="33-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E6%96%B9%E6%A1%88"><strong>3.3 高可用性方案</strong></h4>
                <p>对于需要7x24小时服务的关键系统，停机进行备份恢复是不可接受的。因此，诞生了各种高可用性技术。</p>
                <ul>
                <li><strong>主从复制 (Master-Slave Replication):</strong>
                <ul>
                <li>所有写操作在主库完成，然后通过<strong>日志流 (Log Shipping)</strong> 或<strong>触发器</strong>等方式，异步或同步地复制到一个或多个从库。</li>
                <li>当主库故障时，可以手动或自动地将一个从库<strong>提升 (Promote)</strong> 为新的主库。</li>
                </ul>
                </li>
                <li><strong>存储冗余 (RAID):</strong> 通过磁盘阵列技术，在硬件层面提供数据冗余，可以容忍单个（或多个）磁盘的物理损坏。</li>
                <li><strong>集群与分布式数据库:</strong> 将数据分布在多个节点上，每个节点都有数据的副本。单个节点的故障不会影响整个系统的可用性。</li>
                </ul>
            </article>
        </main>
    </div>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
</body>
</html>