<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<title>数据库系统设计09:恢复系统(Recovery System)</title>
<link href="../style.css" rel="stylesheet"/>
<link href="../modal.css" rel="stylesheet"/>
<script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" type="text/javascript">
</script>
<!-- Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
<script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
<!-- Highlight.js Themes -->
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/rose-pine-dawn.min.css" id="highlight-theme-link" rel="stylesheet"/>
<!-- Highlight.js Copy Plugin CSS -->
<link href="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.css" rel="stylesheet"/>
</head>
<body>
<audio id="bg-music" loop="" src="../music.mp3"></audio>
<button class="music-control" id="music-toggle">♪</button><button class="dark-mode-control" id="dark-mode-toggle">🌙</button>
<header>
<h1>forliage的blog</h1>
<nav>
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../posts.html">文章</a></li>
<li><a href="../about.html">关于</a></li>
<li><a href="../category.html?category=技术文章">技术文章</a></li>
<li><a href="../category.html?category=生活随笔">生活随笔</a></li>
<li><a href="../category.html?category=学习笔记">学习笔记</a></li>
<li><a href="../category.html?category=心情日记">心情日记</a></li>
<li><a href="#" id="about-me-btn">ABOUT ME</a></li>
</ul>
</nav>
</header>
<div class="container">
<div id="sidebar-container"></div>
<main>
<article>
<h1 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A109%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9Frecovery-system">数据库系统设计09:恢复系统(Recovery System)</h1>
<p>一个数据库系统，无论其查询优化器多么智能，并发控制协议多么精妙，如果它无法在断电、宕机甚至磁盘损坏后，保证数据的安全和正确，那么它就是一文不值的。<strong>可靠性，是数据库最核心的价值主张。</strong> 而实现这份可靠性的重任，就落在了恢复系统的肩上。</p>
<p>恢复系统的使命，就是坚定不移地捍主ACID中的两大承诺：</p>
<ul>
<li><strong>原子性 (Atomicity):</strong> 保证事务“要么全做，要么全不做”。对于未完成的事务，必须撤销其所有影响。</li>
<li><strong>持久性 (Durability):</strong> 保证已提交的事务，其结果永不丢失。</li>
</ul>
<p>今天，我们将扮演灾难恢复工程师的角色，直面各种可能发生的故障。我们将学习数据库是如何通过一种看似简单却无比强大的工具——<strong>日志 (The Log)</strong>，来记录系统的一举一动，并以此为基础，构建起一套能在任何混乱中重建秩序的恢复算法。我们将重点剖析在现代数据库中被广泛采用的<strong>ARIES</strong>算法，理解其<code>Analysis-Redo-Undo</code>三阶段恢复的精髓。</p>
<h3 id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%9F%BA%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E6%81%A2%E5%A4%8D%E5%9F%BA%E7%A1%80"><strong>第一部分：基于日志的恢复基础</strong></h3>
<p>一切恢复技术，都始于日志。日志是数据库的“黑匣子”，它以一种<strong>仅追加 (append-only)</strong> 的方式，忠实地记录了所有对数据库状态产生影响的操作。</p>
<h4 id="11-%E6%95%85%E9%9A%9C%E7%9A%84%E5%88%86%E7%B1%BB"><strong>1.1 故障的分类</strong></h4>
<ul>
<li><strong>事务故障 (Transaction Failure):</strong> 逻辑错误（如除以零）、违反完整性约束、死锁牺牲品等。
                <ul>
<li><strong>恢复动作:</strong> <strong>中止 (Abort)</strong> 并 <strong>撤销 (Undo)</strong> 该事务的所有修改。</li>
</ul>
</li>
<li><strong>系统崩溃 (System Crash):</strong> 软件错误（OS/DBMS bug）、硬件故障（断电、CPU/内存故障）等。
                <ul>
<li><strong>假设:</strong> <strong>易失性存储（内存）的内容全部丢失</strong>，但<strong>非易失性存储（磁盘）的内容保持完好</strong>（可能处于一个不一致的状态）。</li>
<li><strong>恢复动作:</strong> 重启后，<strong>撤销</strong>所有在崩溃时<strong>未提交</strong>的事务，并<strong>重做</strong>所有<strong>已提交</strong>但其修改可能未写入磁盘的事务。</li>
</ul>
</li>
<li><strong>介质故障 (Media Failure):</strong> 磁盘磁头损坏、磁盘控制器故障等，导致部分或全部磁盘数据永久丢失。
                <ul>
<li><strong>恢复动作:</strong> 从最近的<strong>备份 (Backup/Dump)</strong> 中恢复数据库，然后利用日志<strong>重放 (Replay)</strong> 备份点之后的所有已提交事务。</li>
</ul>
</li>
</ul>
<h4 id="12-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95-log-records"><strong>1.2 日志记录 (Log Records)</strong></h4>
<p>日志文件由一系列日志记录构成。每条记录都必须包含足够的信息来支持<code>Undo</code>和<code>Redo</code>。</p>
<ul>
<li><strong>$&lt;T_i, \text{start}&gt;$:</strong> 事务$T_i$开始。</li>
<li><strong>$&lt;T_i, X, V_{old}, V_{new}&gt;$:</strong> 事务$T_i$将数据项$X$的值从$V_{old}$（前像, Before Image）修改为$V_{new}$（后像, After Image）。这是最核心的<strong>更新日志记录</strong>。</li>
<li><strong>$&lt;T_i, \text{commit}&gt;$:</strong> 事务$T_i$成功提交。</li>
<li><strong>$&lt;T_i, \text{abort}&gt;$:</strong> 事务$T_i$中止。</li>
<li><strong><code>&lt;checkpoint&gt;</code>:</strong> 检查点记录（稍后详述）。</li>
</ul>
<h4 id="13-%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97%E5%8D%8F%E8%AE%AE-write-ahead-logging-wal"><strong>1.3 预写日志协议 (Write-Ahead Logging, WAL)</strong></h4>
<p><strong>这是整个恢复系统的第一黄金法则，不可动摇！</strong></p>
<ul>
<li>
<p><strong>规则:</strong></p>
<ol>
<li>在将一个被修改的数据页<strong>刷新 (flush)</strong> 到磁盘<strong>之前</strong>，必须<strong>首先</strong>确保与该修改相关的<strong>所有日志记录</strong>（特别是包含$V_{old}$的Undo信息）都已经被写入到<strong>稳定的日志存储</strong>中。</li>
<li>事务只有在其**<code>&lt;commit&gt;</code>日志记录**被写入稳定日志存储后，才能被认为是已提交。</li>
</ol>
</li>
<li>
<p><strong>为什么？</strong></p>
<ul>
<li><strong>保证原子性:</strong> 如果系统在数据页写入磁盘后、事务提交前崩溃，我们需要利用日志中的$V_{old}$来<code>Undo</code>这个修改。如果日志没先写，<code>Undo</code>信息就丢失了，数据库就永久地处于一个“脏”状态。</li>
<li><strong>保证持久性:</strong> 当事务提交时，我们只需保证<code>&lt;commit&gt;</code>日志落盘即可向用户确认。即使此时数据页还在内存中，系统崩溃后我们也能通过日志中的$V_{new}$来<code>Redo</code>这个修改，确保其持久性。</li>
</ul>
</li>
</ul>
<h4 id="14-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%E4%B8%8E%E6%81%A2%E5%A4%8D"><strong>1.4 缓冲区管理策略与恢复</strong></h4>
<p>恢复系统的设计，与缓冲区管理器如何处理脏页（被修改过的页）密切相关。</p>
<ul>
<li><strong>STEAL vs. NO-STEAL:</strong>
<ul>
<li><strong>STEAL (窃取):</strong> 允许将<strong>未提交事务</strong>修改过的脏页，在事务提交前就写入磁盘。
                <ul>
<li><strong>优点:</strong> 内存利用率高，不需要为未提交的事务保留所有脏页。</li>
<li><strong>缺点:</strong> <strong>需要<code>Undo</code>日志。</strong> 如果系统崩溃，这些被“窃取”出去的脏页必须被回滚。</li>
</ul>
</li>
<li><strong>NO-STEAL (不窃取):</strong> <strong>禁止</strong>将未提交事务修改过的脏页写入磁盘。
                <ul>
<li><strong>优点:</strong> <strong>不需要<code>Undo</code>日志</strong>，恢复简单。</li>
<li><strong>缺点:</strong> 严重限制了缓冲池的管理，可能需要为长事务缓存大量脏页。</li>
</ul>
</li>
</ul>
</li>
<li><strong>FORCE vs. NO-FORCE:</strong>
<ul>
<li><strong>FORCE (强制):</strong> 在事务<strong>提交时</strong>，<strong>强制</strong>将该事务修改过的所有脏页都写入磁盘。
                <ul>
<li><strong>优点:</strong> <strong>不需要<code>Redo</code>日志。</strong> 提交即意味着数据已落盘。</li>
<li><strong>缺点:</strong> 提交延迟高，将大量随机I/O集中在提交点。</li>
</ul>
</li>
<li><strong>NO-FORCE (不强制):</strong> 事务提交时，<strong>不要求</strong>立即写入脏页。
                <ul>
<li><strong>优点:</strong> 提交快，可以将多个事务的脏页批量、异步地写入，优化I/O。</li>
<li><strong>缺点:</strong> <strong>需要<code>Redo</code>日志。</strong> 如果提交后、脏页写入前崩溃，需要重做。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>现代数据库的选择：</strong> 为了高性能，几乎所有现代数据库都采用 <strong><code>STEAL</code> + <code>NO-FORCE</code></strong> 策略。这意味着，<strong>我们的恢复系统必须同时支持<code>Undo</code>和<code>Redo</code>。</strong></p>
<h3 id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86aries"><strong>第二部分：ARIES</strong></h3>
<p>ARIES (Algorithm for Recovery and Isolation Exploiting Semantics) 是IBM Almaden研究中心发明的恢复算法，已成为事实上的工业标准。它优雅地处理了<code>STEAL</code>+<code>NO-FORCE</code>策略带来的所有复杂性。</p>
<h4 id="21-aries%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><strong>2.1 ARIES的核心思想</strong></h4>
<ol>
<li><strong>重复历史 (Repeating History):</strong> 恢复的第一步，是通过<code>Redo</code>将数据库恢复到<strong>崩溃前的瞬间状态</strong>，包括所有未提交事务所做的修改。</li>
<li><strong>撤销未完成的事务 (Undoing losers):</strong> 在恢复到崩溃前状态后，再统一地<code>Undo</code>那些在崩溃时还未提交的“失败者”事务。</li>
<li><strong>补偿日志记录 (Compensation Log Records, CLRs):</strong> <code>Undo</code>操作本身也是对数据库的修改，也必须记录日志，这种日志就是CLR。CLR记录了<code>Undo</code>操作，它只需要<code>Redo</code>信息，不需要<code>Undo</code>信息（因为我们从不撤销一个撤销操作）。这能防止在<code>Undo</code>过程中再次崩溃时，系统进行重复的、不必要的<code>Undo</code>。</li>
</ol>
<h4 id="22-%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E7%9A%84%E5%B7%A5%E4%BD%9C"><strong>2.2 正常运行期间的工作</strong></h4>
<ul>
<li><strong>记录日志:</strong> 任何更新操作都会生成一条$&lt;T_i, X, V_{old}, V_{new}&gt;$日志。</li>
<li><strong>维护事务表 (Transaction Table):</strong> 内存中，记录所有活动事务的状态、最后一条日志记录的指针等。</li>
<li><strong>维护脏页表 (Dirty Page Table):</strong> 内存中，记录所有在缓冲池中被修改过（变脏）的页。</li>
<li><strong>定期执行检查点 (Checkpointing):</strong> 这是为了<strong>缩短恢复时间</strong>的关键机制。</li>
</ul>
<p><strong>检查点的作用:</strong>
                如果没有检查点，系统崩溃后，我们需要从<strong>日志的起点</strong>开始扫描，这可能非常耗时。检查点告诉恢复系统：“在这个点之前提交的事务，其数据修改肯定已经写入磁盘了，你不需要再为它们<code>Redo</code>了。”</p>
<p><strong>模糊检查点 (Fuzzy Checkpoint) 流程:</strong></p>
<ol>
<li>开始检查点，写入<code>&lt;checkpoint, start&gt;</code>日志，并暂停接收新的事务。</li>
<li>将当时的<strong>事务表</strong>和<strong>脏页表</strong>的内容，写入到检查点日志记录中。</li>
<li>写入<code>&lt;checkpoint, end&gt;</code>日志。</li>
<li>将检查点日志强制刷盘。</li>
</ol>
<ul>
<li><strong>关键:</strong> 在检查点期间，<strong>事务可以继续执行</strong>，脏页也不需要立即刷盘。这使得检查点对系统性能的影响降到最低。</li>
</ul>
<h4 id="23-%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E7%9A%84aries%E4%B8%89%E9%98%B6%E6%AE%B5"><strong>2.3 崩溃恢复的ARIES三阶段</strong></h4>
<p>当系统从崩溃中重启时，恢复管理器开始执行：</p>
<h5 id="%E9%98%B6%E6%AE%B5%E4%B8%80%E5%88%86%E6%9E%90-analysis-phase"><strong>阶段一：分析 (Analysis Phase)</strong></h5>
<ul>
<li><strong>目标:</strong> 确定在崩溃瞬间，哪些事务是<strong>未完成的 (losers)</strong>，哪些页是<strong>脏的</strong>。</li>
<li><strong>流程:</strong>
<ol>
<li>从最近一个<strong>完整的检查点</strong>开始，<strong>向前</strong>扫描日志直到末尾。</li>
<li>根据日志记录，重建崩溃瞬间的<strong>事务表</strong>和<strong>脏页表</strong>。
                <ul>
<li>看到$&lt;T_i, \text{start}&gt;$，将$T_i$加入事务表。</li>
<li>看到$&lt;T_i, \text{commit/abort}&gt;$，将$T_i$从事务表中移除。</li>
<li>看到更新日志，如果被修改的页不在脏页表中，则加入。</li>
</ul>
</li>
</ol>
</li>
<li><strong>产出:</strong>
<ul>
<li>一个<strong>失败者事务列表 (Loser List)</strong>。</li>
<li>一个需要进行恢复检查的<strong>脏页表</strong>。</li>
<li><code>Redo</code>阶段需要开始扫描的<strong>最早的日志点</strong>（通常是脏页表中最“老”的那个脏页对应的第一条日志）。</li>
</ul>
</li>
</ul>
<h5 id="%E9%98%B6%E6%AE%B5%E4%BA%8C%E9%87%8D%E5%81%9A-redo-phase"><strong>阶段二：重做 (Redo Phase)</strong></h5>
<ul>
<li><strong>目标:</strong> 将数据库恢复到崩溃前的确切状态，确保所有<strong>已提交</strong>事务的持久性，同时也<strong>恢复未提交事务</strong>的修改。</li>
<li><strong>流程:</strong>
<ol>
<li>从分析阶段确定的<code>Redo</code>起始点开始，<strong>向前</strong>扫描日志直到末尾。</li>
<li>对于每一条<strong>更新日志记录</strong>或<strong>CLR</strong>:
                a. 检查其修改的数据页P是否在脏页表中。
                b. 如果是，并且日志中的LSN（日志序列号）<strong>大于</strong>磁盘上页面P中记录的LSN，则<strong>无条件地重做 (Redo)</strong> 这个修改（将$V_{new}$写入页），并更新页面的LSN。</li>
</ol>
</li>
<li><strong>幂等性 (Idempotency):</strong> <code>Redo</code>操作是幂等的。即使一个修改已经写入磁盘，再次<code>Redo</code>也不会出错。</li>
<li><strong>结果:</strong> 此阶段结束后，磁盘状态与崩溃前瞬间的内存状态完全一致。</li>
</ul>
<h5 id="%E9%98%B6%E6%AE%B5%E4%B8%89%E6%92%A4%E9%94%80-undo-phase"><strong>阶段三：撤销 (Undo Phase)</strong></h5>
<ul>
<li><strong>目标:</strong> 撤销所有在<strong>失败者列表</strong>中的事务。</li>
<li><strong>流程:</strong>
<ol>
<li>从<strong>失败者列表</strong>中所有事务的<strong>最后一条日志记录</strong>开始，<strong>向后</strong>扫描日志。</li>
<li>对于遇到的每一条属于失败者事务的<strong>普通更新日志</strong>:
                a. 执行<code>Undo</code>操作（将$V_{old}$写回数据项）。
                b. 为这个<code>Undo</code>操作，生成一条<strong>CLR</strong>，并写入日志。
                c. 继续处理该事务的前一条日志记录（通过日志记录中的<code>PrevLSN</code>指针可以快速跳转）。</li>
<li>当一个失败者事务的所有修改都被<code>Undo</code>后（即处理到它的<code>&lt;start&gt;</code>日志），为它写入一条<code>&lt;abort&gt;</code>日志。</li>
</ol>
</li>
<li><strong>CLR的重要性:</strong> 如果在<code>Undo</code>阶段再次崩溃，重启后，分析阶段会看到这些CLR。在<code>Redo</code>阶段，这些CLR会被重做，确保<code>Undo</code>操作本身是持久的。当再次进入<code>Undo</code>阶段时，系统看到CLR就知道这个<code>Undo</code>已经做过了，会跳过它，继续处理更早的日志，从而避免了重复<code>Undo</code>。</li>
</ul>
<h3 id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E4%BB%8B%E8%B4%A8%E6%81%A2%E5%A4%8D"><strong>第三部分：介质恢复</strong></h3>
<p>WAL和ARIES可以处理事务故障和系统崩溃，但如果<strong>承载日志或数据文件的磁盘本身损坏了</strong>，它们就无能为力了。</p>
<h4 id="31-%E5%A4%87%E4%BB%BD%E4%B8%8E%E5%BD%92%E6%A1%A3-backup--archiving"><strong>3.1 备份与归档 (Backup &amp; Archiving)</strong></h4>
<ul>
<li><strong>全量备份 (Full Dump):</strong> 定期地将整个数据库复制到一个独立的、安全的存储介质（如磁带、云存储）上。</li>
<li><strong>增量备份 (Incremental Backup):</strong> 只备份自上一次备份以来发生变化的数据。</li>
<li><strong>日志归档 (Log Archiving):</strong> 日志文件是循环使用的。当一个日志文件被写满后，在重用它之前，必须将其内容<strong>归档</strong>到一个安全的长期存储中。这是实现<strong>时间点恢复 (Point-in-Time Recovery, PITR)</strong> 的基础。</li>
</ul>
<h4 id="32-%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B"><strong>3.2 介质故障的恢复流程</strong></h4>
<ol>
<li><strong>替换硬件:</strong> 首先，更换损坏的磁盘。</li>
<li><strong>恢复备份:</strong> 将最近一次的<strong>全量备份</strong>恢复到新磁盘上。</li>
<li><strong>应用增量备份:</strong> 按顺序应用后续的增量备份。</li>
<li><strong>前滚日志 (Roll Forward):</strong>
<ul>
<li>从备份点开始，获取所有后续的<strong>归档日志</strong>和<strong>当前日志</strong>。</li>
<li><strong>重放 (Replay)</strong> 这些日志中所有<strong>已提交事务</strong>的**<code>Redo</code>**部分。</li>
<li>这个过程就像一个长时间的ARIES <code>Redo</code>阶段，将数据库的状态“前滚”到崩溃前的最新时刻。</li>
</ul>
</li>
</ol>
<h4 id="33-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E6%96%B9%E6%A1%88"><strong>3.3 高可用性方案</strong></h4>
<p>对于需要7x24小时服务的关键系统，停机进行备份恢复是不可接受的。因此，诞生了各种高可用性技术。</p>
<ul>
<li><strong>主从复制 (Master-Slave Replication):</strong>
<ul>
<li>所有写操作在主库完成，然后通过<strong>日志流 (Log Shipping)</strong> 或<strong>触发器</strong>等方式，异步或同步地复制到一个或多个从库。</li>
<li>当主库故障时，可以手动或自动地将一个从库<strong>提升 (Promote)</strong> 为新的主库。</li>
</ul>
</li>
<li><strong>存储冗余 (RAID):</strong> 通过磁盘阵列技术，在硬件层面提供数据冗余，可以容忍单个（或多个）磁盘的物理损坏。</li>
<li><strong>集群与分布式数据库:</strong> 将数据分布在多个节点上，每个节点都有数据的副本。单个节点的故障不会影响整个系统的可用性。</li>
</ul>
</article><div class="share-buttons">
<p>分享到：</p>
<a class="share-btn weibo" href="#" onclick="sharePost(event, 'weibo')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Sina Weibo</title><path d="M10.098 20.323c-3.977.391-7.414-1.406-7.672-4.02-.259-2.609 2.759-5.047 6.74-5.441 3.979-.394 7.413 1.404 7.671 4.018.259 2.6-2.759 5.049-6.737 5.439l-.002.004zM9.05 17.219c-.384.616-1.208.884-1.829.602-.612-.279-.793-.991-.406-1.593.379-.595 1.176-.861 1.793-.601.622.263.82.972.442 1.592zm1.27-1.627c-.141.237-.449.353-.689.253-.236-.09-.313-.361-.177-.586.138-.227.436-.346.672-.24.239.09.315.36.18.601l.014-.028zm.176-2.719c-1.893-.493-4.033.45-4.857 2.118-.836 1.704-.026 3.591 1.886 4.21 1.983.64 4.318-.341 5.132-2.179.8-1.793-.201-3.642-2.161-4.149zm7.563-1.224c-.346-.105-.57-.18-.405-.615.375-.977.42-1.804 0-2.404-.781-1.112-2.915-1.053-5.364-.03 0 0-.766.331-.571-.271.376-1.217.315-2.224-.27-2.809-1.338-1.337-4.869.045-7.888 3.08C1.309 10.87 0 13.273 0 15.348c0 3.981 5.099 6.395 10.086 6.395 6.536 0 10.888-3.801 10.888-6.82 0-1.822-1.547-2.854-2.915-3.284v.01zm1.908-5.092c-.766-.856-1.908-1.187-2.96-.962-.436.09-.706.511-.616.932.09.42.511.691.932.602.511-.105 1.067.044 1.442.465.376.421.466.977.316 1.473-.136.406.089.856.51.992.405.119.857-.105.992-.512.33-1.021.12-2.178-.646-3.035l.03.045zm2.418-2.195c-1.576-1.757-3.905-2.419-6.054-1.968-.496.104-.812.587-.706 1.081.104.496.586.813 1.082.707 1.532-.331 3.185.15 4.296 1.383 1.112 1.246 1.429 2.943.947 4.416-.165.48.106 1.007.586 1.157.479.165.991-.104 1.157-.586.675-2.088.241-4.478-1.338-6.235l.03.045z"></path></svg>
<span>微博</span>
</a>
<a class="share-btn twitter" href="#" onclick="sharePost(event, 'twitter')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M21.543 7.104c.015.211.015.423.015.636 0 6.507-4.954 14.01-14.01 14.01v-.003A13.94 13.94 0 0 1 0 19.539a9.88 9.88 0 0 0 7.287-2.041 4.93 4.93 0 0 1-4.6-3.42 4.916 4.916 0 0 0 2.223-.084A4.926 4.926 0 0 1 .96 9.167v-.062a4.887 4.887 0 0 0 2.235.616A4.928 4.928 0 0 1 1.67 3.148 13.98 13.98 0 0 0 11.82 8.292a4.929 4.929 0 0 1 8.39-4.49 9.868 9.868 0 0 0 3.128-1.196 4.941 4.941 0 0 1-2.165 2.724A9.828 9.828 0 0 0 24 4.555a10.019 10.019 0 0 1-2.457 2.549z"></path></svg>
<span>Twitter</span>
</a>
<a class="share-btn linkedin" href="#" onclick="sharePost(event, 'linkedin')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg>
<span>LinkedIn</span>
</a>
<a class="share-btn wechat" href="#" onclick="sharePost(event, 'wechat')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>WeChat</title><path d="M8.691 2.188C3.891 2.188 0 5.476 0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59 0 0 1 .213.665l-.39 1.48c-.019.07-.048.141-.048.213 0 .163.13.295.29.295a.326.326 0 0 0 .167-.054l1.903-1.114a.864.864 0 0 1 .717-.098 10.16 10.16 0 0 0 2.837.403c.276 0 .543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178A1.17 1.17 0 0 1 4.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813 0c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178 1.17 1.17 0 0 1-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826 0 1.622-.12 2.361-.336a.722.722 0 0 1 .598.082l1.584.926a.272.272 0 0 0 .14.047c.134 0 .24-.111.24-.247 0-.06-.023-.12-.038-.177l-.327-1.233a.582.582 0 0 1-.023-.156.49.49 0 0 1 .201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.97-.982zm4.844 0c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.969-.982z"></path></svg>
<span>微信</span>
</a>
<a class="share-btn qq" href="#" onclick="sharePost(event, 'qq')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Tencent QQ</title><path d="M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673"></path></svg>
<span>QQ</span>
</a>
<a class="share-btn facebook" href="#" onclick="sharePost(event, 'facebook')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Facebook</title><path d="M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z"></path></svg>
<span>Facebook</span>
</a>
</div>
<div class="giscus-container" style="margin-top: 50px;">
<script async="" crossorigin="anonymous" data-category="Announcements" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-mapping="pathname" data-reactions-enabled="1" data-repo="forliage/forliage.github.io" data-repo-id="R_kgDONjzd4w" data-strict="0" data-theme="https://forliage.github.io/giscus.css" src="https://giscus.app/client.js">
</script>
</div>


</main>
</div>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
<script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
<script src="../script.js"></script>
<!-- The Modal -->
<div class="modal" id="about-me-modal">
<!-- Modal content -->
<div class="modal-content">
<span class="close-button">×</span>
<h2>About Me</h2>
<p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
<p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
<p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
<p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
<p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
<p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
<hr/>
<h3>订阅我的博客</h3>
<p>订阅功能正在建设中，敬请期待！</p>
</div>
</div>
<script src="../modal.js"></script>
<!-- Highlight.js Core -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- Highlight.js Copy Plugin -->
<script src="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.js"></script>
<!-- Initialize Highlight.js and Copy Plugin -->
<script>
  hljs.highlightAll();
  hljs.addPlugin(new CopyButtonPlugin());
</script>
</body>
</html>