<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<title>数值分析01:有限位数表达、误差传递和收敛性</title>
<link href="../style.css" rel="stylesheet"/>
<link href="../modal.css" rel="stylesheet"/>
<script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" type="text/javascript">
</script>
<!-- Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
<script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
<!-- Highlight.js Themes -->
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/rose-pine-dawn.min.css" id="highlight-theme-link" rel="stylesheet"/>
<!-- Highlight.js Copy Plugin CSS -->
<link href="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.css" rel="stylesheet"/>
</head>
<body>
<audio id="bg-music" loop="" src="../music.mp3"></audio>
<button class="music-control" id="music-toggle">♪</button><button class="dark-mode-control" id="dark-mode-toggle">🌙</button>
<header>
<h1>forliage的blog</h1>
<nav>
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../posts.html">文章</a></li>
<li><a href="../about.html">关于</a></li>
<li><a href="../category.html?category=技术文章">技术文章</a></li>
<li><a href="../category.html?category=生活随笔">生活随笔</a></li>
<li><a href="../category.html?category=学习笔记">学习笔记</a></li>
<li><a href="../category.html?category=心情日记">心情日记</a></li>
<li><a href="#" id="about-me-btn">ABOUT ME</a></li>
</ul>
</nav>
</header>
<div class="container">
<div id="sidebar-container"></div>
<main>
<article>
<h1 id="%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%9001%E6%9C%89%E9%99%90%E4%BD%8D%E6%95%B0%E8%A1%A8%E8%BE%BE%E8%AF%AF%E5%B7%AE%E4%BC%A0%E9%80%92%E5%92%8C%E6%94%B6%E6%95%9B%E6%80%A7">数值分析01:有限位数表达、误差传递和收敛性</h1>
<h3 id="%E5%BC%95%E8%A8%80%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90"><strong>引言：为何需要数值分析？</strong></h3>
<p>当我们试图将数学理论应用于解决复杂的工程、金融或科学问题时，会遇到两个核心挑战：</p>
<ol>
<li><strong>理论上的不可解性：</strong> 许多问题，尽管在理论上存在解，但无法用初等函数表示出来。一个经典的例子就是我们今天将要讨论的积分 $\int_{0}^{1} e^{-x^2} dx$。它的原函数无法用我们熟悉的函数（如多项式、三角函数、指数函数）表示。</li>
<li><strong>实践中的不可行性：</strong> 即使问题有精确的解析解，例如求解一个大型的线性方程组，当维度达到数万甚至数百万时，手动计算或使用解析方法（如克莱姆法则）的计算量是天文数字，完全不现实。</li>
</ol>
<p>这时，<strong>计算机</strong>成为了我们最强大的工具。但计算机有其固有的局限性：</p>
<ul>
<li><strong>离散性 (Discreteness):</strong> 计算机只能处理离散的数据，而数学理论中的变量通常是连续的。</li>
<li><strong>有限性 (Finiteness):</strong> 计算机的内存和存储空间是有限的，它无法表示无限长的数字（如 $\pi$ 或 $\sqrt{2}$），也无法执行无限多次的运算（如无穷级数求和）。</li>
</ul>
<p><strong>数值分析 (Numerical Analysis)</strong> 正是连接<strong>连续的数学理论</strong>与<strong>离散的、有限的计算机</strong>之间的桥梁。它研究如何设计、分析和实现算法，用计算机来近似解决数学问题。</p>
<p>课程的核心，就是围绕着“<strong>近似</strong>”这个词展开。只要有近似，就必然会产生<strong>误差 (Error)</strong>。我们这堂课的目标，就是要理解误差的来源、如何度量它、它如何传播，以及我们如何设计出“好”的算法来控制误差，确保我们得到的近似解是可靠和有意义的。</p>
<p>今天，我们将从最基础也是最核心的三个概念入手：</p>
<ol>
<li><strong>有限位数表达 (Finite-digit Representation):</strong> 计算机是如何表示数字的，这直接导致了<strong>舍入误差</strong>。</li>
<li><strong>误差的产生与传播 (Error Generation and Propagation):</strong> 探讨另一类主要误差——<strong>截断误差</strong>，并分析在计算过程中误差是如何累积和放大的。</li>
<li><strong>算法的稳定性与收敛性 (Algorithm Stability and Convergence):</strong> 衡量一个数值算法好坏的关键标准。</li>
</ol>
<h3 id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E8%AF%AF%E5%B7%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%9D%A5%E6%BA%90"><strong>第一部分：误差的两种主要来源</strong></h3>
<h4 id="11-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E8%BF%91%E4%BC%BC%E8%AE%A1%E7%AE%97%E9%AB%98%E6%96%AF%E7%A7%AF%E5%88%86"><strong>1.1 案例分析：近似计算高斯积分</strong></h4>
<p>考虑一个在统计学和物理学中非常重要的积分，正态分布的概率密度函数就与它有关：</p>
<p><strong>讨论 1: 近似计算 $\int_{0}^{1} e^{-x^2} dx$ 的值。</strong></p>
<p>我们知道这个积分的精确值大约是 $0.746824...$。但正如前面提到的，我们找不到 $e^{-x^2}$ 的初等原函数。那么，我们如何用计算机来计算它呢？</p>
<p><strong>解决方案：</strong> 一个强大的工具是泰勒展开。我们知道 $e^u$ 在 $u=0$ 处的麦克劳林级数是：
                $$e^u = 1 + u + \frac{u^2}{2!} + \frac{u^3}{3!} + \dots = \sum_{k=0}^{\infty} \frac{u^k}{k!}$$</p>
<p>将 $u = -x^2$ 代入，我们得到 $e^{-x^2}$ 的泰勒级数：
                $$e^{-x^2} = 1 - x^2 + \frac{(-x^2)^2}{2!} + \frac{(-x^2)^3}{3!} + \frac{(-x^2)^4}{4!} + \dots$$
                $$e^{-x^2} = 1 - x^2 + \frac{x^4}{2!} - \frac{x^6}{3!} + \frac{x^8}{4!} - \dots = \sum_{k=0}^{\infty} \frac{(-1)^k x^{2k}}{k!}$$</p>
<p>这个级数在整个实数域上收敛。我们可以对这个级数进行逐项积分（因为在收敛域内这是允许的）：</p>
<p>$$\begin{aligned}
                \int_{0}^{1} e^{-x^2} dx &amp;= \int_{0}^{1} \left( 1 - x^2 + \frac{x^4}{2!} - \frac{x^6}{3!} + \frac{x^8}{4!} - \dots \right) dx \\
                &amp;= \left[ x - \frac{x^3}{3} + \frac{x^5}{5 \cdot 2!} - \frac{x^7}{7 \cdot 3!} + \frac{x^9}{9 \cdot 4!} - \dots \right]_{0}^{1} \\
                &amp;= 1 - \frac{1}{3} + \frac{1}{5 \cdot 2!} - \frac{1}{7 \cdot 3!} + \frac{1}{9 \cdot 4!} - \dots \\
                &amp;= 1 - \frac{1}{3} + \frac{1}{10} - \frac{1}{42} + \frac{1}{216} - \dots
                \end{aligned}
                $$</p>
<p>这是一个交错级数。现在，我们面临了计算机的“有限性”挑战：我们不可能计算无穷多项的和。我们必须在某处<strong>截断 (truncate)</strong> 这个级数。</p>
<p>假设我们只取前4项来近似这个积分：
                $$S_4 = 1 - \frac{1}{3} + \frac{1}{10} - \frac{1}{42}$$</p>
<p>这个近似值与真实值之间的差异，就是第一种主要误差。</p>
<h4 id="12-%E6%88%AA%E6%96%AD%E8%AF%AF%E5%B7%AE-truncation-error"><strong>1.2 截断误差 (Truncation Error)</strong></h4>
<p><strong>定义：</strong> 截断误差是由于使用有限的过程（例如，有限项求和、有限步迭代）来近似一个无限过程而产生的误差。它本质上是<strong>数学方法本身的近似</strong>所带来的误差。</p>
<p>在我们的例子中，截断误差就是被我们“扔掉”的尾巴，即余项 $R_4$：
                $$R_4 = \int_{0}^{1} \left( \frac{x^8}{4!} - \frac{x^{10}}{5!} + \dots \right) dx = \frac{1}{9 \cdot 4!} - \frac{1}{11 \cdot 5!} + \dots$$</p>
<p>对于收敛的交错级数，其误差的绝对值小于被截断的第一项的绝对值。因此，我们可以估计截断误差的大小：
                $$|R_4| = \left| \frac{1}{216} - \frac{1}{1320} + \dots \right| &lt; \frac{1}{9 \cdot 4!} = \frac{1}{9 \cdot 24} = \frac{1}{216} \approx 0.0046$$</p>
<p>这意味着，如果我们能精确计算 $S_4$，那么我们的结果与真实值的差距不会超过 $0.0046$。</p>
<p>现在，让我们来计算 $S_4$ 的值：
                $$S_4 = 1 - \frac{1}{3} + \frac{1}{10} - \frac{1}{42}$$</p>
<p>这里就出现了第二种误差。当我们用计算器或计算机计算这些分数时，例如 $\frac{1}{3} = 0.33333...$，我们必须在某个位置进行取舍。</p>
<p>假设我们使用3位小数进行计算：
                $$S_4 \approx 1 - 0.333 + 0.100 - 0.024 = 0.743$$</p>
<p>这个 $0.743$ 与 $S_4$ 的精确值 $1 - \frac{1}{3} + \frac{1}{10} - \frac{1}{42} = \frac{311}{420} \approx 0.74047...$ 之间的差异，就是第二种主要误差。</p>
<h4 id="13-%E8%88%8D%E5%85%A5%E8%AF%AF%E5%B7%AE-roundoff-error"><strong>1.3 舍入误差 (Roundoff Error)</strong></h4>
<p><strong>定义：</strong> 舍入误差是由于计算机使用有限的位数（或数字）来表示实数而产生的误差。它是<strong>计算机硬件的局限性</strong>所带来的误差。</p>
<p>在上面的计算中，将 $\frac{1}{3}$ 表示为 $0.333$，将 $\frac{1}{42}$ 表示为 $0.024$，都引入了舍入误差。这些小的误差在后续的加减运算中会累积起来。</p>
<p><strong>总结一下：</strong></p>
<ul>
<li><strong>截断误差</strong>：我们选择的<strong>数学模型</strong>（用前4项代替无穷级数）与<strong>真实问题</strong>之间的误差。</li>
<li><strong>舍入误差</strong>：我们使用的<strong>计算机表示</strong>（3位小数）与<strong>数学模型中的精确数</strong>（如 $1/3$）之间的误差。</li>
</ul>
<p>总误差是这两者之和（以及它们之间复杂的相互作用）：
                <strong>总误差 = 真实值 - 计算值 = (真实值 - 数学模型) + (数学模型 - 计算值) = 截断误差 + 舍入误差</strong></p>
<p>核心思想：<strong>数值计算中的误差总是由这两种来源共同作用的结果。</strong></p>
<h3 id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%88%8D%E5%85%A5%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90"><strong>第二部分：计算机中的数字表示与舍入误差分析</strong></h3>
<p>为了深入理解舍入误差，我们必须了解计算机是如何存储数字的。</p>
<h4 id="21-%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA%E6%B3%95-floating-point-form"><strong>2.1 浮点表示法 (Floating-Point Form)</strong></h4>
<p>任何一个非零实数 $y$ 都可以表示为<strong>规范化的十进制浮点形式</strong>：
                $$y = \pm 0.d_1d_2...d_k... \times 10^n$$
                其中 $d_1, d_2, ...$ 是 $0$ 到 $9$ 之间的整数，且为了表示的唯一性，我们要求 $d_1 \neq 0$（这被称为<strong>规范化</strong>）。</p>
<ul>
<li>$\pm$ 是<strong>符号 (Sign)</strong>。</li>
<li>$0.d_1d_2...d_k...$ 是<strong>尾数 (Mantissa or Significand)</strong>。</li>
<li>$n$ 是<strong>指数 (Exponent)</strong>。</li>
</ul>
<p>计算机内部存储数字的位数是有限的。一个<strong>k位十进制机器数</strong>指的是尾数只能存储 $k$ 位数字。
                $$\hat{y} = \pm 0.d_1d_2...d_k \times 10^n$$</p>
<p><strong>重要拓展：</strong> 实际的计算机内部使用二进制，遵循 <strong>IEEE 754 标准</strong>。例如，一个64位的<strong>双精度 (double precision)</strong> 浮点数，它分配1位给符号，11位给指数，剩下的52位给尾数。我们这里为了教学方便，使用十进制进行讨论，其原理是完全相通的。</p>
<p>当一个实数 $y = 0.d_1d_2...d_kd_{k+1}... \times 10^n$ 需要被存入一个只能存 $k$ 位尾数的机器时，就必须进行取舍。主要有两种方式：</p>
<p><strong>1. 截断 (Chopping):</strong>
                直接丢掉第 $k+1$ 位以及之后的所有数字。
                $$fl_{chop}(y) = 0.d_1d_2...d_k \times 10^n$$</p>
<p><strong>2. 四舍五入 (Rounding):</strong>
                检查第 $k+1$ 位数字 $d_{k+1}$。</p>
<ul>
<li>如果 $d_{k+1} &lt; 5$，则执行截断。</li>
<li>如果 $d_{k+1} \geq 5$，则在第 $k$ 位上加1（这可能导致进位），然后截断。
                一个巧妙的实现方式是：
                $$fl_{round}(y) = \text{chop}(y + 5 \times 10^{n-(k+1)})$$</li>
</ul>
<p><strong>示例：</strong> 将 $\pi \approx 0.31415926... \times 10^1$ 用5位十进制机器数表示。</p>
<ul>
<li><strong>截断:</strong> $fl_{chop}(\pi) = 0.31415 \times 10^1$</li>
<li><strong>四舍五入:</strong> 第6位是9（$\geq 5$），所以第5位加1。$fl_{round}(\pi) = 0.31416 \times 10^1$。
                显然，四舍五入通常更精确。</li>
</ul>
<h4 id="22-%E8%AF%AF%E5%B7%AE%E7%9A%84%E5%BA%A6%E9%87%8F%E7%BB%9D%E5%AF%B9%E8%AF%AF%E5%B7%AE%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%AF%AF%E5%B7%AE"><strong>2.2 误差的度量：绝对误差与相对误差</strong></h4>
<p>假设 $p$ 是精确值，$p^*$ 是它的近似值。</p>
<p><strong>定义：</strong></p>
<ul>
<li><strong>绝对误差 (Absolute Error):</strong> $E_{abs} = |p - p^*|$</li>
<li><strong>相对误差 (Relative Error):</strong> $E_{rel} = \frac{|p - p^*|}{|p|}$ (要求 $p \neq 0$)</li>
</ul>
<p><strong>为什么相对误差更重要？</strong>
                相对误差是无量纲的，它衡量了误差相对于真实值的大小。</p>
<ul>
<li><strong>例子1：</strong> 测量一张桌子的长度，真实值是1.50米，测量值是1.60米。绝对误差是0.1米，相对误差是 $\frac{0.1}{1.50} \approx 6.7%$。这个误差很显著。</li>
<li><strong>例子2：</strong> 测量地球到月球的距离，真实值约384,400公里，测量值是384,500公里。绝对误差是100公里，非常大！但相对误差是 $\frac{100}{384400} \approx 0.026%$，非常小。</li>
</ul>
<p>相对误差更能反映近似的“质量”。</p>
<h4 id="23-%E8%88%8D%E5%85%A5%E8%AF%AF%E5%B7%AE%E7%9A%84%E7%95%8C"><strong>2.3 舍入误差的界</strong></h4>
<p>我们可以为截断和四舍五入两种方式产生的相对误差给出一个上界。
                设 $y = 0.d_1d_2...d_kd_{k+1}... \times 10^n$。</p>
<p><strong>1. 截断 (Chopping):</strong>
                $$|y - fl_{chop}(y)| = |0.00...0d_{k+1}d_{k+2}... \times 10^n| = 0.d_{k+1}d_{k+2}... \times 10^{n-k}$$
                由于 $0.d_{k+1}d_{k+2}... &lt; 1$，所以 $|y - fl_{chop}(y)| &lt; 1 \times 10^{n-k}$。
                相对误差为：
                $$\frac{|y - fl_{chop}(y)|}{|y|} = \frac{0.d_{k+1}d_{k+2}... \times 10^{n-k}}{|0.d_1d_2... \times 10^n|} = \frac{0.d_{k+1}d_{k+2}...}{0.d_1d_2...} \times 10^{-k}$$
                因为 $y$ 是规范化的，所以 $0.d_1d_2... \ge 0.1$。因此：
                $$E_{rel} \le \frac{1}{0.1} \times 10^{-k} = 10^{-k+1}$$</p>
<p><strong>2. 四舍五入 (Rounding):</strong>
                通过类似分析，无论是向上还是向下取整，误差的绝对值都不会超过“半个单位”。
                $$|y - fl_{round}(y)| \le \frac{1}{2} \times 10^{n-k}$$
                相对误差为：
                $$E_{rel} = \frac{|y - fl_{round}(y)|}{|y|} \le \frac{0.5 \times 10^{n-k}}{|0.d_1d_2... \times 10^n|} \le \frac{0.5}{0.1} \times 10^{-k} = 0.5 \times 10^{-k+1}$$</p>
<p><strong>结论：</strong> 四舍五入的误差上界是截断的一半。这就是为什么在科学计算中，默认的舍入方式几乎总是四舍五入。这个 $10^{-k+1}$ 或 $0.5 \times 10^{-k+1}$ 也被称为<strong>机器精度 (Machine Epsilon)</strong> 的一个度量。</p>
<h4 id="24-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97-significant-digits"><strong>2.4 有效数字 (Significant Digits)</strong></h4>
<p><strong>定义：</strong> 若 $p^*$ 是 $p$ 的近似值，我们说 $p^*$ 对 $p$ 有 $t$ 位有效数字，如果 $t$ 是满足下式的最大非负整数：
                $$\frac{|p - p^*|}{|p|} &lt; 5 \times 10^{-t}$$</p>
<p>这个定义直观地将相对误差与我们熟悉的“有效数字”概念联系起来。例如，如果相对误差小于 $5 \times 10^{-4}$，我们至少可以说这个近似有3位有效数字。</p>
<h3 id="%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E7%81%BE%E9%9A%BE%E6%80%A7%E7%9A%84%E8%88%8D%E5%85%A5%E8%AF%AF%E5%B7%AE%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97%E7%9A%84%E6%8D%9F%E5%A4%B1"><strong>第三部分：灾难性的舍入误差——有效数字的损失</strong></h3>
<p>舍入误差本身通常很小。然而，在某些特定的算术运算中，它会被急剧放大，导致灾难性的后果。</p>
<h4 id="31-%E7%9B%B8%E8%BF%91%E6%95%B0%E7%9B%B8%E5%87%8F"><strong>3.1 相近数相减</strong></h4>
<p><strong>核心问题：</strong> 两个非常接近的数字相减，会导致有效数字的严重损失。</p>
<p><strong>示例:</strong>
                设 $a_1 = 0.12345$ 和 $a_2 = 0.12346$。假设这是两个用5位浮点数精确表示的数字，它们都有5位有效数字。
                计算它们的差：
                $$a_2 - a_1 = 0.12346 - 0.12345 = 0.00001$$
                这个结果可以写成规范化的浮点数 $0.1 \times 10^{-4}$。</p>
<p><strong>发生了什么？</strong>
                原始数字的前4位有效数字 ($1, 2, 3, 4$) 在相减过程中完全抵消了。结果 $0.00001$ 中的前4个0只是占位符，不携带信息。真正有意义的数字只剩下最后一位 ‘1’。我们从两个拥有5位有效信息的数字，得到了一个只拥有1位有效信息的数字。</p>
<p><strong>关键点：</strong> 这不是说减法本身有错，而是如果原始的 $a_1$ 和 $a_2$ 本身就是近似值（例如，它们是经过舍入得到的），那么它们末尾的数字可能是不准确的。
                假设 $a_1$ 的真实值是 $0.123451...$，$a_2$ 的真实值是 $0.123459...$。
                $a_1$ 被舍入为 $0.12345$，$a_2$ 被舍入为 $0.12346$。
                它们的真实差值是 $0.000008...$。
                而我们用近似值计算的差是 $0.00001$。
                相对误差为 $\frac{|0.00001 - 0.000008|}{|0.000008|} = \frac{0.000002}{0.000008} = 25%$！
                一个微小的初始舍入误差，在相近数相减后，被放大了成百上千倍。</p>
<p><strong>记住：</strong> 在数值计算中，要<strong>极力避免两个大小相近的数直接相减</strong>。如果不可避免，通常需要对公式进行代数变形。</p>
<h4 id="32-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E6%B1%82%E8%A7%A3%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B"><strong>3.2 案例研究：求解一元二次方程</strong></h4>
<p>这是一个展示如何避免有效数字损失的经典例子。</p>
<p><strong>研究课题 1: 求解二次方程 $ax^2 + bx + c = 0$。以 $x^2 + 62.10x + 1 = 0$ 为例，假设我们使用4位有效数字的四舍五入算术。</strong></p>
<p>我们都熟悉求根公式：
                $$x_{1,2} = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$</p>
<p>这里，$a=1, b=62.10, c=1$。
                首先计算判别式中的项：</p>
<ul>
<li>$b^2 = (62.10)^2 = 3856.41$。四舍五入到4位，我们得到 $3856$。</li>
<li>$4ac = 4 \times 1 \times 1 = 4$。</li>
<li>$b^2 - 4ac \approx 3856 - 4 = 3852$。</li>
<li>$\sqrt{b^2 - 4ac} \approx \sqrt{3852}$。计算器给出 $62.06448...$。四舍五入到4位，得到 $62.06$。</li>
</ul>
<p>现在，我们计算两个根：
                $$x_1 = \frac{-b + \sqrt{b^2 - 4ac}}{2a} \approx \frac{-62.10 + 62.06}{2} = \frac{-0.04}{2} = -0.0200$$</p>
<p>这里发生了什么？$-62.10$ 和 $62.06$ 是两个非常接近的数！它们的相减导致了严重的有效数字损失。我们得到的 $-0.04$ 很可能是不准确的。</p>
<p>$$x_2 = \frac{-b - \sqrt{b^2 - 4ac}}{2a} \approx \frac{-62.10 - 62.06}{2} = \frac{-124.16}{2} = -62.08$$
                这个计算是两个负数相加，没有相近数相减的问题，所以这个根 $x_2$ 应该是比较准确的。</p>
<p><strong>如何改进？</strong>
                我们的目标是避免计算 $x_1$ 时的相减操作。我们可以利用韦达定理：
                $$x_1 \cdot x_2 = \frac{c}{a}$$</p>
<p><strong>更优的算法：</strong></p>
<ol>
<li>首先，计算符号不会抵消的那个根。当 $b&gt;0$ 时，这是 $x_2$。当 $b&lt;0$ 时，这将是 $x_1$。总之，是分子中加号（或减去一个负数）的那个。
                $x_2 = \frac{-b - \text{sgn}(b)\sqrt{b^2 - 4ac}}{2a} \approx -62.08$ (这里 sgn(b)=+1)</li>
<li>然后，利用韦达定理计算另一个根：
                $x_1 = \frac{c}{a \cdot x_2} \approx \frac{1}{1 \times (-62.08)} = -0.016108...$
                四舍五入到4位，得到 $x_1 \approx -0.01611$。</li>
</ol>
<p><strong>对比结果：</strong></p>
<ul>
<li><strong>传统方法:</strong> $x_1 \approx -0.0200$</li>
<li><strong>改进方法:</strong> $x_1 \approx -0.01611$</li>
<li><strong>精确解 (更高精度计算):</strong> $x_1 \approx -0.0161072...$, $x_2 \approx -62.0839...$</li>
</ul>
<p>可以看到，改进后的算法得到的 $x_1$ 精确得多。这是一个完美的例子，说明<strong>好的数值算法不仅仅是把数学公式直接翻译成代码，而是要预见到并规避数值陷阱。</strong></p>
<h4 id="33-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%80%BC"><strong>3.3 案例研究：多项式求值</strong></h4>
<p><strong>讨论 2: 计算 $f(x) = x^3 - 6.1x^2 + 3.2x + 1.5$ 在 $x=4.71$ 处的值，使用3位数字算术。</strong></p>
<p><strong>精确值：</strong>
                $$
                \begin{aligned}
                f(4.71) &amp;= (4.71)^3 - 6.1(4.71)^2 + 3.2(4.71) + 1.5 \\
                &amp;= 104.487111 - 6.1(22.1841) + 15.072 + 1.5 \\
                &amp;= 104.487111 - 135.32301 + 15.072 + 1.5 = -14.263899
                \end{aligned}
                $$</p>
<p><strong>方法一：直接计算 (使用3位截断算术)</strong></p>
<ol>
<li>$x = 4.71$</li>
<li>$x^2 = (4.71)^2 = 22.1841 \rightarrow 22.1$ (截断)</li>
<li>$x^3 = x \cdot x^2 \approx 4.71 \times 22.1 = 104.091 \rightarrow 104.$</li>
<li>$6.1x^2 \approx 6.1 \times 22.1 = 134.81 \rightarrow 134.$</li>
<li>$3.2x \approx 3.2 \times 4.71 = 15.072 \rightarrow 15.0$</li>
<li>$f(4.71) \approx (104. - 134.) + 15.0 + 1.5 = -30.0 + 15.0 + 1.5 = -13.5$
                <strong>相对误差：</strong> $\frac{|-13.5 - (-14.26)|}{|-14.26|} \approx 5.3%$</li>
</ol>
<p><strong>方法二：秦九韶算法 (Horner's Method)</strong>
                这是评估多项式的一种非常高效且数值稳定的方法。它的思想是嵌套乘法。
                $f(x) = x^3 - 6.1x^2 + 3.2x + 1.5 = ((x - 6.1)x + 3.2)x + 1.5$</p>
<p><strong>使用3位截断算术计算：</strong></p>
<ol>
<li>$x - 6.1 = 4.71 - 6.1 = -1.39$</li>
<li>$(x - 6.1)x \approx -1.39 \times 4.71 = -6.5469 \rightarrow -6.54$</li>
<li>$((x - 6.1)x + 3.2) \approx -6.54 + 3.2 = -3.34$</li>
<li>$f(x) \approx -3.34 \times 4.71 + 1.5 = -15.7314 + 1.5 \rightarrow -15.7 + 1.5 = -14.2$
                <strong>相对误差：</strong> $\frac{|-14.2 - (-14.26)|}{|-14.26|} \approx 0.42%$</li>
</ol>
<p><strong>结论：</strong> 秦九韶算法需要的乘法次数更少（2次 vs 3次），加法/减法次数相同，但最重要的是，它减少了中间步骤的舍入次数，并且避免了计算非常大的数（如 $x^3$）再减去另一个大数，从而有效地控制了舍入误差的累积。</p>
<h3 id="%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><strong>第四部分：算法的稳定性</strong></h3>
<p>我们已经看到，对于同一个问题，不同的算法可能会得到精度迥异的结果。这引出了一个核心概念：<strong>算法的稳定性</strong>。</p>
<h4 id="41-%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89"><strong>4.1 稳定性的定义</strong></h4>
<p><strong>定义：</strong></p>
<ul>
<li>一个算法被称为<strong>稳定的 (Stable)</strong>，如果初始数据的微小改变（例如，由于舍入误差）只导致最终结果的微小改变。</li>
<li>如果初始数据的微小改变会导致最终结果的巨大改变，则称该算法是<strong>不稳定的 (Unstable)</strong>。</li>
<li>如果一个算法只对某些特定的初始数据选择是稳定的，则称其为<strong>条件稳定的 (Conditionally Stable)</strong>。</li>
</ul>
<p><strong>误差的增长方式：</strong>
                假设 $E_0$ 是初始误差， $E_n$ 是经过 $n$ 步运算后的误差。</p>
<ul>
<li><strong>线性增长 (Linear Growth):</strong> 如果 $E_n \approx C \cdot n \cdot E_0$（其中 $C$ 是一个常数），这种增长通常是可接受的。</li>
<li><strong>指数增长 (Exponential Growth):</strong> 如果 $E_n \approx C^n \cdot E_0$（其中 $C &gt; 1$），这种增长是灾难性的，它意味着误差会迅速淹没真实信号。这样的算法是不稳定的。</li>
</ul>
<h4 id="42-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%AA%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95"><strong>4.2 案例研究：一个递推关系的两种算法</strong></h4>
<p><strong>问题：</strong> 计算积分序列 $I_n = \frac{1}{e} \int_{0}^{1} x^n e^x dx$ 对于 $n=0, 1, 2, ...$</p>
<p>首先，我们可以通过分部积分法得到一个递推关系：
                $$I_n = \frac{1}{e} \left[ [x^n e^x]_0^1 - \int_0^1 n x^{n-1} e^x dx \right] = \frac{1}{e} [e - n \cdot e \cdot I_{n-1}] = 1 - n I_{n-1}$$</p>
<p>我们可以计算出 $I_0$：
                $$I_0 = \frac{1}{e} \int_0^1 e^x dx = \frac{1}{e} [e^x]_0^1 = \frac{e-1}{e} = 1 - \frac{1}{e} \approx 0.63212056$$</p>
<p>另外，我们注意到 $x^n$ 在 $[0,1]$ 上是递增的，$e^x$ 也是。所以 $I_n$ 应该是正的，并且随着 $n$ 增大，$x^n$ 在大部分区间更接近0，所以 $I_n$ 应该是递减的。</p>
<p><strong>方法一：正向递推 (Forward Recurrence)</strong>
                使用公式 $I_n = 1 - n I_{n-1}$。
                假设我们使用的 $I_0^*$ 是一个近似值，带有初始误差 $E_0 = I_0 - I_0^*$。</p>
<ul>
<li>$I_1^* = 1 - 1 \cdot I_0^* \approx 0.36787944$</li>
<li>$I_2^* = 1 - 2 \cdot I_1^* \approx 1 - 2(0.36787944) = 0.26424112$
                ...</li>
<li>$I_{10}^* = 1 - 10 \cdot I_9^* \approx 0.08812800$</li>
<li>$I_{11}^* = 1 - 11 \cdot I_{10}^* \approx 0.03059200$</li>
<li>$I_{12}^* = 1 - 12 \cdot I_{11}^* \approx 0.63289600$  <strong>(变大)</strong></li>
<li>$I_{13}^* = 1 - 13 \cdot I_{12}^* \approx -7.2276480$ <strong>(变成负数)</strong></li>
<li>$I_{15}^* \approx -1423.3914$</li>
</ul>
<p>我们来分析误差传播：
                $$E_n = I_n - I_n^* = (1 - n I_{n-1}) - (1 - n I_{n-1}^*) = n(I_{n-1}^* - I_{n-1}) = -n E_{n-1}$$
                所以，$|E_n| = n |E_{n-1}| = n(n-1)|E_{n-2}| = \dots = n!|E_0|$。</p>
<p>误差以<strong>阶乘 (Factorial)</strong> 的速度增长！这比指数增长还要快。任何微小的初始舍入误差 $E_0$ 都会被迅速放大到毁灭性的程度。因此，<strong>正向递推算法是极度不稳定的</strong>。</p>
<p><strong>方法二：反向递推 (Backward Recurrence)</strong>
                我们将递推公式变形： $I_{n-1} = \frac{1 - I_n}{n}$
                这个公式让我们能从 $I_n$ 计算出 $I_{n-1}$。
                我们可以从一个很大的 $N$ 开始，然后往回计算 $I_{N-1}, I_{N-2}, \dots, I_0$。
                但我们需要一个 $I_N$ 的初始值。我们知道 $I_n \to 0$ 当 $n \to \infty$。
                我们可以做一个合理的猜测，例如，取 $N=20$，并假设 $I_{20}^* = 0$。</p>
<p>我们来分析这种方法的误差传播。假设 $I_N$ 的真实值与我们的猜测 $I_N^*$ 之间存在误差 $E_N = I_N - I_N^*$。
                $$E_{N-1} = I_{N-1} - I_{N-1}^* = \frac{1-I_N}{N} - \frac{1-I_N^*}{N} = \frac{I_N^* - I_N}{N} = -\frac{E_N}{N}$$
                $$|E_{N-1}| = \frac{|E_N|}{N}$$
                $$|E_{N-2}| = \frac{|E_{N-1}|}{N-1} = \frac{|E_N|}{N(N-1)}$$
                $$...$$
                $$|E_n| = \frac{|E_N|}{N(N-1)...(n+1)}$$</p>
<p>初始的误差 $E_N$ 在每一步反向递推中都被<strong>除以</strong>一个越来越大的数。误差被迅速地<strong>衰减</strong>了！
                即使我们对 $I_N$ 的初始猜测很不准确（例如，设 $I_{20}^*=0$ 而真实值可能是 $0.01$），这个初始误差在反向计算到 $I_{10}, I_9, ...$ 时，其影响已经小到可以忽略不计。</p>
<p><strong>这就是一个稳定的算法。</strong> 它对初始值的微小（甚至不那么微小）的扰动具有“自我修正”的能力。</p>
<h3 id="%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93"><strong>第五部分：课程总结</strong></h3>
<p><strong>本讲核心要点回顾：</strong></p>
<ol>
<li><strong>误差无处不在：</strong> 数值计算的误差主要来源于<strong>截断误差</strong>（数学方法的近似）和<strong>舍入误差</strong>（计算机有限表示）。</li>
<li><strong>警惕有效数字损失：</strong> <strong>相近数相减</strong>是数值计算中的头号“杀手”，会导致舍入误差的灾难性放大。务必通过代数变形等手段规避它。</li>
<li><strong>算法的选择至关重要：</strong> 同样一个问题，可能有多种数值算法。一个<strong>稳定</strong>的算法能够抑制误差的传播，而一个<strong>不稳定</strong>的算法会使误差失控，导致结果毫无意义。我们通过二次方程求根、多项式求值和递推关系三个案例深刻体会了这一点。</li>
<li><strong>数值分析的思维方式：</strong> 不仅仅是实现数学公式，更是要分析算法的数值特性，特别是它对误差的敏感度。</li>
</ol>
<p><strong>作业预览：Lab 01 - 数值级数求和</strong>
<strong>问题：</strong> 制作一个表格，计算函数 $\psi(x) = \sum_{k=1}^{\infty} \frac{1}{k(k+x)}$ 在 $x = 0.0, 0.1, 0.2, \dots, 300.00$ 共3001个点上的值。要求所有计算结果的<strong>绝对误差小于 $1.0 \times 10^{-10}$</strong>。</p>
<p><strong>思考与挑战：</strong></p>
<ol>
<li>这是一个无穷级数，你必须<strong>截断</strong>它。你需要计算多少项才能保证截断误差小于 $10^{-10}$？</li>
<li>你需要分析余项 $R_N(x) = \sum_{k=N+1}^{\infty} \frac{1}{k(k+x)}$。如何有效地估计这个余项的上界，从而确定需要计算的项数 $N$？</li>
<li>对于不同的 $x$ 值，$N$ 会是相同的吗？</li>
<li>在求和过程中，累加的顺序会影响最终的舍入误差吗？（提示：将一堆小数相加时，从最小的数开始加，通常能得到更精确的结果。）</li>
</ol>
<h4 id="%E8%A7%A3%E7%AD%94%E6%96%B9%E6%A1%88%E6%95%B0%E5%80%BC%E7%BA%A7%E6%95%B0%E6%B1%82%E5%92%8C">解答方案：数值级数求和</h4>
<h5 id="1-%E9%97%AE%E9%A2%98%E9%87%8D%E8%BF%B0%E4%B8%8E%E5%88%86%E6%9E%90"><strong>1. 问题重述与分析</strong></h5>
<p><strong>目标：</strong> 计算函数 $\psi(x) = \sum_{k=1}^{\infty} \frac{1}{k(k+x)}$ 在 $x \in [0.0, 0.1, \dots, 300.00]$ 上的3001个值，并确保每个值的<strong>绝对误差</strong>小于 $\epsilon = 1.0 \times 10^{-10}$。</p>
<p><strong>核心挑战：</strong></p>
<ol>
<li><strong>无穷级数：</strong> 计算机无法进行无穷次运算。我们必须用一个有限和 $S_N(x) = \sum\limits_{k=1}^{N} \frac{1}{k(k+x)}$ 来近似 $\psi(x)$。</li>
<li><strong>截断误差控制：</strong> 我们必须选择一个足够大的 $N$，使得截断误差 $R_N(x) = \psi(x) - S_N(x) = \sum\limits_{k=N+1}^{\infty} \frac{1}{k(k+x)}$ 的绝对值小于给定的容差 $\epsilon$。</li>
<li><strong>计算效率：</strong> 1秒的时间限制意味着我们不能让 $N$ 大到不切实际的程度。</li>
<li><strong>数值稳定性：</strong> 计算过程中需要避免舍入误差的过度累积。</li>
</ol>
<h5 id="2-%E5%88%9D%E6%AD%A5%E5%B0%9D%E8%AF%95%E7%9B%B4%E6%8E%A5%E6%B1%82%E5%92%8C%E6%B3%95%E5%8F%8A%E5%85%B6%E5%B1%80%E9%99%90%E6%80%A7"><strong>2. 初步尝试：直接求和法及其局限性</strong></h5>
<p>最直接的想法是：选择一个足够大的 $N$，然后直接计算 $S_N(x)$。关键在于如何确定 $N$。</p>
<p><strong>截断误差估计：</strong>
                我们需要为 $R_N(x)$ 找一个上界。对于一个正项、单调递减的级数，我们可以使用积分来估计其尾项和：
                $$R_N(x) = \sum_{k=N+1}^{\infty} \frac{1}{k(k+x)} &lt; \int_{N}^{\infty} \frac{1}{t(t+x)} dt$$</p>
<p>这个积分可以通过部分分式分解来求解：
                $\frac{1}{t(t+x)} = \frac{1}{x} \left( \frac{1}{t} - \frac{1}{t+x} \right)$ (假设 $x \neq 0$)</p>
<p>$$
                \begin{aligned}
                \int_{N}^{\infty} \frac{1}{x} \left( \frac{1}{t} - \frac{1}{t+x} \right) dt &amp;= \frac{1}{x} \left[ \ln(t) - \ln(t+x) \right]_{N}^{\infty} \\
                &amp;= \frac{1}{x} \left[ \ln\left(\frac{t}{t+x}\right) \right]_{N}^{\infty} = \frac{1}{x} \left( \ln(1) - \ln\left(\frac{N}{N+x}\right) \right) \\
                &amp;= \frac{1}{x} \ln\left(\frac{N+x}{N}\right) = \frac{1}{x} \ln\left(1 + \frac{x}{N}\right)
                \end{aligned}
                $$</p>
<p>所以，我们必须选择 $N$，使得对于所有 $x \in [0.1, 300.00]$，都满足：
                $$\frac{1}{x} \ln\left(1 + \frac{x}{N}\right) &lt; \epsilon = 10^{-10}$$</p>
<p><strong>分析这个条件：</strong>
                当 $N$ 很大时，$x/N$ 很小，我们可以使用泰勒展开 $\ln(1+u) \approx u$。
                $$R_N(x) &lt; \frac{1}{x} \left( \frac{x}{N} \right) = \frac{1}{N}$$</p>
<p>这意味着，为了满足误差要求，我们需要 $\frac{1}{N} &lt; 10^{-10}$，即 $N &gt; 10^{10}$。</p>
<p><strong>结论：</strong> 直接求和需要计算超过一百亿项！这在1秒内是绝对不可能完成的。<strong>直接求和法不可行。</strong> 这个问题的设计初衷就是为了说明，一个看似简单的方法在数值上可能是灾难性的。</p>
<h5 id="3-%E6%94%B9%E8%BF%9B%E7%AD%96%E7%95%A5%E5%B8%A6%E7%A7%AF%E5%88%86%E4%BF%AE%E6%AD%A3%E7%9A%84%E6%B1%82%E5%92%8C%E6%B3%95"><strong>3. 改进策略：带积分修正的求和法</strong></h5>
<p>既然直接求和收敛太慢，我们可以换一个思路：只对级数的前一部分（例如 $N$ 项）进行直接求和，而用更精确的积分值来<strong>近似</strong>级数的尾部。</p>
<p><strong>新近似公式：</strong>
                $$\psi(x) \approx S_N(x) + \int_{N}^{\infty} \frac{1}{t(t+x)} dt$$
                $$\psi(x) \approx \sum_{k=1}^{N} \frac{1}{k(k+x)} + \frac{1}{x} \ln\left(1 + \frac{x}{N}\right)$$</p>
<p><strong>新方法的误差分析：</strong>
                现在，这个新方法的误差是级数尾项和积分尾项的差：
                $$E_{new} = \left| R_N(x) - \int_{N}^{\infty} \frac{1}{t(t+x)} dt \right| = \left| \sum_{k=N+1}^{\infty} f(k) - \int_{N}^{\infty} f(t) dt \right|$$
                其中 $f(t) = \frac{1}{t(t+x)}$。</p>
<p>根据<strong>欧拉-麦克劳林公式 (Euler-Maclaurin formula)</strong> 的第一项，这个误差可以被很好地近似：
                $$E_{new} \approx \frac{1}{2} f(N) = \frac{1}{2N(N+x)}$$</p>
<p>为了得到一个不依赖于 $x$ 的、适用于所有情况的 $N$，我们取其上界：
                $$E_{new} &lt; \frac{1}{2N(N+0)} = \frac{1}{2N^2}$$</p>
<p>现在，我们用这个新的误差界来确定 $N$：
                $$\frac{1}{2N^2} &lt; \epsilon = 10^{-10}$$
                $$\Longleftrightarrow N^2 &gt; \frac{1}{2 \times 10^{-10}} = 0.5 \times 10^{10}$$
                $$\Longleftrightarrow N &gt; \sqrt{0.5 \times 10^{10}} \approx 70710.67$$</p>
<p><strong>结论：</strong> 我们可以选择一个固定的、稍大一点的整数，例如 $N=71000$ 或者更保险的 $N=100000$。这个计算量（十万次循环）对于现代计算机来说是瞬时完成的。这个方法是可行的。</p>
<h5 id="4-%E6%9C%80%E7%BB%88%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><strong>4. 最终算法设计</strong></h5>
<p><strong>特殊情况处理：</strong></p>
<ul>
<li><strong>当 $x = 0.0$ 时：</strong>
                $$\psi(0) = \sum_{k=1}^{\infty} \frac{1}{k^2}$$
                这是一个著名的级数，称为巴塞尔问题，其和为 $\frac{\pi^2}{6}$。这是一个解析解，可以直接使用高精度的 $\pi$ 值计算，误差远小于 $\epsilon$。</li>
<li><strong>当 $x \to 0$ 时：</strong>
                修正项 $\frac{1}{x} \ln(1 + \frac{x}{N})$ 会变成 $\frac{0}{0}$ 型，直接计算会导致严重的舍入误差。我们需要使用泰勒展开：
                $$\frac{1}{x} \ln\left(1 + \frac{x}{N}\right) = \frac{1}{x} \left( \frac{x}{N} - \frac{1}{2}\left(\frac{x}{N}\right)^2 + O(x^3) \right) = \frac{1}{N} - \frac{x}{2N^2} + \dots$$
                当 $x$ 非常小（例如小于 $10^{-8}$）时，应该使用这个展开式来计算修正项，以避免相消误差。</li>
</ul>
<p><strong>算法步骤：</strong></p>
<ol>
<li>
<p><strong>设定参数：</strong></p>
<ul>
<li>容差 $\epsilon = 1.0 \times 10^{-10}$。</li>
<li>根据误差分析，确定求和项数 $N = 100000$。</li>
<li>预先计算并存储高精度的 $\pi^2/6$ 值。</li>
</ul>
</li>
<li>
<p><strong>主循环：</strong>
                遍历 $x$ 从 $0.0$ 到 $300.00$，步长为 $0.1$。</p>
<ul>
<li><strong>IF $x = 0.0$:</strong>
                结果就是预计算的 $\pi^2/6$。</li>
<li><strong>ELSE ($x &gt; 0$):</strong>
                a.  <strong>初始化有限和</strong> $S_N = 0.0$。
                b.  <strong>计算有限和：</strong>
<code>FOR k FROM 1 TO N:</code>
<code>   S_N = S_N + 1.0 / (k * (k + x))</code>
<em>(注意: 使用浮点数运算，例如 1.0)</em>
                c.  <strong>计算积分修正项 $C_N(x)$:</strong>
<code>IF x &lt; 1.0e-8:</code> (阈值选择)
                <code>   C_N = 1.0/N - x/(2.0*N*N)</code>
<code>ELSE:</code>
<code>   C_N = (1.0/x) * log(1.0 + x/N)</code>
                d.  <strong>计算最终结果：</strong>
<code>psi_x = S_N + C_N</code>
                e.  <strong>输出或存储</strong> $x$ 和 <code>psi_x</code>。</li>
</ul>
</li>
<li>
<p><strong>结束。</strong></p>
</li>
</ol>
<h5 id="5-%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><strong>5. 伪代码实现</strong></h5>
<div class="code-container">
<pre class="hljs"><code><div>PROCEDURE Solve_Lab_01:
    CONSTANT N = 100000
    CONSTANT PI = 3.141592653589793
    psi_at_zero = PI*PI / 6.0

    // Print header for the table
    PRINT "x", "psi(x)"

    // Loop through all required x values
    FOR x_val FROM 0.0 TO 300.0 STEP 0.1:
        IF abs(x_val) &lt; 1.0e-12: // Check for x=0 safely
            result = psi_at_zero
        ELSE:
            // Part 1: Direct Summation
            sum_part = 0.0
            FOR k FROM 1 TO N:
                sum_part = sum_part + 1.0 / (k * (k + x_val))
            
            // Part 2: Integral Correction Term
            correction_part = 0.0
            IF x_val &lt; 1.0e-8: // Use Taylor expansion for small x
                correction_part = (1.0 / N) - (x_val / (2.0 * N * N))
            ELSE: // Use direct formula for other x
                correction_part = (1.0 / x_val) * log(1.0 + x_val / N)
            
            result = sum_part + correction_part
        
        PRINT x_val, result
    END FOR
END PROCEDURE
</div></code></pre>
</div>
<h5 id="6-%E6%80%BB%E7%BB%93"><strong>6. 总结</strong></h5>
<p>这个问题的解决方案完美地体现了数值分析的核心思想：</p>
<ul>
<li><strong>分析先行：</strong> 在编写任何代码之前，必须进行严格的数学分析，以理解算法的收敛性和误差特性。</li>
<li><strong>避免蛮力：</strong> 直接的、显而易见的方法往往在数值上是低效或不稳定的。</li>
<li><strong>组合方法：</strong> 将离散的求和与连续的积分思想结合起来，可以创造出收敛速度快得多的新算法。</li>
<li><strong>关注细节：</strong> 必须处理好特殊情况和潜在的数值陷阱，如 $x=0$ 的情况和 $x \to 0$ 时可能出现的舍入误差。</li>
</ul>
</article><div class="share-buttons">
<p>分享到：</p>
<a class="share-btn weibo" href="#" onclick="sharePost(event, 'weibo')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Sina Weibo</title><path d="M10.098 20.323c-3.977.391-7.414-1.406-7.672-4.02-.259-2.609 2.759-5.047 6.74-5.441 3.979-.394 7.413 1.404 7.671 4.018.259 2.6-2.759 5.049-6.737 5.439l-.002.004zM9.05 17.219c-.384.616-1.208.884-1.829.602-.612-.279-.793-.991-.406-1.593.379-.595 1.176-.861 1.793-.601.622.263.82.972.442 1.592zm1.27-1.627c-.141.237-.449.353-.689.253-.236-.09-.313-.361-.177-.586.138-.227.436-.346.672-.24.239.09.315.36.18.601l.014-.028zm.176-2.719c-1.893-.493-4.033.45-4.857 2.118-.836 1.704-.026 3.591 1.886 4.21 1.983.64 4.318-.341 5.132-2.179.8-1.793-.201-3.642-2.161-4.149zm7.563-1.224c-.346-.105-.57-.18-.405-.615.375-.977.42-1.804 0-2.404-.781-1.112-2.915-1.053-5.364-.03 0 0-.766.331-.571-.271.376-1.217.315-2.224-.27-2.809-1.338-1.337-4.869.045-7.888 3.08C1.309 10.87 0 13.273 0 15.348c0 3.981 5.099 6.395 10.086 6.395 6.536 0 10.888-3.801 10.888-6.82 0-1.822-1.547-2.854-2.915-3.284v.01zm1.908-5.092c-.766-.856-1.908-1.187-2.96-.962-.436.09-.706.511-.616.932.09.42.511.691.932.602.511-.105 1.067.044 1.442.465.376.421.466.977.316 1.473-.136.406.089.856.51.992.405.119.857-.105.992-.512.33-1.021.12-2.178-.646-3.035l.03.045zm2.418-2.195c-1.576-1.757-3.905-2.419-6.054-1.968-.496.104-.812.587-.706 1.081.104.496.586.813 1.082.707 1.532-.331 3.185.15 4.296 1.383 1.112 1.246 1.429 2.943.947 4.416-.165.48.106 1.007.586 1.157.479.165.991-.104 1.157-.586.675-2.088.241-4.478-1.338-6.235l.03.045z"></path></svg>
<span>微博</span>
</a>
<a class="share-btn twitter" href="#" onclick="sharePost(event, 'twitter')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M21.543 7.104c.015.211.015.423.015.636 0 6.507-4.954 14.01-14.01 14.01v-.003A13.94 13.94 0 0 1 0 19.539a9.88 9.88 0 0 0 7.287-2.041 4.93 4.93 0 0 1-4.6-3.42 4.916 4.916 0 0 0 2.223-.084A4.926 4.926 0 0 1 .96 9.167v-.062a4.887 4.887 0 0 0 2.235.616A4.928 4.928 0 0 1 1.67 3.148 13.98 13.98 0 0 0 11.82 8.292a4.929 4.929 0 0 1 8.39-4.49 9.868 9.868 0 0 0 3.128-1.196 4.941 4.941 0 0 1-2.165 2.724A9.828 9.828 0 0 0 24 4.555a10.019 10.019 0 0 1-2.457 2.549z"></path></svg>
<span>Twitter</span>
</a>
<a class="share-btn linkedin" href="#" onclick="sharePost(event, 'linkedin')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg>
<span>LinkedIn</span>
</a>
<a class="share-btn wechat" href="#" onclick="sharePost(event, 'wechat')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>WeChat</title><path d="M8.691 2.188C3.891 2.188 0 5.476 0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59 0 0 1 .213.665l-.39 1.48c-.019.07-.048.141-.048.213 0 .163.13.295.29.295a.326.326 0 0 0 .167-.054l1.903-1.114a.864.864 0 0 1 .717-.098 10.16 10.16 0 0 0 2.837.403c.276 0 .543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178A1.17 1.17 0 0 1 4.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813 0c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178 1.17 1.17 0 0 1-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826 0 1.622-.12 2.361-.336a.722.722 0 0 1 .598.082l1.584.926a.272.272 0 0 0 .14.047c.134 0 .24-.111.24-.247 0-.06-.023-.12-.038-.177l-.327-1.233a.582.582 0 0 1-.023-.156.49.49 0 0 1 .201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.97-.982zm4.844 0c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.969-.982z"></path></svg>
<span>微信</span>
</a>
<a class="share-btn qq" href="#" onclick="sharePost(event, 'qq')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Tencent QQ</title><path d="M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673"></path></svg>
<span>QQ</span>
</a>
<a class="share-btn facebook" href="#" onclick="sharePost(event, 'facebook')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Facebook</title><path d="M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z"></path></svg>
<span>Facebook</span>
</a>
</div>
<div class="giscus-container" style="margin-top: 50px;">
<script async="" crossorigin="anonymous" data-category="Announcements" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-mapping="pathname" data-reactions-enabled="1" data-repo="forliage/forliage.github.io" data-repo-id="R_kgDONjzd4w" data-strict="0" data-theme="https://forliage.github.io/giscus.css" src="https://giscus.app/client.js">
</script>
</div>


</main>
</div>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
<script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
<div class="dock">
  <a href="https://forliage.github.io/index.html">🏠</a>
  <a href="https://forliage.github.io/posts.html">📚</a>
  <a href="https://forliage.github.io/about.html">👤</a>
</div>
<script src="../script.js"></script>
<!-- The Modal -->
<div class="modal" id="about-me-modal">
<!-- Modal content -->
<div class="modal-content">
<span class="close-button">×</span>
<h2>About Me</h2>
<p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
<p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
<p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
<p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
<p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
<p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
<hr/>
<h3>订阅我的博客</h3>
<p>订阅功能正在建设中，敬请期待！</p>
</div>
</div>
<script src="../modal.js"></script><script src="../trail.js"></script>
<!-- Highlight.js Core -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- Highlight.js Copy Plugin -->
<script src="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.js"></script>
<!-- Initialize Highlight.js and Copy Plugin -->
<script>
  hljs.highlightAll();
  hljs.addPlugin(new CopyButtonPlugin());
</script>
</body>
</html>