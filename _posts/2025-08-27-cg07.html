<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>计算机图形学07:三维视图管线</title>
    <link rel="stylesheet" href="../style.css">
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A607%E4%B8%89%E7%BB%B4%E8%A7%86%E5%9B%BE%E7%AE%A1%E7%BA%BF">计算机图形学07:三维视图管线</h1>
                <h3 id="%E5%BC%95%E8%A8%80%E4%BB%8E3d%E4%B8%96%E7%95%8C%E5%88%B02d%E5%B1%8F%E5%B9%95"><strong>引言：从3D世界到2D屏幕</strong></h3>
                <p>我们的最终目标非常明确：<strong>将一个用三维坐标描述的世界，显示在一个二维的像素屏幕上</strong>。这个从3D到2D的降维过程，是整个图形学中最核心、最精妙的部分。它不仅仅是简单地丢弃一个坐标轴，而是要模拟真实世界中人眼或相机的成像原理，创造出具有深度和真实感的视觉体验。</p>
                <p>整个过程可以被看作是一条<strong>流水线 (Pipeline)</strong>，三维顶点数据从一端进入，经过一系列连续的坐标系变换，最终在另一端输出为二维屏幕上的像素颜色。理解这条流水线，就等于掌握了从模型到图像的完整路径。</p>
                <h3 id="1-%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2%E4%B8%8E%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2"><strong>1. 模型变换与视图变换</strong></h3>
                <p>让我们先理清两个容易混淆的概念：<strong>模型变换 (Modeling Transformation)</strong> 和 <strong>视图变换 (Viewing Transformation)</strong>。</p>
                <ul>
                <li><strong>模型变换：</strong> 我们上一讲学习的内容。它回答的是“<strong>物体在世界中的哪个位置？</strong>”。它将物体从自身的<strong>局部坐标系</strong>（或称模型坐标系）变换到统一的<strong>世界坐标系</strong>中。这一步是在搭建场景。</li>
                <li><strong>视图变换：</strong> 今天的新内容。它回答的是“<strong>我们（相机）站在哪里，朝哪里看？</strong>”。它将整个世界（包括所有物体）从<strong>世界坐标系</strong>变换到<strong>相机坐标系</strong>（或称观察坐标系、视觉坐标系）。这一步是在确定拍摄机位。</li>
                </ul>
                <p><strong>相机类比法</strong> 是理解视图变换最直观的方式：</p>
                <ol>
                <li><strong>确定相机位置 (Eye/Camera Position):</strong> 相机在世界中的 $(x, y, z)$ 坐标。</li>
                <li><strong>确定拍摄目标 (Look-At Point):</strong> 相机镜头对准的点。</li>
                <li><strong>确定相机“头顶”朝向 (Up Vector):</strong> 定义相机的旋转，防止画面歪斜。通常我们会指定一个大致的“向上”的向量（如(0,1,0)），系统会自动计算出与视线垂直的精确相机顶部方向。</li>
                </ol>
                <p>在数学上，视图变换构建了一个以相机为原点的新坐标系，通常称为**(u, v, n)**坐标系。然后计算一个变换矩阵，将世界坐标系中的所有顶点都转换到这个新的相机坐标系下。通常，我们习惯让相机看向 <strong>-Z</strong> 轴方向，这在后续的深度测试等操作中会带来便利。</p>
                <p>在OpenGL中，<code>gluLookAt(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ)</code> 这个函数就为我们封装了这一整个复杂的过程，自动计算并应用视图变换矩阵。</p>
                <h3 id="2-%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2"><strong>2. 投影变换</strong></h3>
                <p>当所有物体都转换到相机坐标系下之后，我们就进入了整个流程中最关键的一步：<strong>投影 (Projection)</strong>。投影变换定义了我们能<strong>看见什么</strong>以及<strong>如何看见</strong>。</p>
                <p>投影变换的核心任务，是将一个三维的<strong>视景体 (View Volume)</strong> 内的物体，“压扁”到一个二维的**投影平面 (Projection Plane)**上。</p>
                <p>我们主要有两种投影方式：</p>
                <h4 id="21-%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1-orthographic-projection"><strong>2.1 正交投影 (Orthographic Projection)</strong></h4>
                <ul>
                <li><strong>原理：</strong> 投影线相互平行，且垂直于投影平面。可以想象成将物体直接“拍平”到屏幕上。</li>
                <li><strong>视景体：</strong> 一个长方体（Cuboid）。</li>
                <li><strong>特点：</strong>
                <ul>
                <li><strong>没有远近感：</strong> 物体的大小不会随着距离的远近而改变。</li>
                <li><strong>保留平行线和角度：</strong> 适用于工程制图、建筑蓝图、2.5D游戏等需要精确测量和展示的场合。</li>
                </ul>
                </li>
                <li><strong>OpenGL实现：</strong> <code>glOrtho(left, right, bottom, top, near, far)</code>，这六个参数定义了长方体视景体的六个面。</li>
                </ul>
                <h4 id="22-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1-perspective-projection"><strong>2.2 透视投影 (Perspective Projection)</strong></h4>
                <ul>
                <li><strong>原理：</strong> 所有投影线都汇聚于一点——<strong>视点 (Center of Projection)</strong>，即相机的位置。这完全模拟了人眼的成像原理。</li>
                <li><strong>视景体：</strong> 一个被远近两个平面截断的四棱锥，称为<strong>视锥体 (Frustum)</strong>。</li>
                <li><strong>特点：</strong>
                <ul>
                <li><strong>近大远小：</strong> 距离相机越远的物体，在屏幕上看起来越小，产生强烈的深度感。</li>
                <li><strong>透视收缩 (Foreshortening):</strong> 平行线在远处会汇聚于<strong>灭点 (Vanishing Point)</strong>。这是艺术和现实世界中的基本视觉规律。</li>
                </ul>
                </li>
                <li><strong>OpenGL实现：</strong>
                <ul>
                <li><code>glFrustum(left, right, bottom, top, near, far)</code>: 直接定义视锥体的六个面，功能强大但不直观。</li>
                <li><code>gluPerspective(fovy, aspect, near, far)</code>: 更常用、更符合人类直觉的方式。
                <ul>
                <li><code>fovy</code>: 垂直方向的<strong>视野角度 (Field of View)</strong>，决定了镜头的“广角”程度。</li>
                <li><code>aspect</code>: 视口的<strong>宽高比 (Aspect Ratio)</strong>，即 <code>width / height</code>。</li>
                <li><code>near</code>, <code>far</code>: <strong>近、远裁剪面</strong>的距离。</li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
                <p><strong>投影的数学本质</strong>
                无论是正交投影还是透视投影，其背后都是一个<strong>投影矩阵</strong>。这个矩阵会将视景体内的所有顶点，变换到一个统一的、规则的立方体空间中，这个空间称为<strong>规范化观察体 (Canonical View Volume, CVV)</strong> 或<strong>裁剪空间 (Clip Space)</strong>。CVV通常是一个从-1到+1的立方体。</p>
                <p>透视投影的矩阵会产生一个奇妙的效果：它会将原来的视锥体“扭曲”成一个长方体。这个扭曲的过程，正是通过齐次坐标的<code>w</code>分量和后续的<strong>透视除法</strong>实现的，从而产生了“近大远小”的效果。</p>
                <h3 id="3-%E8%A3%81%E5%89%AA"><strong>3. 裁剪</strong></h3>
                <p>投影变换完成后，所有顶点都进入了裁剪空间。现在，判断一个物体是否在视野内就变得异常简单：</p>
                <ul>
                <li>一个顶点 $(x, y, z)$ 在CVV内，当且仅当：
                $-1 \le x \le 1$
                $-1 \le y \le 1$
                $-1 \le z \le 1$</li>
                </ul>
                <p>任何不满足这个条件的图元，都会被<strong>裁剪 (Clipping)</strong> 算法处理，部分或全部被丢弃。</p>
                <h3 id="4-%E8%A7%86%E5%8F%A3%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A0%87%E5%87%86%E7%94%BB%E5%B8%83%E5%88%B0%E4%BD%A0%E7%9A%84%E5%B1%8F%E5%B9%95"><strong>4. 视口变换：从标准画布到你的屏幕</strong></h3>
                <p>经过裁剪后，我们剩下的所有几何体都位于一个从-1到+1的标准立方体中。最后一步，就是<strong>视口变换 (Viewport Transformation)</strong>。</p>
                <ul>
                <li><strong>目的：</strong> 将这个标准化的、与设备无关的CVV坐标，映射到你屏幕上指定的像素区域——<strong>视口 (Viewport)</strong>。</li>
                <li><strong>过程：</strong> 本质上是一个简单的线性缩放和平移操作，将 x 和 y 坐标从 <code>[-1, 1]</code> 范围映射到 <code>[x, x+width]</code> 和 <code>[y, y+height]</code> 的像素范围。</li>
                <li><strong>OpenGL实现：</strong> <code>glViewport(x, y, width, height)</code>，其中(x,y)是视口左下角的像素坐标，width和height是视口的像素尺寸。</li>
                </ul>
                <h3 id="5-%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A7%86%E5%9B%BE%E7%AE%A1%E7%BA%BF%E6%80%BB%E7%BB%93"><strong>5. 完整的视图管线总结</strong></h3>
                <p>现在，我们可以串联起整个流程，形成一个完整的从3D模型到2D图像的经典视图管线：</p>
                <ol>
                <li>
                <p><strong>模型变换 (Modeling Transformation):</strong></p>
                <ul>
                <li><code>模型坐标系</code> -&gt; <code>世界坐标系</code></li>
                <li>目的：在世界中摆放物体。</li>
                </ul>
                </li>
                <li>
                <p><strong>视图变换 (Viewing Transformation):</strong></p>
                <ul>
                <li><code>世界坐标系</code> -&gt; <code>相机坐标系</code></li>
                <li>目的：确定相机位置和朝向。</li>
                <li><em>(在OpenGL中，模型和视图变换通常合并为 <strong>模型视图矩阵 (Model-View Matrix)</strong>)</em></li>
                </ul>
                </li>
                <li>
                <p><strong>投影变换 (Projection Transformation):</strong></p>
                <ul>
                <li><code>相机坐标系</code> -&gt; <code>裁剪空间 (CVV)</code></li>
                <li>目的：定义视景体，进行降维。</li>
                </ul>
                </li>
                <li>
                <p><strong>裁剪 (Clipping):</strong></p>
                <ul>
                <li>在<code>裁剪空间</code>中，丢弃视景体外的几何体。</li>
                </ul>
                </li>
                <li>
                <p><strong>透视除法 (Perspective Division):</strong></p>
                <ul>
                <li><code>裁剪空间</code> -&gt; <code>规范化设备坐标 (NDC)</code></li>
                <li>将坐标除以w分量，完成透视效果。</li>
                </ul>
                </li>
                <li>
                <p><strong>视口变换 (Viewport Transformation):</strong></p>
                <ul>
                <li><code>NDC</code> -&gt; <code>屏幕坐标系 (像素)</code></li>
                <li>目的：将最终图像映射到屏幕窗口的指定区域。</li>
                </ul>
                </li>
                </ol>
            </article>
        </main>
    </div>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
</body>
</html>