<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<title>x86汇编05-1:指令结构与数据传送指令</title>
<link href="../style.css" rel="stylesheet"/>
<link href="../modal.css" rel="stylesheet"/>
<script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" type="text/javascript">
</script>
<!-- Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
<script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
<!-- Highlight.js Themes -->
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/rose-pine-dawn.min.css" id="highlight-theme-link" rel="stylesheet"/>
<!-- Highlight.js Copy Plugin CSS -->
<link href="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.css" rel="stylesheet"/>
</head>
<body>
<audio id="bg-music" loop="" src="../music.mp3"></audio>
<button class="music-control" id="music-toggle">♪</button><button class="dark-mode-control" id="dark-mode-toggle">🌙</button>
<button id="style-toggle-btn" title="切换控件样式">🎨</button>
<header>
<h1>forliage的blog</h1>
<nav>
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../posts.html">文章</a></li>
<li><a href="../about.html">关于</a></li>
<li><a href="../category.html?category=技术文章">技术文章</a></li>
<li><a href="../category.html?category=生活随笔">生活随笔</a></li>
<li><a href="../category.html?category=学习笔记">学习笔记</a></li>
<li><a href="../category.html?category=心情日记">心情日记</a></li>
<li><a href="#" id="about-me-btn">ABOUT ME</a></li>
</ul>
</nav>
</header>
<div class="container">
<div id="sidebar-container"></div>
<main>
<article>
<h1 id="x86%E6%B1%87%E7%BC%9605-1%E6%8C%87%E4%BB%A4%E7%BB%93%E6%9E%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">x86汇编05-1:指令结构与数据传送指令</h1>
<h3 id="1-%E6%8C%87%E4%BB%A4%E7%BB%93%E6%9E%84-instruction-structure"><strong>1 指令结构 (Instruction Structure)</strong></h3>
<p>在我们逐一学习指令之前，先要理解一条x86指令在源代码层面是如何构成的。这是一个通用的范式，适用于我们后续学习的所有指令。</p>
<p><strong>通用格式：</strong>
<code>[Prefixes] Mnemonic [Operand1], [Operand2] ; Comment</code></p>
<ul>
<li><strong><code>Mnemonic</code> (助记符)</strong>: 这是指令的核心，是一个易于记忆的英文缩写，代表了指令的功能。例如 <code>MOV</code> (Move), <code>ADD</code> (Add), <code>JMP</code> (Jump)。它是指令的“谓语”。</li>
<li><strong><code>Operands</code> (操作数)</strong>: 这是指令操作的对象，是指令的“宾语”或“主语”。一条指令可以有零、一、二或（极少数情况下）三个操作数。操作数可以是以下三种类型：
                <ol>
<li><strong>立即数 (Immediate)</strong>: 直接写在指令中的常数值。例如 <code>MOV AX, 1234h</code> 中的 <code>1234h</code>。</li>
<li><strong>寄存器 (Register)</strong>: CPU内部的寄存器。例如 <code>MOV AX, BX</code> 中的 <code>AX</code> 和 <code>BX</code>。</li>
<li><strong>内存 (Memory)</strong>: 内存地址中的数据。例如 <code>MOV AX, [myVar]</code> 或 <code>MOV AX, [BX+SI]</code>。</li>
</ol>
</li>
<li><strong><code>Prefixes</code> (前缀)</strong>: 这是可选的特殊字节，放在指令机器码的前面，用于修饰或改变指令的行为。例如我们之前讲过的段覆盖前缀 <code>ES:</code>，或者用于重复执行字符串操作的 <code>REP</code> 前缀。我们后续会深入讲解。</li>
</ul>
<p><strong>x86指令集的设计哲学——CISC的体现</strong>
                x86是一种典型的<strong>复杂指令集计算机 (CISC)</strong> 架构。其核心设计思想是：<strong>让硬件（CPU）承担更多的工作，从而让软件（编译器/程序员）更轻松</strong>。这一点在操作数的组合上体现得淋漓尽致。</p>
<p>一条 <code>MOV</code> 指令，其操作数的组合可以非常灵活：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>dest</code> (Operand1)</th>
<th style="text-align:center"><code>src</code> (Operand2)</th>
<th style="text-align:center">合法性</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Register</td>
<td style="text-align:center">Register</td>
<td style="text-align:center">√</td>
<td><code>MOV AX, BX</code></td>
</tr>
<tr>
<td style="text-align:center">Register</td>
<td style="text-align:center">Memory</td>
<td style="text-align:center">√</td>
<td><code>MOV AX, [myVar]</code></td>
</tr>
<tr>
<td style="text-align:center">Register</td>
<td style="text-align:center">Immediate</td>
<td style="text-align:center">√</td>
<td><code>MOV AX, 100</code></td>
</tr>
<tr>
<td style="text-align:center">Memory</td>
<td style="text-align:center">Register</td>
<td style="text-align:center">√</td>
<td><code>MOV [myVar], AX</code></td>
</tr>
<tr>
<td style="text-align:center">Memory</td>
<td style="text-align:center">Immediate</td>
<td style="text-align:center">√</td>
<td><code>MOV [myVar], 100</code></td>
</tr>
<tr>
<td style="text-align:center">Memory</td>
<td style="text-align:center">Memory</td>
<td style="text-align:center">×</td>
<td><code>MOV [var1], [var2]</code></td>
</tr>
</tbody>
</table>
<p>请大家特别注意最后一条：<strong>x86架构的绝大多数指令，都不允许两个操作数同时是内存地址</strong>。</p>
<ul>
<li><strong>CPU/架构层面的原因</strong>: CPU内部的数据通路设计通常只包含一条到内存控制器的主总线。如果允许<code>mem, mem</code>操作，CPU要么需要设计两条独立的内存访问总线（这会使芯片设计极其复杂和昂貴），要么需要内部的微码（microcode）将这条指令分解为 <code>MOV reg, [mem2]</code> -&gt; <code>MOV [mem1], reg</code> 两条微指令，并需要一个内部临时寄存器来周转。Intel的设计者为了在复杂性和性能之间取得平衡，在指令集层面禁止了这种操作，强制程序员（或编译器）显式地使用寄存器进行中转。这反映了CISC架构内部也存在类似RISC（精简指令集）的设计考量。</li>
</ul>
<h3 id="2-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4-data-transfer-instructions"><strong>2 数据传送指令 (Data Transfer Instructions)</strong></h3>
<p>这类指令的共同特点是：它们只负责移动数据，<strong>通常不会改变标志寄存器中的算术标志位</strong>（如CF, ZF, SF, OF）。</p>
<h4 id="21-%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><strong>2.1 通用数据传送指令</strong></h4>
<p>这是最核心、最频繁使用的一组指令。</p>
<h5 id="211-mov-dest-src-move"><strong>2.1.1 <code>mov dest, src</code> (Move)</strong></h5>
<ul>
<li><strong>高级描述</strong>: 将<code>src</code>操作数的值<strong>复制</strong>到<code>dest</code>操作数。<code>MOV</code>这个词其实有点误导，它的行为是“复制”（Copy），而不是“移动”（Move），源操作数<code>src</code>的值并不会被销毁。</li>
<li><strong>CPU/架构层面</strong>: 这是CPU最基本的操作之一。
                <ul>
<li><code>MOV reg, reg</code>: 数据在CPU内部的寄存器文件（Register File）之间流动，不访问外部总线，速度极快。</li>
<li><code>MOV reg, imm</code>: 立即数被编码在指令的机器码中，CPU在取指阶段就获得了这个数据，然后直接送入目标寄存器。</li>
<li><code>MOV reg, mem</code>: CPU通过地址总线发送内存地址，通过控制总线发送读信号，然后等待数据从数据总线返回，存入目标寄存器。</li>
<li><code>MOV mem, reg</code>: CPU发送地址和写信号，同时将寄存器的值放到数据总线上，写入内存。</li>
</ul>
</li>
<li><strong>系统层面</strong>: 这是实现一切变量赋值、参数传递、数据初始化的基础。高级语言中的 <code>a = b;</code> <code>x = 10;</code> 等语句，最终都会被编译成一条或几条<code>MOV</code>指令。</li>
<li><strong>例子</strong>:<pre class="hljs"><code><div>.DATA
                    myWord DW 1234h
                .CODE
                    ; 寄存器到寄存器
                    MOV AX, 1       ; AX = 0001h
                    MOV BX, AX      ; BX = 0001h (AX的值不变)

                    ; 立即数到寄存器
                    MOV CX, 0FFh    ; CX = 00FFh

                    ; 内存到寄存器
                    MOV DX, [myWord]; DX = 1234h (从myWord地址读取数据)

                    ; 寄存器到内存
                    MOV [myWord], CX; myWord在内存中的值现在变为00FFh

                    ; 立即数到内存
                    MOV WORD PTR [myWord+2], 5678h ; 将立即数写入myWord后面的字
                </div></code></pre>
</li>
<li><strong>特别注意</strong>:
                <ol>
<li><code>dest</code>和<code>src</code>的操作数宽度必须一致。<code>MOV AX, BL</code> (16位 vs 8位) 是非法的。</li>
<li>段寄存器<code>CS</code>不能作为<code>MOV</code>指令的目标操作数。这是硬件层面的保护机制，防止程序意外地修改代码段指针，导致执行流崩溃。<code>CS</code>只能通过<code>JMP</code>, <code>CALL</code>等流程控制指令来改变。</li>
<li><code>MOV</code>指令不能直接在两个段寄存器之间传送数据（如<code>MOV DS, ES</code>是非法的），必须通过一个通用寄存器中转。</li>
</ol>
</li>
</ul>
<h5 id="212-push-op-push-onto-stack"><strong>2.1.2 <code>push op</code> (Push onto Stack)</strong></h5>
<ul>
<li><strong>高级描述</strong>: 将操作数<code>op</code>压入堆栈。</li>
<li><strong>CPU/架构层面</strong>: <code>push</code>是一条复合指令，CPU内部的微码会将其分解为两个微操作：
                <ol>
<li><strong>递减堆栈指针</strong>: <code>SP = SP - operand_size</code> (16位模式下减2，32位模式下减4)。堆栈在x86中是向<strong>低地址</strong>方向增长的。</li>
<li><strong>存入数据</strong>: <code>MOV [SS:SP], op</code>。将操作数存放在新的栈顶位置。
                这两个操作是<strong>原子</strong>的，不可被中断，保证了堆栈操作的完整性。</li>
</ol>
</li>
<li><strong>系统层面</strong>: 这是实现函数/过程调用的基石。
                <ul>
<li><strong>传递参数</strong>: 在调用函数前，将参数<code>push</code>到栈上。</li>
<li><strong>保存返回地址</strong>: <code>CALL</code>指令会自动<code>push</code>下一条指令的地址。</li>
<li><strong>保存寄存器</strong>: 在函数开头，<code>push</code>需要使用的寄存器，以保护调用者的上下文；在函数结尾，再<code>pop</code>回来。</li>
</ul>
</li>
<li><strong>例子</strong>:<pre class="hljs"><code><div>; 假设初始时 SS=2000h, SP=1000h
                MOV AX, 1122h
                MOV BX, 3344h

                PUSH AX         ; 1. SP = 1000h - 2 = 0FFEh
                                ; 2. 内存[2000:0FFE] = 1122h
                                ; 现在 SP = 0FFEh

                PUSH BX         ; 1. SP = 0FFEh - 2 = 0FFCh
                                ; 2. 内存[2000:0FFC] = 3344h
                                ; 现在 SP = 0FFCh
                </div></code></pre>
                此时栈顶是<code>3344h</code>。</li>
</ul>
<h5 id="213-pop-op-pop-from-stack"><strong>2.1.3 <code>pop op</code> (Pop from Stack)</strong></h5>
<ul>
<li><strong>高级描述</strong>: 从堆栈顶部弹出一个数据到操作数<code>op</code>。</li>
<li><strong>CPU/架构层面</strong>: 与<code>push</code>相反，<code>pop</code>的微操作是：
                <ol>
<li><strong>读取数据</strong>: <code>MOV op, [SS:SP]</code>。从当前栈顶位置取出数据。</li>
<li><strong>递增堆栈指针</strong>: <code>SP = SP + operand_size</code>。</li>
</ol>
</li>
<li><strong>系统层面</strong>: 与<code>push</code>配对使用，用于恢复寄存器、获取函数返回值（某些调用约定）、清理栈上的参数。</li>
<li><strong>例子</strong>: (紧接上例)<pre class="hljs"><code><div>; 当前 SP = 0FFCh, 栈顶是 3344h
                POP DX          ; 1. DX = 内存[2000:0FFC] = 3344h
                                ; 2. SP = 0FFCh + 2 = 0FFEh
                                ; 现在 DX = 3344h, SP = 0FFEh

                POP CX          ; 1. CX = 内存[2000:0FFE] = 1122h
                                ; 2. SP = 0FFEh + 2 = 1000h
                                ; 现在 CX = 1122h, SP恢复到初始值1000h
                </div></code></pre>
</li>
<li><strong>特别注意</strong>: <code>PUSH</code>和<code>POP</code>的顺序必须相反，数量必须相等，否则会导致堆栈不平衡，当函数返回(<code>RET</code>)时，会取到一个错误的返回地址，引发程序崩溃。这是最常见的汇编编程错误之一。</li>
</ul>
<h5 id="214-xchg-op1-op2-exchange"><strong>2.1.4 <code>xchg op1, op2</code> (Exchange)</strong></h5>
<ul>
<li><strong>高级描述</strong>: 交换两个操作数的值。</li>
<li><strong>CPU/架构层面</strong>:
                <ul>
<li><code>XCHG reg, reg</code>: CPU内部可以不通过总线，直接在寄存器文件内部完成交换，效率非常高。</li>
<li><code>XCHG reg, mem</code>: 这会被CPU分解为三次内存/寄存器之间的数据移动，但<code>XCHG</code>指令保证了这个操作的原子性（如果配合<code>LOCK</code>前缀），这在多线程编程中至关重要。</li>
</ul>
</li>
<li><strong>设计哲学</strong>: 为什么不直接用三条<code>MOV</code>指令和一个临时寄存器来交换？
                <ol>
<li><strong>简洁</strong>: 一条指令更清晰。</li>
<li><strong>高效</strong>: <code>XCHG</code>的机器码编码通常比三条<code>MOV</code>更短。对于<code>reg, reg</code>的情况，执行速度也更快。</li>
<li><strong>原子性</strong>: <code>LOCK XCHG</code>是实现互斥锁（Mutex）和自旋锁（Spinlock）等同步原语的关键指令。</li>
</ol>
</li>
<li><strong>有趣的事实</strong>: <code>XCHG AX, AX</code> (或 <code>EAX, EAX</code>) 的机器码是 <code>0x90</code>，这恰好是 <code>NOP</code> (No Operation) 指令的编码。调试器经常用 <code>0x90</code> 来替换代码以设置断点。</li>
<li><strong>例子</strong>:<pre class="hljs"><code><div>MOV AX, 1111h
                MOV BX, 2222h
                ; AX=1111h, BX=2222h
                XCHG AX, BX
                ; 现在 AX=2222h, BX=1111h

                .DATA
                    myVar DW 3333h
                .CODE
                    XCHG AX, [myVar] ; AX=3333h, myVar在内存中的值变为2222h
                </div></code></pre>
</li>
</ul>
<h4 id="22-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4-in-out"><strong>2.2 输入输出指令 (<code>IN</code>, <code>OUT</code>)</strong></h4>
<p>我们已在第四讲介绍过，这里再次系统性地讲解。</p>
<h5 id="6221-in-alax-port--6222-out-port-alax"><strong>6.2.2.1 <code>in al/ax, port</code></strong> &amp; <strong>6.2.2.2 <code>out port, al/ax</code></strong></h5>
<ul>
<li><strong>高级描述</strong>: 在累加器 (<code>AL</code>或<code>AX</code>) 和 I/O 端口之间传送数据。</li>
<li><strong>CPU/架构层面</strong>: 这两条指令会驱动CPU的控制总线产生特殊的I/O读/写信号，而不是内存读/写信号。这会激活I/O地址空间，而不是主内存。硬件设计上，累加器被固定为操作数之一，简化了指令译码逻辑。<code>port</code>地址如果是0-255，可以是立即数；如果是256-65535，则必须先加载到<code>DX</code>寄存器中。</li>
<li><strong>系统层面</strong>: 这是设备驱动程序与硬件设备（如串口、并口、键盘控制器）进行底层通信的唯一途径（在PMIO模型下）。操作系统通过设置I/O权限位图（I/O Permission Bit Map）来限制用户模式程序执行<code>IN</code>/<code>OUT</code>，防止恶意程序直接破坏硬件。</li>
<li><strong>例子</strong>: 读取CMOS RAM的第0个寄存器（秒）<pre class="hljs"><code><div>MOV AL, 0       ; 要读取的CMOS寄存器地址
                OUT 70h, AL     ; 将地址写入CMOS地址端口70h
                IN  AL, 71h     ; 从CMOS数据端口71h读出秒数
                                ; AL中现在存放着当前的秒数
                </div></code></pre>
</li>
</ul>
<h4 id="23-%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><strong>2.3 地址传送指令</strong></h4>
<h5 id="231-lea-dest-src-load-effective-address"><strong>2.3.1 <code>lea dest, src</code> (Load Effective Address)</strong></h5>
<ul>
<li><strong>高级描述</strong>: 将<code>src</code>操作数指定的<strong>有效地址</strong>（偏移地址）计算出来，并传送到<code>dest</code>寄存器。<code>LEA</code>是"Load Effective Address"的缩写。</li>
<li><strong>CPU/架构层面</strong>: 这是x86中最具“CISC”特色的指令之一。它<strong>不会访问内存</strong>。它只是借用了内存寻址的语法格式来进行<strong>通用算术运算</strong>。CPU的地址生成单元（AGU）会计算出<code>src</code>操作数的最终偏移地址，但它不把这个地址送到地址总线，而是直接把它送回通用寄存器。</li>
<li><strong>系统层面/设计哲学</strong>:
                <ol>
<li><strong>获取地址</strong>: <code>LEA BX, [myVar]</code> 等价于 <code>MOV BX, OFFSET myVar</code>。</li>
<li><strong>高效的算术运算</strong>: <code>LEA</code>的真正威力在于此。编译器极度钟爱<code>LEA</code>来进行优化。
                <ul>
<li><code>LEA EAX, [EBX+8]</code>  =&gt; <code>EAX = EBX + 8</code> (比<code>ADD EAX, 8</code>更快，因为它不影响标志位)</li>
<li><code>LEA EAX, [EAX*2]</code>   =&gt; <code>EAX = EAX * 2</code> (比<code>SHL EAX, 1</code>或<code>ADD EAX, EAX</code>更快)</li>
<li><code>LEA EAX, [EAX*4]</code>   =&gt; <code>EAX = EAX * 4</code></li>
<li><code>LEA EAX, [EBX + ECX*4 + 100h]</code> =&gt; 在一个时钟周期内完成一次乘法和两次加法！这是任何简单算术指令都无法比拟的。</li>
</ul>
</li>
</ol>
</li>
<li><strong>例子</strong>:<pre class="hljs"><code><div>.DATA
                    myArray DW 1, 2, 3, 4, 5
                .CODE
                    ; 作用1：获取地址
                    LEA SI, [myArray]   ; SI = myArray的偏移地址

                    ; 作用2：复杂计算
                    MOV EBX, 10
                    MOV ECX, 3
                    ; 计算 EAX = EBX + ECX*4 + 20h = 10 + 12 + 32 = 54
                    LEA EAX, [EBX + ECX*4 + 20h] ; EAX = 00000036h (54)
                </div></code></pre>
</li>
</ul>
<h5 id="232-lds-dest-src--les-dest-src-load-pointer"><strong>2.3.2 <code>lds dest, src</code> &amp; <code>les dest, src</code> (Load Pointer)</strong></h5>
<ul>
<li><strong>高级描述</strong>: 从内存<code>src</code>中加载一个<strong>远指针</strong>（32位或48位）到目标寄存器对。<code>src</code>必须是内存操作数。</li>
<li><strong>CPU/架构层面</strong>:
                <ul>
<li><code>LDS reg16, mem32</code>: 从<code>mem32</code>处读取一个32位指针。低16位送入<code>reg16</code>（作为偏移），高16位送入<code>DS</code>段寄存器。</li>
<li><code>LES reg16, mem32</code>: 类似，但高16位送入<code>ES</code>段寄存器。</li>
</ul>
</li>
<li><strong>系统层面</strong>: 这两条指令是16位分段内存模型的历史产物。在那个时代，程序经常需要处理跨越64KB段边界的指针（称为远指针）。<code>LDS</code>/<code>LES</code>提供了一种原子地加载这种指针的方法，确保段和偏移被同时更新。在现代32位和64位<strong>平坦内存模型</strong>的操作系统（Windows, Linux）中，远指针的概念已经消失，这两条指令几乎<strong>已被废弃</strong>，了解即可。</li>
</ul>
<h4 id="24-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><strong>2.4 标志寄存器传送指令</strong></h4>
<h5 id="241-lahf-load-ah-from-flags--sahf-store-ah-into-flags"><strong>2.4.1 <code>lahf</code> (Load AH from Flags)</strong> &amp; <strong><code>sahf</code> (Store AH into Flags)</strong></h5>
<ul>
<li><strong>高级描述</strong>: 在<code>AH</code>寄存器和<code>FLAGS</code>寄存器的<strong>低8位</strong>之间传送数据。</li>
<li><strong>CPU/架构层面/设计哲学</strong>: 这完全是为了<strong>向后兼容</strong>。Intel 8086的前辈，8080处理器，有一个包含标志位的寄存器，其布局与<code>FLAGS</code>寄存器的低8位完全相同 (SF, ZF, AF, PF, CF)。为了能让8080的汇编代码更容易地移植到8086，Intel设计了这两条指令。它们在现代编程中很少使用，因为有更强大的<code>PUSHF</code>/<code>POPF</code>。</li>
</ul>
<h5 id="242-pushf-push-flags--popf-pop-flags"><strong>2.4.2 <code>pushf</code> (Push Flags)</strong> &amp; <strong><code>popf</code> (Pop Flags)</strong></h5>
<ul>
<li><strong>高级描述</strong>: 将16位的<code>FLAGS</code>寄存器压入或弹出堆栈。</li>
<li><strong>CPU/架构层面</strong>: <code>pushf</code>的行为与<code>push ax</code>类似，但操作数是<code>FLAGS</code>寄存器。<code>popf</code>则从栈顶取出16位数，恢复到<code>FLAGS</code>寄存器。</li>
<li><strong>系统层面</strong>:
                <ol>
<li><strong>保存和恢复状态</strong>: 当你需要调用一个子程序，但又不确定它是否会修改标志位，而你后续的代码又依赖于当前的标志位状态时，就可以在调用前<code>pushf</code>，调用后<code>popf</code>。</li>
<li><strong>手动修改标志位</strong>: 虽然不常见，但你可以<code>pushf</code>，修改栈上的值，然后<code>popf</code>来间接修改<code>FLAGS</code>寄存器。例如，可以手动设置方向标志位<code>DF</code>。</li>
</ol>
</li>
</ul>
<h5 id="243-pushfd-push-eflags--popfd-pop-eflags"><strong>2.4.3 <code>pushfd</code> (Push EFlags)</strong> &amp; <strong><code>popfd</code> (Pop EFlags)</strong></h5>
<ul>
<li>
<p><strong>高级描述</strong>: <code>pushf</code>/<code>popf</code>的32位版本，操作32位的<code>EFLAGS</code>寄存器。</p>
</li>
<li>
<p><strong>系统层面</strong>: 这两条指令在<strong>操作系统内核</strong>和<strong>调试器</strong>中是至关重要的。</p>
<ul>
<li><strong>上下文切换</strong>: 当操作系统需要从一个进程切换到另一个进程时，它必须完整地保存当前进程的所有状态，这其中就包括了<code>EFLAGS</code>寄存器。<code>pushfd</code>是保存它的最直接方式。</li>
<li><strong>中断处理</strong>: 当一个中断发生时，硬件会自动保存<code>EFLAGS</code>。但在中断服务程序内部，如果需要改变标志位（例如，通过<code>CLI</code>关闭中断），就需要在开头<code>pushfd</code>，在结尾<code>popfd</code>，以确保不影响被中断的程序。</li>
</ul>
</li>
<li>
<p><strong>例子</strong>: 手动设置方向标志位 <code>DF</code></p>
<pre class="hljs"><code><div>pushf           ; 将FLAGS压栈
                pop ax          ; 将FLAGS的值取到AX中
                or ah, 04h      ; DF是FLAGS的第10位, 对应AH的第2位(00000100b)
                ; or ax, 0400h  ; 更清晰的写法是直接操作AX
                push ax         ; 将修改后的值压回栈
                popf            ; 恢复到FLAGS寄存器，现在DF=1
                ; 此后的字符串操作将从高地址向低地址进行

                ; 更简洁的方式
                std             ; Set Direction Flag, 专为此设计
                </div></code></pre>
</li>
</ul>
</article><div class="share-buttons">
<p>分享到：</p>
<a class="share-btn weibo" href="#" onclick="sharePost(event, 'weibo')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Sina Weibo</title><path d="M10.098 20.323c-3.977.391-7.414-1.406-7.672-4.02-.259-2.609 2.759-5.047 6.74-5.441 3.979-.394 7.413 1.404 7.671 4.018.259 2.6-2.759 5.049-6.737 5.439l-.002.004zM9.05 17.219c-.384.616-1.208.884-1.829.602-.612-.279-.793-.991-.406-1.593.379-.595 1.176-.861 1.793-.601.622.263.82.972.442 1.592zm1.27-1.627c-.141.237-.449.353-.689.253-.236-.09-.313-.361-.177-.586.138-.227.436-.346.672-.24.239.09.315.36.18.601l.014-.028zm.176-2.719c-1.893-.493-4.033.45-4.857 2.118-.836 1.704-.026 3.591 1.886 4.21 1.983.64 4.318-.341 5.132-2.179.8-1.793-.201-3.642-2.161-4.149zm7.563-1.224c-.346-.105-.57-.18-.405-.615.375-.977.42-1.804 0-2.404-.781-1.112-2.915-1.053-5.364-.03 0 0-.766.331-.571-.271.376-1.217.315-2.224-.27-2.809-1.338-1.337-4.869.045-7.888 3.08C1.309 10.87 0 13.273 0 15.348c0 3.981 5.099 6.395 10.086 6.395 6.536 0 10.888-3.801 10.888-6.82 0-1.822-1.547-2.854-2.915-3.284v.01zm1.908-5.092c-.766-.856-1.908-1.187-2.96-.962-.436.09-.706.511-.616.932.09.42.511.691.932.602.511-.105 1.067.044 1.442.465.376.421.466.977.316 1.473-.136.406.089.856.51.992.405.119.857-.105.992-.512.33-1.021.12-2.178-.646-3.035l.03.045zm2.418-2.195c-1.576-1.757-3.905-2.419-6.054-1.968-.496.104-.812.587-.706 1.081.104.496.586.813 1.082.707 1.532-.331 3.185.15 4.296 1.383 1.112 1.246 1.429 2.943.947 4.416-.165.48.106 1.007.586 1.157.479.165.991-.104 1.157-.586.675-2.088.241-4.478-1.338-6.235l.03.045z"></path></svg>
<span>微博</span>
</a>
<a class="share-btn twitter" href="#" onclick="sharePost(event, 'twitter')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M21.543 7.104c.015.211.015.423.015.636 0 6.507-4.954 14.01-14.01 14.01v-.003A13.94 13.94 0 0 1 0 19.539a9.88 9.88 0 0 0 7.287-2.041 4.93 4.93 0 0 1-4.6-3.42 4.916 4.916 0 0 0 2.223-.084A4.926 4.926 0 0 1 .96 9.167v-.062a4.887 4.887 0 0 0 2.235.616A4.928 4.928 0 0 1 1.67 3.148 13.98 13.98 0 0 0 11.82 8.292a4.929 4.929 0 0 1 8.39-4.49 9.868 9.868 0 0 0 3.128-1.196 4.941 4.941 0 0 1-2.165 2.724A9.828 9.828 0 0 0 24 4.555a10.019 10.019 0 0 1-2.457 2.549z"></path></svg>
<span>Twitter</span>
</a>
<a class="share-btn linkedin" href="#" onclick="sharePost(event, 'linkedin')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg>
<span>LinkedIn</span>
</a>
<a class="share-btn wechat" href="#" onclick="sharePost(event, 'wechat')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>WeChat</title><path d="M8.691 2.188C3.891 2.188 0 5.476 0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59 0 0 1 .213.665l-.39 1.48c-.019.07-.048.141-.048.213 0 .163.13.295.29.295a.326.326 0 0 0 .167-.054l1.903-1.114a.864.864 0 0 1 .717-.098 10.16 10.16 0 0 0 2.837.403c.276 0 .543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178A1.17 1.17 0 0 1 4.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813 0c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178 1.17 1.17 0 0 1-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826 0 1.622-.12 2.361-.336a.722.722 0 0 1 .598.082l1.584.926a.272.272 0 0 0 .14.047c.134 0 .24-.111.24-.247 0-.06-.023-.12-.038-.177l-.327-1.233a.582.582 0 0 1-.023-.156.49.49 0 0 1 .201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.97-.982zm4.844 0c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.969-.982z"></path></svg>
<span>微信</span>
</a>
<a class="share-btn qq" href="#" onclick="sharePost(event, 'qq')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Tencent QQ</title><path d="M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673"></path></svg>
<span>QQ</span>
</a>
<a class="share-btn facebook" href="#" onclick="sharePost(event, 'facebook')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Facebook</title><path d="M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z"></path></svg>
<span>Facebook</span>
</a>
</div>
<div class="giscus-container" style="margin-top: 50px;">
  <script src="https://giscus.app/client.js"
  data-repo="forliage/forliage.github.io"
  data-repo-id="R_kgDONjzd4w"
  data-category="Announcements"
  data-category-id="DIC_kwDONjzd484Cus1G"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"
  data-theme="https://forliage.github.io/giscus.css"
  data-lang="zh-CN"
  crossorigin="anonymous"
  async>
</script>
</div>


</main>
</div>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
<script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
<div class="dock">
  <a href="https://forliage.github.io/index.html">🏠</a>
  <a href="https://forliage.github.io/posts.html">📚</a>
  <a href="https://forliage.github.io/about.html">👤</a>
</div>
<script src="../script.js"></script>
<!-- The Modal -->
<div class="modal" id="about-me-modal">
<!-- Modal content -->
<div class="modal-content">
<span class="close-button">×</span>
<h2>About Me</h2>
<p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
<p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
<p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
<p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
<p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
<p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
<hr/>
<h3>订阅我的博客</h3>
<p>订阅功能正在建设中，敬请期待！</p>
</div>
</div>
<script src="../modal.js"></script><script src="../trail.js"></script>
<!-- Highlight.js Core -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- Highlight.js Copy Plugin -->
<script src="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.js"></script>
<!-- Initialize Highlight.js and Copy Plugin -->
<script>
  hljs.highlightAll();
  hljs.addPlugin(new CopyButtonPlugin());
</script>
</body>
</html>