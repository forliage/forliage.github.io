<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>图像信息处理3:图像几何变换</title>
    
    <link rel="stylesheet" href="../style.css">
    
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <audio id="bg-music" src="../music.mp3" loop></audio>
    <button id="music-toggle" class="music-control">♪</button>
    <header>
        <h1>forliage的blog</h1>
        <nav>
            <ul>
                <li><a href="../index.html">首页</a></li>
                <li><a href="../posts.html">文章</a></li>
                <li><a href="../about.html">关于</a></li>
                <li><a href="../category.html?category=技术文章">技术文章</a></li>
                <li><a href="../category.html?category=生活随笔">生活随笔</a></li>
                <li><a href="../category.html?category=学习笔记">学习笔记</a></li>
                <li><a href="../category.html?category=心情日记">心情日记</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div id="sidebar-container"></div>
        <main>
            <article>
                <h1 id="%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%863%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2">图像信息处理3:图像几何变换</h1>
                <h3 id="1-%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%9F%BA%E7%A1%80"><strong>1. 几何变换基础</strong></h3>
                <h4 id="11-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><strong>1.1 核心概念</strong></h4>
                <p><strong>图像几何变换 (Geometric Transformation)</strong> 是指改变图像中像素的空间位置，从而产生一幅新的图像。其核心在于：</p>
                <ul>
                <li><strong>只改变位置，不改变像素值：</strong> 变换本身只涉及坐标的重新映射，像素的灰度值或颜色值在理论上是不变的。</li>
                <li><strong>空间坐标变换：</strong> 建立源图像 $f(x, y)$ 与目标图像 $g(x', y')$ 之间像素坐标的映射关系。</li>
                </ul>
                <p>这个映射关系可以表示为：
                $$
                (x, y) = T(x', y')
                $$
                其中，$(x, y)$ 是源图像中的坐标，$(x', y')$ 是目标图像中的坐标，$T$ 是变换函数。这意味着，目标图像中 $(x', y')$ 位置的像素值，应该从源图像中 $(x, y)$ 位置获取。</p>
                <h4 id="12-%E5%89%8D%E5%90%91%E6%98%A0%E5%B0%84-vs-%E5%90%8E%E5%90%91%E6%98%A0%E5%B0%84"><strong>1.2 前向映射 vs. 后向映射</strong></h4>
                <p>实现几何变换有两种思路：</p>
                <ol>
                <li>
                <p><strong>前向映射 (Forward Mapping):</strong></p>
                <ul>
                <li><strong>思路：</strong> 遍历源图像 $f$ 中的每一个像素 $(x, y)$，通过变换 $T_{fwd}$ 计算它在目标图像 $g$ 中的对应位置 $(x', y')$，然后将 $f(x, y)$ 的值赋给 $g(x', y')$。
                $$
                (x', y') = T_{fwd}(x, y)
                $$</li>
                <li><strong>问题：</strong>
                <ul>
                <li><strong>像素重叠（Collision）：</strong> 多个源像素可能映射到目标图像的同一个位置。</li>
                <li><strong>空洞（Hole）：</strong> 目标图像的某些像素位置可能没有任何源像素映射过来，形成空洞。</li>
                <li><strong>浮点坐标：</strong> 计算出的 $(x', y')$ 往往是浮点数，需要取整，导致精度损失。</li>
                </ul>
                </li>
                </ul>
                </li>
                <li>
                <p><strong>后向映射 (Backward Mapping / Inverse Mapping):</strong></p>
                <ul>
                <li><strong>思路：</strong> 遍历目标图像 $g$ 中的每一个像素 $(x', y')$，通过<strong>逆变换</strong> $T_{inv}$ 计算它在源图像 $f$ 中的对应位置 $(x, y)$，然后将 $f(x, y)$ 的值赋给 $g(x', y')$。
                $$
                (x, y) = T_{inv}(x', y')
                $$</li>
                <li><strong>优点：</strong>
                <ul>
                <li><strong>无空洞/重叠：</strong> 目标图像的每个像素都有且仅有一个确定的源坐标。</li>
                <li><strong>易于实现：</strong> 这是现代图像处理库（如OpenCV）普遍采用的方法。</li>
                </ul>
                </li>
                <li><strong>挑战：</strong> 计算出的源坐标 $(x, y)$ 仍然是浮点数。由于像素坐标必须是整数，我们无法直接获取 $f(x, y)$ 的值。这就引出了<strong>插值 (Interpolation)</strong> 的需求。</li>
                </ul>
                </li>
                </ol>
                <p><strong>结论：在实际应用中，我们几乎总是使用后向映射+插值的方法来实现几何变换。</strong></p>
                <h3 id="2-%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2-affine-transformation"><strong>2. 仿射变换 (Affine Transformation)</strong></h3>
                <p>仿射变换是一类重要的线性几何变换，它保持了图像的“平直性”（直线变换后仍然是直线）和“平行性”（平行线变换后仍然平行），但不一定保持角度和长度。</p>
                <h4 id="21-%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E4%B8%8E%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5"><strong>2.1 齐次坐标与变换矩阵</strong></h4>
                <p>为了将平移（加法）和其他线性变换（乘法）统一到同一个矩阵运算框架下，我们引入<strong>齐次坐标 (Homogeneous Coordinates)</strong>。一个二维点 $(x, y)$ 的齐次坐标表示为 $(x, y, 1)$。</p>
                <p>一个通用的2D仿射变换可以用一个 $3 \times 3$ 的矩阵来表示：
                $$
                \begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = \begin{bmatrix} a & b & c \\ d & e & f \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}
                $$
                展开后即为：
                $$
                \begin{cases} x' = ax + by + c \\ y' = dx + ey + f \end{cases}
                $$
                下面我们来具体看几种基本的仿射变换。</p>
                <h4 id="22-%E5%9F%BA%E6%9C%AC%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2"><strong>2.2 基本仿射变换</strong></h4>
                <ol>
                <li>
                <p><strong>平移 (Translation):</strong>
                将图像沿x轴平移 $t_x$，沿y轴平移 $t_y$。</p>
                <ul>
                <li><strong>方程：</strong> $x' = x + t_x$, $y' = y + t_y$</li>
                <li><strong>变换矩阵：</strong>
                $$
                M_{trans} = \begin{bmatrix} 1 & 0 & t_x \\ 0 & 1 & t_y \\ 0 & 0 & 1 \end{bmatrix}
                $$</li>
                </ul>
                </li>
                <li>
                <p><strong>缩放 (Scaling):</strong>
                将图像沿x轴缩放 $s_x$ 倍，沿y轴缩放 $s_y$ 倍（相对于原点）。</p>
                <ul>
                <li><strong>方程：</strong> $x' = s_x \cdot x$, $y' = s_y \cdot y$</li>
                <li><strong>变换矩阵：</strong>
                $$
                M_{scale} = \begin{bmatrix} s_x & 0 & 0 \\ 0 & s_y & 0 \\ 0 & 0 & 1 \end{bmatrix}
                $$</li>
                </ul>
                </li>
                <li>
                <p><strong>旋转 (Rotation):</strong>
                将图像绕原点逆时针旋转 $\theta$ 角度。</p>
                <ul>
                <li><strong>方程：</strong> $x' = x \cos\theta - y \sin\theta$, $y' = x \sin\theta + y \cos\theta$</li>
                <li><strong>变换矩阵：</strong>
                $$
                M_{rot} = \begin{bmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{bmatrix}
                $$</li>
                </ul>
                </li>
                <li>
                <p><strong>镜像/翻转 (Mirror/Flip):</strong></p>
                <ul>
                <li><strong>水平翻转 (绕y轴):</strong> $x' = -x$, $y' = y$  ($s_x=-1, s_y=1$)</li>
                <li><strong>垂直翻转 (绕x轴):</strong> $x' = x$, $y' = -y$  ($s_x=1, s_y=-1$)</li>
                <li><strong>变换矩阵 (水平翻转):</strong>
                $$
                M_{flipH} = \begin{bmatrix} -1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
                $$</li>
                </ul>
                </li>
                <li>
                <p><strong>剪切 (Shearing):</strong>
                使图像发生倾斜。</p>
                <ul>
                <li><strong>水平剪切:</strong> $x' = x + sh_x \cdot y$, $y' = y$</li>
                <li><strong>垂直剪切:</strong> $x' = x$, $y' = y + sh_y \cdot x$</li>
                <li><strong>变换矩阵 (水平剪切):</strong>
                $$
                M_{shearH} = \begin{bmatrix} 1 & sh_x & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
                $$</li>
                </ul>
                </li>
                </ol>
                <h4 id="23-%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2"><strong>2.3 组合变换</strong></h4>
                <p>仿射变换的强大之处在于可以通过矩阵乘法将多个基本变换组合成一个单一的变换。例如，要先将图像放大2倍，然后绕原点旋转45度，最后再平移(10, 20)，其总变换矩阵为：
                $$
                M_{total} = M_{trans} \cdot M_{rot} \cdot M_{scale}
                $$
                <strong>注意：矩阵乘法不满足交换律，变换的顺序至关重要！</strong></p>
                <h4 id="24-c-%E5%AE%9E%E7%8E%B0-%E4%BD%BF%E7%94%A8opencv"><strong>2.4 C++ 实现 (使用OpenCV)</strong></h4>
                <p>OpenCV提供了便捷的函数来执行仿射变换。</p>
                <pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/opencv.hpp&gt;</span></span>

                <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
                    cv::Mat src = cv::imread(<span class="hljs-string">"your_image.jpg"</span>);
                    <span class="hljs-keyword">if</span> (src.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

                    <span class="hljs-function">cv::Point2f <span class="hljs-title">src_center</span><span class="hljs-params">(src.cols / <span class="hljs-number">2.0f</span>, src.rows / <span class="hljs-number">2.0f</span>)</span></span>;

                    <span class="hljs-comment">// 1. 获取旋转矩阵 (绕中心旋转45度，缩放0.8倍)</span>
                    <span class="hljs-comment">// OpenCV的getRotationMatrix2D返回一个2x3的矩阵</span>
                    cv::Mat rot_mat = cv::getRotationMatrix2D(src_center, <span class="hljs-number">45.0</span>, <span class="hljs-number">0.8</span>);

                    <span class="hljs-comment">// 2. 获取平移矩阵 (自定义一个2x3矩阵)</span>
                    cv::Mat trans_mat = (cv::Mat_&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">25</span>);

                    cv::Mat dst_rot, dst_trans;

                    <span class="hljs-comment">// 3. 应用仿射变换</span>
                    <span class="hljs-comment">// warpAffine函数内部实现了后向映射和插值</span>
                    cv::warpAffine(src, dst_rot, rot_mat, src.size());
                    cv::warpAffine(src, dst_trans, trans_mat, src.size());
                    
                    cv::imshow(<span class="hljs-string">"Source"</span>, src);
                    cv::imshow(<span class="hljs-string">"Rotated and Scaled"</span>, dst_rot);
                    cv::imshow(<span class="hljs-string">"Translated"</span>, dst_trans);
                    cv::waitKey(<span class="hljs-number">0</span>);
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                }
                </div></code></pre>
                <h3 id="3-%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95-interpolation"><strong>3. 插值算法 (Interpolation)</strong></h3>
                <p>当后向映射计算出的源坐标 $(x, y)$ 是浮点数时，我们需要根据其周围整数坐标像素的值来估算出 $f(x, y)$ 的值。这就是插值。</p>
                <h4 id="31-%E6%9C%80%E8%BF%91%E9%82%BB%E6%8F%92%E5%80%BC-nearest-neighbor-interpolation"><strong>3.1 最近邻插值 (Nearest Neighbor Interpolation)</strong></h4>
                <ul>
                <li><strong>思想：</strong> 最简单的方法，直接选择离 $(x, y)$ 最近的整数坐标点的像素值作为结果。
                $$
                f(x, y) \approx f(\text{round}(x), \text{round}(y))
                $$</li>
                <li><strong>优点：</strong> 计算速度最快。</li>
                <li><strong>缺点：</strong> 效果最差，会产生明显的锯齿和块状效应（马赛克）。</li>
                </ul>
                <h4 id="32-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC-bilinear-interpolation"><strong>3.2 双线性插值 (Bilinear Interpolation)</strong></h4>
                <ul>
                <li><strong>思想：</strong> 在 $(x, y)$ 周围的 $2 \times 2$ 邻域内，进行两次线性插值。</li>
                <li><strong>步骤：</strong>
                <ol>
                <li>找到 $(x, y)$ 的四个最近邻像素点：$Q_{11}=(x_1, y_1)$, $Q_{12}=(x_1, y_2)$, $Q_{21}=(x_2, y_1)$, $Q_{22}=(x_2, y_2)$。</li>
                <li><strong>第一次插值（水平方向）：</strong>
                $$
                f(R_1) = f(x, y_1) \approx \frac{x_2-x}{x_2-x_1}f(Q_{11}) + \frac{x-x_1}{x_2-x_1}f(Q_{21})
                $$
                $$
                f(R_2) = f(x, y_2) \approx \frac{x_2-x}{x_2-x_1}f(Q_{12}) + \frac{x-x_1}{x_2-x_1}f(Q_{22})
                $$</li>
                <li><strong>第二次插值（垂直方向）：</strong>
                $$
                f(x, y) \approx \frac{y_2-y}{y_2-y_1}f(R_1) + \frac{y-y_1}{y_2-y_1}f(R_2)
                $$</li>
                </ol>
                </li>
                <li><strong>优点：</strong> 效果平滑，是速度和质量之间的一个很好的折中，也是最常用的插值方法。</li>
                <li><strong>缺点：</strong> 会轻微模糊图像细节。</li>
                </ul>
                <h4 id="33-%E5%8F%8C%E4%B8%89%E6%AC%A1%E6%8F%92%E5%80%BC-bicubic-interpolation"><strong>3.3 双三次插值 (Bicubic Interpolation)</strong></h4>
                <ul>
                <li><strong>思想：</strong> 使用周围 $4 \times 4$ 邻域内的16个像素点，拟合一个三次多项式曲面来估算像素值。</li>
                <li><strong>优点：</strong> 效果最好，能更好地保留图像细节，边缘更平滑。</li>
                <li><strong>缺点：</strong> 计算量最大，速度最慢。</li>
                </ul>
                <p><strong>在OpenCV中，<code>cv::warpAffine</code>和<code>cv::resize</code>等函数的<code>flags</code>参数可以指定插值方法，如 <code>cv::INTER_NEAREST</code>, <code>cv::INTER_LINEAR</code> (默认), <code>cv::INTER_CUBIC</code>。</strong></p>
                <h3 id="4-%E9%AB%98%E7%BA%A7%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><strong>4. 高级几何变换</strong></h3>
                <h4 id="41-%E5%9B%BE%E5%83%8F%E6%89%AD%E6%9B%B2-warping"><strong>4.1 图像扭曲 (Warping)</strong></h4>
                <p>当变换函数 $T$ 不是简单的仿射变换，而是更复杂的非线性函数时，就称为图像扭曲。例如，透视变换（Perspective Transformation）可以模拟三维空间中的旋转，它需要一个 $3 \times 3$ 的完整矩阵，并且不再保持平行性。局部扭曲则可以产生哈哈镜等效果。</p>
                <h4 id="42-%E5%9B%BE%E5%83%8F%E6%B8%90%E5%8F%98-morphing"><strong>4.2 图像渐变 (Morphing)</strong></h4>
                <p>图像渐变（Morphing）是一种更为复杂的动画技术，它将一幅图像（源图像A）平滑地过渡到另一幅图像（目标图像B）。这涉及到两个同步进行的过程：</p>
                <ol>
                <li><strong>形状渐变 (Warping)：</strong> 将源图像A的形状逐渐扭曲成目标图像B的形状。这通常通过在两幅图像上定义一组对应的<strong>特征点或特征线</strong>来实现。中间帧的形状是A和B对应特征点位置的加权平均。</li>
                <li><strong>颜色渐变 (Cross-dissolving)：</strong> 将扭曲后的源图像和扭曲后的目标图像进行颜色上的加权平均（淡入淡出）。</li>
                </ol>
                <ul>
                <li><strong>公式（以像素为单位）：</strong>
                对于第 $k$ 帧（$k$ 从0到1变化），其像素值 $I_k(p_k)$ 可以表示为：
                <ul>
                <li><strong>位置插值：</strong> $p_k = (1-k) \cdot p_A + k \cdot p_B$</li>
                <li><strong>颜色插值：</strong> $I_k(p_k) = (1-k) \cdot I_A(p_A) + k \cdot I_B(p_B)$</li>
                </ul>
                </li>
                </ul>
                <p>Morphing的关键在于如何建立两幅图像之间有意义的、稠密的对应关系。</p>
                <h3 id="5-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E8%A1%A8%E6%83%85%E8%BF%81%E7%A7%BB-expression-transfer"><strong>5. 应用实例：表情迁移 (Expression Transfer)</strong></h3>
                <p>几何变换是许多计算机图形学和视觉任务的核心技术，例如表情迁移。</p>
                <ul>
                <li><strong>问题描述：</strong> 给定一个源人物的视频A（例如，一个中性表情到微笑的序列 A -&gt; A'），和一个目标人物的静态图像B，目标是生成目标人物做出同样表情的图像B'。</li>
                <li><strong>基于几何变换的简化思路 (Ratio Image):</strong>
                <ol>
                <li><strong>特征点标记：</strong> 在 A, A', B 上手动或自动标记出面部关键特征点（眼角、嘴角、鼻尖等）。</li>
                <li><strong>几何形变计算：</strong> 从 A 到 A' 的每个特征点都发生了一个位移向量。这个位移场代表了“微笑”这个表情的几何形变。</li>
                <li><strong>形变应用 (Warping):</strong> 将这个几何形变场应用到图像B上。对于B中的每个特征点 $v_b$，其在B'中的新位置 $v_{b'}$ 计算为：$v_{b'} = v_b + (v_{a'} - v_a)$。 这就生成了一个初步的、几何上对齐的图像 $B_{warped}$。</li>
                <li><strong>光照与纹理修正 (Ratio Image):</strong> 仅仅几何扭曲是不够的，因为表情变化会引起光照变化（如皱纹产生阴影）。<code>Expression Ratio Image (ERI)</code> 是一种捕捉这种光照变化的方法。
                <ul>
                <li>假设图像亮度 $I$ 由反射率 $\rho$ 和光照 $E$ 决定：$I(n) = \rho E(n)$，其中 $n$ 是表面法线。</li>
                <li>表情变化改变了法线 $n \to n'$，因此 $I' = \rho E(n')$。</li>
                <li>ERI 定义为 $R = I'/I = E(n')/E(n)$。这个比率<strong>与材质无关</strong>，只捕捉了由形变引起的光照变化。</li>
                </ul>
                </li>
                <li><strong>最终合成：</strong>
                <ul>
                <li>计算源图像的ERI: $R_A = A'/A_{warped}$ (A'需要先扭曲以对齐A)。</li>
                <li>将这个光照变化应用到目标图像上：$B' = B_{warped} \cdot R_A$。</li>
                </ul>
                </li>
                </ol>
                </li>
                </ul>
                <p>这个简化的流程展示了如何结合几何变换（Warping）和其他图像处理技术来实现复杂的视觉效果。</p>
            </article>
        </main>
    </div>
    
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
    <script src="../script.js"></script>
</body>
</html>