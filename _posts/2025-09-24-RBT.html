<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<title>算法:红黑树 (Red-Black Tree) 深度解析</title>
<link href="../style.css" rel="stylesheet"/>
<link href="../modal.css" rel="stylesheet"/>
<script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" type="text/javascript">
</script>
<!-- Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FPDBQB4LZD"></script>
<script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FPDBQB4LZD');
    </script>
<!-- Highlight.js Themes -->
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/rose-pine-dawn.min.css" id="highlight-theme-link" rel="stylesheet"/>
<!-- Highlight.js Copy Plugin CSS -->
<link href="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.css" rel="stylesheet"/>
</head>
<body>
<audio id="bg-music" loop="" src="../music.mp3"></audio>
<button class="music-control" id="music-toggle">♪</button><button class="dark-mode-control" id="dark-mode-toggle">🌙</button>
<button id="style-toggle-btn" title="切换控件样式">🎨</button>
<header>
<h1>forliage的blog</h1>
<nav>
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../posts.html">文章</a></li>
<li><a href="../about.html">关于</a></li>
<li><a href="../category.html?category=技术文章">技术文章</a></li>
<li><a href="../category.html?category=生活随笔">生活随笔</a></li>
<li><a href="../category.html?category=学习笔记">学习笔记</a></li>
<li><a href="../category.html?category=心情日记">心情日记</a></li>
<li><a href="#" id="about-me-btn">ABOUT ME</a></li>
</ul>
</nav>
</header>
<div class="container">
<div id="sidebar-container"></div>
<main>
<article>
<h1 id="红黑树">算法:红黑树 (Red-Black Tree) 深度解析</h1>
<h3 id="第一部分红黑树的起源-定义与核心性质"><strong>第一部分：红黑树的起源、定义与核心性质</strong></h3>
<h4 id="11--为什么我们需要红黑树"><strong>1.1、 为什么我们需要红黑树？</strong></h4>
<p>在我们深入红黑树的细节之前，一个关键问题是：我们为什么要发明这么一种看起来很复杂的数据结构？</p>
<p>答案源于对基础二叉搜索树（Binary Search Tree, BST）的优化需求。一个普通的BST在理想情况下，即数据随机插入时，树的高度大约为 $O(\log n)$，其中 $n$ 是节点的数量。在这种情况下，其增删改查操作的效率都非常高，接近于二分查找。</p>
<p>然而，BST有一个致命的弱点：它对插入数据的顺序极为敏感。如果我们按顺序插入一系列数据（例如 1, 2, 3, 4, 5），BST会退化成一个链表。</p>
<div class="mermaid">graph TD
    subgraph "普通BST：顺序插入1, 2, 3, 4, 5"
        A[1] --&gt; B[2];
        B --&gt; C[3];
        C --&gt; D[4];
        D --&gt; E[5];
    end
</div>
<p>在这种最坏情况下，树的高度为 $O(n)$，所有操作的时间复杂度都退化为 $O(n)$，这与我们使用树形结构的初衷背道而驰。</p>
<p>为了解决这个问题，科学家们提出了一系列“自平衡二叉搜索树”（Self-Balancing Binary Search Trees）。这类树的核心思想是：在每次插入或删除节点后，通过一系列的修复操作（主要是<strong>旋转</strong>），来维持树的“大致平衡”，从而确保树的高度始终保持在 $O(\log n)$。</p>
<p>红黑树就是这类数据结构中最著名的一种。与另一位著名的成员——AVL树——相比，红黑树的平衡条件没有那么“严格”。AVL树要求任何节点的左右子树高度差不能超过1，这使得它的查询性能非常稳定，但为了维持这种严格的平衡，插入和删除时可能需要进行多次旋转。而红黑树的平衡条件相对宽松，它通过一套精妙的“红黑”着色规则来实现，这使得它在插入和删除操作中的平均旋转次数更少，因此在写操作频繁的场景下，其综合性能通常优于AVL树。</p>
<p><strong>小结</strong>：红黑树的诞生，是为了解决普通二叉搜索树在最坏情况下的性能退化问题。它是一种自平衡的二叉搜索树，通过引入节点颜色和一套维护规则，来保证树的高度始终在对数级别，从而为增、删、查等操作提供稳定高效的 $O(\log n)$ 时间复杂度。</p>
<h4 id="12--红黑树的严格定义"><strong>1.2、 红黑树的严格定义</strong></h4>
<p>要成为一棵合格的红黑树，必须始终遵守以下五条规则（或称“性质”、“约束”）。这五条规则是后续所有操作和证明的基础。</p>
<ol>
<li><strong>颜色戒律 (Color Invariant)</strong>：每个节点要么是<strong>红色</strong>，要么是<strong>黑色</strong>。</li>
<li><strong>根节点戒律 (Root Invariant)</strong>：树的根节点永远是<strong>黑色</strong>。</li>
<li><strong>叶子戒律 (Leaf Invariant)</strong>：所有的叶子节点（NIL节点）都是<strong>黑色</strong>。
<ul>
<li><strong>解读</strong>：这里的“叶子节点”非常关键，它不是指我们通常意义上没有子节点的节点，而是指其“哨兵节点”（sentinel node）或称为NIL节点。在实现中，为了方便处理边界条件，我们通常不使用 <code>nullptr</code>，而是用一个全局唯一的黑色哨兵节点来表示所有的叶子。这样，每个常规节点都恰好有两个子节点。</li>
</ul>
</li>
<li><strong>红色戒律 (Red Invariant)</strong>：如果一个节点是<strong>红色</strong>的，那么它的两个子节点必须都是<strong>黑色</strong>的。
<ul>
<li><strong>解读</strong>：这条规则是红黑树平衡性的关键之一。它直接保证了从根到任意叶子的路径上，不会出现连续的两个红色节点。反过来看，就是<strong>从任何节点到其后代叶节点的路径上，红色节点不能相邻</strong>。</li>
</ul>
</li>
<li><strong>路径戒律 (Path Invariant)</strong>：对于树中的任意一个节点，从该节点到其所有后代叶子节点的简单路径上，所包含的<strong>黑色</strong>节点的数量是相同的。
<ul>
<li><strong>解读</strong>：这个数量被称为该节点的“<strong>黑高</strong>”（Black-Height），记为 $bh(x)$。这条规则是红黑树平衡性的<strong>核心</strong>。它强制要求，无论你从哪个分支下去，到达底部的“黑色深度”是完全一致的，从而间接地约束了树的整体高度。</li>
</ul>
</li>
</ol>
<p>下面是一个满足所有红黑树性质的示例：</p>
<div class="mermaid">graph TD
    subgraph "红黑树示例 (bh=2)"
        A(13):::black --&gt; B(8):::red;
        A --&gt; C(17):::black;
        B --&gt; D(1):::black;
        B --&gt; E(11):::black;
        C --&gt; F(15):::red;
        C --&gt; G(25):::black;
        E --&gt; H(..):::red;
        F --&gt; I(..):::black
        G --&gt; J(..):::red;
        
        %% Dummy nodes for layout
        D --&gt; D1(NIL):::black;
        D --&gt; D2(NIL):::black;
        H --&gt; H1(NIL):::black;
        H --&gt; H2(NIL):::black;
        I --&gt; I1(NIL):::black;
        I --&gt; I2(NIL):::black;
        J --&gt; J1(NIL):::black;
        J --&gt; J2(NIL):::black;
    end
    classDef red fill:#f88,stroke:#333,stroke-width:2px;
    classDef black fill:#666,stroke:#333,stroke-width:2px,color:#fff;
    class B,F,H,J red;
    class A,C,D,E,G,I,D1,D2,H1,H2,I1,I2,J1,J2 black;
</div>
<p><em>（注：上图中，NIL节点为逻辑上的黑色叶子节点，为简化视图仅展示部分）</em></p>
<h4 id="13--从五条定义到性能保证黑高的作用"><strong>1.3、 从五条定义到性能保证：黑高的作用</strong></h4>
<p>这五条看似简单的规则如何保证树的高度为 $O(\log n)$？这背后是严谨的数学证明，也是体现深度的地方。</p>
<p><strong>核心引理</strong>：一棵以节点 $x$ 为根的子树，其内部节点（不包括NIL叶子）的数量至少为 $2^{bh(x)} - 1$。</p>
<p><strong>证明（使用数学归纳法）</strong>：</p>
<ol>
<li><strong>基础情况</strong>：如果 $x$ 的高度为0，那么 $x$ 就是一个叶子节点（NIL）。它的黑高 $bh(x) = 0$。其内部节点数量为0。根据公式，$2^0 - 1 = 1 - 1 = 0$。引理成立。</li>
<li><strong>归纳假设</strong>：假设对于任意节点 $y$，如果其子树的黑高为 $k$，那么以 $y$ 为根的子树内部节点数至少为 $2^k - 1$。现在我们来证明，对于黑高为 $bh(x) = k+1$ 的节点 $x$，其内部节点数至少为 $2^{k+1} - 1$。</li>
<li><strong>归纳步骤</strong>：
<ul>
<li>节点 $x$ 至少有两个子节点，我们称之为 $c_1$ 和 $c_2$。</li>
<li>根据路径戒律（性质5），$x$ 的黑高等于其子节点的黑高加上 $x$ 本身的颜色贡献。</li>
<li>如果 $x$ 的子节点 $c_i$ 是黑色的，那么 $bh(c_i) = bh(x) - 1 = k$。</li>
<li>如果 $x$ 的子节点 $c_i$ 是红色的，那么 $c_i$ 的子节点必须是黑色的（性质4），所以 $bh(c_i) = bh(x) = k+1$。但是，从 $x$ 经过 $c_i$ 到达叶子节点的黑节点数依然是 $k+1$，这意味着 $c_i$ 的子节点的黑高是 $k$。</li>
<li>因此，无论 $x$ 的子节点是什么颜色，其子节点的黑高至少为 $bh(x) - 1 = k$。</li>
<li>根据归纳假设，每个子节点 $c_i$ 所代表的子树，其内部节点数至少为 $2^{bh(c_i)} - 1 \ge 2^{bh(x)-1} - 1 = 2^k - 1$。</li>
<li>所以，以 $x$ 为根的子树的内部节点总数 $N(x)$ 为：<br>
$$N(x) = N(c_1) + N(c_2) + 1 \ge (2^k - 1) + (2^k - 1) + 1 = 2 \cdot 2^k - 1 = 2^{k+1} - 1$$
</li>
<li>证明完成。</li>
</ul>
</li>
</ol>
<p><strong>高度推论</strong>：一棵包含 $n$ 个内部节点的红黑树，其高度 $h$ 不会超过 $2 \log_2(n+1)$。</p>
<p><strong>证明</strong>：</p>
<ol>
<li>设树的根节点为 $root$，高度为 $h$。</li>
<li>根据红色戒律（性质4），从根到任意叶子的任何简单路径上，黑色节点的数量至少占一半。因此，根节点的黑高 $bh(root) \ge h/2$。</li>
<li>根据我们刚刚证明的引理，树的总结点数 $n \ge 2^{bh(root)} - 1$。</li>
<li>将两者结合：$n \ge 2^{h/2} - 1$。</li>
<li>整理得：$n+1 \ge 2^{h/2}$。</li>
<li>两边取对数：$\log_2(n+1) \ge h/2$。</li>
<li>最终得到：$h \le 2 \log_2(n+1)$。</li>
</ol>
<p><strong>结论</strong>：这个数学证明是红黑树性能的基石。它告诉我们，无论我们如何插入或删除，只要我们能维持那五条定义，树的高度 $h$ 就永远被锁定在 $O(\log n)$ 的范围内。</p>
<h4 id="14--基础操作与实现"><strong>1.4、 基础操作与实现</strong></h4>
<p>在深入探讨最复杂的插入和删除之前，我们必须先掌握查询和用于维持平衡的基础“积木”——旋转操作。</p>
<h5 id="141-查找-search"><strong>1.4.1 查找 (Search)</strong></h5>
<p>红黑树首先是一棵二叉搜索树，因此它的查找操作与标准的BST完全相同，无需关心节点的颜色。</p>
<p><strong>伪代码</strong>：</p>
<div class="code-container"><pre class="hljs"><code>TREE-SEARCH(x, k)
  if x == NIL or k == x.key
    return x
  if k &lt; x.key
    return TREE-SEARCH(x.left, k)
  else
    return TREE-SEARCH(x.right, k)
</code></pre></div>
<p><strong>C++ 完整代码</strong>：</p>
<div class="code-container"><pre class="hljs"><code>// 节点定义
enum Color { RED, BLACK };

struct Node {
    int key;
    Color color;
    Node *parent, *left, *right;

    // 构造函数
    Node(int k, Color c = RED, Node* p = nullptr, Node* l = nullptr, Node* r = nullptr)
        : key(k), color(c), parent(p), left(l), right(r) {}
};

// 查找函数 (在Tree类中)
// T_NIL是一个指向哨兵节点的指针
Node* find(int key) {
    Node* current = root;
    while (current != T_NIL &amp;&amp; key != current-&gt;key) {
        if (key &lt; current-&gt;key) {
            current = current-&gt;left;
        } else {
            current = current-&gt;right;
        }
    }
    return current; // 如果找不到，会返回T_NIL
}
</code></pre></div>
<h5 id="142-旋转-rotation"><strong>1.4.2 旋转 (Rotation)</strong></h5>
<p>旋转是红黑树（以及其他自平衡树）进行结构调整、维持平衡的核心操作。它能够在不破坏二叉搜索树性质的前提下，改变树的局部结构，降低子树高度。旋转分为左旋和右旋。</p>
<p><strong>左旋 (Left Rotation)</strong></p>
<p>对节点 <code>x</code> 进行左旋，是假设它的右子节点 <code>y</code> 不是NIL。旋转的目的是让 <code>y</code> 成为新的子树根，而 <code>x</code> 成为 <code>y</code> 的左子节点。</p>
<div class="mermaid">graph TD
    subgraph "左旋前 (Left-Rotate on x)"
        P --&gt; x;
        x --&gt; a(α);
        x --&gt; y;
        y --&gt; b(β);
        y --&gt; c(γ);
    end

    subgraph "左旋后"
        P --&gt; y;
        y --&gt; x;
        y --&gt; c;
        x --&gt; a;
        x --&gt; b;
    end
</div>
<p><strong>伪代码</strong>：</p>
<div class="code-container"><pre class="hljs"><code>LEFT-ROTATE(T, x)
  y = x.right
  x.right = y.left
  if y.left != T.nil
    y.left.p = x
  y.p = x.p
  if x.p == T.nil
    T.root = y
  else if x == x.p.left
    x.p.left = y
  else
    x.p.right = y
  y.left = x
  x.p = y
</code></pre></div>
<p><strong>右旋 (Right Rotation)</strong></p>
<p>右旋与左旋对称。对节点 <code>y</code> 进行右旋，是假设它的左子节点 <code>x</code> 不是NIL。旋转让 <code>x</code> 上位，<code>y</code> 成为 <code>x</code> 的右子节点。</p>
<div class="mermaid">graph TD
    subgraph "右旋前 (Right-Rotate on y)"
        P --&gt; y;
        y --&gt; x;
        y --&gt; c(γ);
        x --&gt; a(α);
        x --&gt; b(β);
    end
    
    subgraph "右旋后"
        P --&gt; x;
        x --&gt; a;
        x --&gt; y;
        y --&gt; b;
        y --&gt; c;
    end
</div>
<p><strong>伪代码</strong>：</p>
<div class="code-container"><pre class="hljs"><code>RIGHT-ROTATE(T, y)
  x = y.left
  y.left = x.right
  if x.right != T.nil
    x.right.p = y
  x.p = y.p
  if y.p == T.nil
    T.root = x
  else if y == y.p.right
    y.p.right = x
  else
    y.p.left = x
  x.right = y
  y.p = x
</code></pre></div>
<p><strong>C++ 完整代码</strong>：</p>
<div class="code-container"><pre class="hljs"><code>// 在红黑树类(RedBlackTree)中实现
// 假设有成员变量 Node* root 和 Node* T_NIL (哨兵)

void leftRotate(Node* x) {
    Node* y = x-&gt;right;
    x-&gt;right = y-&gt;left;
    if (y-&gt;left != T_NIL) {
        y-&gt;left-&gt;parent = x;
    }
    y-&gt;parent = x-&gt;parent;
    if (x-&gt;parent == nullptr) { // x was the root
        this-&gt;root = y;
    } else if (x == x-&gt;parent-&gt;left) {
        x-&gt;parent-&gt;left = y;
    } else {
        x-&gt;parent-&gt;right = y;
    }
    y-&gt;left = x;
    x-&gt;parent = y;
}

void rightRotate(Node* y) {
    Node* x = y-&gt;left;
    y-&gt;left = x-&gt;right;
    if (x-&gt;right != T_NIL) {
        x-&gt;right-&gt;parent = y;
    }
    x-&gt;parent = y-&gt;parent;
    if (y-&gt;parent == nullptr) { // y was the root
        this-&gt;root = x;
    } else if (y == y-&gt;parent-&gt;right) {
        y-&gt;parent-&gt;right = x;
    } else {
        y-&gt;parent-&gt;left = x;
    }
    x-&gt;right = y;
    y-&gt;parent = x;
}
</code></pre></div>
<h3 id="第二部分红黑树的插入操作与平衡修复"><strong>第二部分：红黑树的插入操作与平衡修复</strong></h3>
<p>插入一个新节点到红黑树中，并非简单地添加一个元素。我们必须确保，在操作完成后，红黑树的五条神圣戒律依然被严格遵守。这个过程分为两个阶段：</p>
<ol>
<li><strong>标准BST插入</strong>：首先，我们完全忽略颜色，按照普通二叉搜索树（BST）的规则，为新节点找到合适的位置并将其插入。</li>
<li><strong>修复（Fixup）</strong>：然后，我们通过一系列精妙的<strong>重新着色</strong>和<strong>旋转</strong>操作，来修复因插入新节点而可能被破坏的红黑树性质。</li>
</ol>
<h4 id="21--插入的哲学为何新节点总是红色的"><strong>2.1、 插入的哲学：为何新节点总是红色的？</strong></h4>
<p>在执行标准BST插入后，我们必须为新节点选择一个颜色：红色或黑色。这是一个至关重要的设计决策。</p>
<p><strong>我们总是将新插入的节点着色为 <code>红色</code>。</strong></p>
<p>为什么？让我们来分析一下：</p>
<ul>
<li><strong>如果着色为黑色</strong>：
<ul>
<li>这会立即改变其所在路径的“黑高”（Black-Height）。</li>
<li>从根到该新节点的路径上，会多出一个黑色节点，而其他路径的黑高不变。</li>
<li>这就直接违反了<strong>性质5（路径戒律）</strong>：“对于树中的任意一个节点，从该节点到其所有后代叶子节点的简单路径上，所包含的黑色节点的数量是相同的。”</li>
<li>修复黑高不平衡是一个非常复杂、涉及全树范围的问题，我们希望极力避免。</li>
</ul>
</li>
<li><strong>如果着色为红色</strong>：
<ul>
<li><strong>性质5（路径戒律）</strong> 得到了保证。因为新增一个红色节点不会改变任何路径的黑高。</li>
<li><strong>性质3（叶子戒律）</strong> 保持不变，因为新节点的子节点是黑色的NIL节点。</li>
<li><strong>性质2（根节点戒律）</strong> 可能会被违反。如果插入的是根节点，它会是红色。但这非常容易修复：在整个插入修复过程结束后，直接将根节点强制变为黑色即可。</li>
<li><strong>性质4（红色戒律）</strong> 可能会被违反。如果新插入的红色节点的父节点也是红色的，就会出现“红-红”冲突。</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：将新节点着色为红色，最多只会违反“根节点戒律”和“红色戒律”。前者修复成本极低，而后者（红-红冲突）是一个<strong>局部问题</strong>，可以通过在祖父节点（Grandparent）为根的子树范围内进行旋转和重新着色来解决。这比处理全局的黑高问题要简单得多。</p>
<p>因此，我们的策略是：<strong>用红色插入，然后专注于解决可能出现的“红-红”冲突。</strong></p>
<h4 id="22--插入修复-insert-fixup夹心的艺术"><strong>2.2、 插入修复 (<code>INSERT-FIXUP</code>)：夹心的艺术</strong></h4>
<p>当我们将一个红色节点 <code>z</code> 插入到一个红色父节点 <code>z.p</code> 之下时，就产生了“红-red”冲突。我们的修复算法 <code>RB-INSERT-FIXUP(z)</code> 的目标就是消除这个冲突。</p>
<p>整个修复过程的核心，在于观察新节点 <code>z</code> 的 <strong>叔叔节点（Uncle）</strong> 的颜色。叔叔节点是 <code>z</code> 的父节点的兄弟节点。</p>
<div class="mermaid">graph TD
    subgraph "关键角色"
        G("Grandparent (z.p.p)")
        P("Parent (z.p)")
        U("Uncle (y)")
        Z("New Node (z)")

        G --&gt; P;
        G --&gt; U;
        P --&gt; Z;
    end
</div>
<p>我们的修复是一个循环过程，只要 <code>z</code> 的父节点是红色的，循环就继续。下面是所有可能遇到的情况（我们先以 <code>z</code> 的父节点是其祖父节点的<strong>左孩子</strong>为例进行讨论，右孩子的情况是完全对称的）。</p>
<h5 id="情况1叔叔节点-y-是-红色"><strong>情况1：叔叔节点 <code>y</code> 是 <code>红色</code></strong></h5>
<p>这是最简单的一种情况。我们有一个红色的父节点和红色的叔叔节点。</p>
<p><strong>场景描述</strong>：</p>
<ul>
<li><code>z</code> (新节点) 是 <code>红色</code>。</li>
<li><code>z.p</code> (父节点) 是 <code>红色</code>。(违反性质4)</li>
<li><code>z.p.p</code> (祖父节点) 必须是 <code>黑色</code> (否则在<code>z</code>插入前就已违反性质4)。</li>
<li><code>y</code> (叔叔节点) 是 <code>红色</code>。</li>
</ul>
<div class="mermaid">graph TD
    subgraph "情况1: 叔叔是红色 (操作前)"
        G("Grandparent (B)"):::black --&gt; P("Parent (R)"):::red;
        G --&gt; U("Uncle (R)"):::red;
        P --&gt; Z("z (R)"):::red;
    end
    classDef red fill:#f88,stroke:#333,stroke-width:2px;
    classDef black fill:#666,stroke:#333,stroke-width:2px,color:#fff;
</div>
<p><strong>修复策略：重新着色</strong></p>
<ol>
<li>将 <strong>父节点 <code>z.p</code></strong> 设为 <code>黑色</code>。</li>
<li>将 <strong>叔叔节点 <code>y</code></strong> 设为 <code>黑色</code>。</li>
<li>将 <strong>祖父节点 <code>z.p.p</code></strong> 设为 <code>红色</code>。</li>
</ol>
<div class="mermaid">graph TD
    subgraph "情况1: 叔叔是红色 (操作后)"
        G("Grandparent (R)"):::red --&gt; P("Parent (B)"):::black;
        G --&gt; U("Uncle (B)"):::black;
        P --&gt; Z("z (R)"):::red;
    end
    classDef red fill:#f88,stroke:#333,stroke-width:2px;
    classDef black fill:#666,stroke:#333,stroke-width:2px,color:#fff;
</div>
<p><strong>解读</strong>：这个操作非常巧妙。通过将父和叔染黑，祖父染红，我们解决了当前层级的“红-红”冲突。同时，由于我们将一个黑色节点（祖父）变成了红色，并将其两个子节点（原来是红色）变成了黑色，任何通过祖父节点的路径的黑高都保持不变。</p>
<p><strong>存在的问题</strong>：我们将祖父节点染成了红色。如果祖父节点的父节点也是红色的，那么我们就把“红-红”冲突<strong>向上推移了两层</strong>。因此，我们需要将 <code>z</code> 指向原来的祖父节点 (<code>z = z.p.p</code>)，然后继续循环，在新的 <code>z</code> 节点上检查并修复。</p>
<h5 id="情况2叔叔节点-y-是-黑色-且-z-是一个内侧子节点形成三角形"><strong>情况2：叔叔节点 <code>y</code> 是 <code>黑色</code> 且 <code>z</code> 是一个内侧子节点（形成“三角形”）</strong></h5>
<p><strong>场景描述</strong>：</p>
<ul>
<li><code>z</code> 是 <code>红色</code>。</li>
<li><code>z.p</code> 是 <code>红色</code>。</li>
<li><code>y</code> (叔叔) 是 <code>黑色</code>。</li>
<li><code>z</code> 是其父节点的 <strong>右孩子</strong> (而父节点是祖父节点的左孩子)，形成一个“&lt;”形状的三角。</li>
</ul>
<div class="mermaid">graph TD
    subgraph "情况2: 黑叔叔，三角 (操作前)"
        G("G (B)"):::black --&gt; P("P (R)"):::red;
        G --&gt; U("U (B)"):::black;
        P --&gt; Z("z (R)"):::red;
    end
    classDef red fill:#f88,stroke:#333,stroke-width:2px;
    classDef black fill:#666,stroke:#333,stroke-width:2px,color:#fff;
</div>
<p><strong>修复策略：一次旋转，转化为情况3</strong></p>
<ol>
<li>令 <code>z</code> 指向其父节点 <code>z.p</code>。</li>
<li>对新的 <code>z</code> (也就是旧的父节点) 进行 <strong>左旋 (LEFT-ROTATE)</strong>。</li>
</ol>
<div class="mermaid">graph TD
    subgraph "情况2: 黑叔叔，三角 (操作后)"
        G("G (B)"):::black --&gt; Z("z (R)"):::red;
        G --&gt; U("U (B)"):::black;
        Z --&gt; P("P (R)"):::red;
    end
    classDef red fill:#f88,stroke:#333,stroke-width:2px;
    classDef black fill:#666,stroke:#333,stroke-width:2px,color:#fff;
</div>
<p><strong>解读</strong>：情况2本身并不解决问题，它的唯一目标是通过一次旋转，将“三角形”结构变成“直线”结构，从而无缝地过渡到情况3。现在，新的 <code>z</code> (原来的父节点) 依然和它的父节点 (现在的 <code>z</code>) 是红-红冲突，但它们排列成了一条直线，这正是情况3可以解决的。</p>
<h5 id="情况3叔叔节点-y-是-黑色-且-z-是一个外侧子节点形成直线"><strong>情况3：叔叔节点 <code>y</code> 是 <code>黑色</code> 且 <code>z</code> 是一个外侧子节点（形成“直线”）</strong></h5>
<p><strong>场景描述</strong>：</p>
<ul>
<li><code>z</code> 是 <code>红色</code>。</li>
<li><code>z.p</code> 是 <code>红色</code>。</li>
<li><code>y</code> (叔叔) 是 <code>黑色</code>。</li>
<li><code>z</code> 是其父节点的 <strong>左孩子</strong> (而父节点是祖父节点的左孩子)，形成一条“/”形状的直线。</li>
</ul>
<div class="mermaid">graph TD
    subgraph "情况3: 黑叔叔，直线 (操作前)"
        G("G (B)"):::black --&gt; P("P (R)"):::red;
        G --&gt; U("U (B)"):::black;
        P --&gt; Z("z (R)"):::red;
    end
    classDef red fill:#f88,stroke:#333,stroke-width:2px;
    classDef black fill:#666,stroke:#333,stroke-width:2px,color:#fff;
</div>
<p><strong>修复策略：重新着色 + 一次旋转，终结问题</strong></p>
<ol>
<li>将 <strong>父节点 <code>z.p</code></strong> 设为 <code>黑色</code>。</li>
<li>将 <strong>祖父节点 <code>z.p.p</code></strong> 设为 <code>红色</code>。</li>
<li>对 <strong>祖父节点 <code>z.p.p</code></strong> 进行 <strong>右旋 (RIGHT-ROTATE)</strong>。</li>
</ol>
<div class="mermaid">graph TD
    subgraph "情况3: 黑叔叔，直线 (操作后)"
        P("P (B)"):::black --&gt; Z("z (R)"):::red;
        P --&gt; G("G (R)"):::red;
        G --&gt; U("U (B)"):::black;
    end
    classDef red fill:#f88,stroke:#333,stroke-width:2px;
    classDef black fill:#666,stroke:#333,stroke-width:2px,color:#fff;
</div>
<p><strong>解读</strong>：这是<strong>终结情形</strong>。经过这系列操作后，子树的根（原来的<code>P</code>）变成了黑色，它的两个孩子（<code>z</code>和<code>G</code>）都是红色。这样，新的子树根下不再有红-红冲突。更重要的是，这棵子树的黑高与操作前完全一样（旋转前，根<code>G</code>是黑色；旋转后，根<code>P</code>是黑色），因此它不会影响树的其他部分的性质。<strong>循环在此处终止</strong>。</p>
<h4 id="23--整体算法与代码实现"><strong>2.3、 整体算法与代码实现</strong></h4>
<p>现在我们将上述逻辑整合为完整的算法。</p>
<p><strong>伪代码</strong>：</p>
<div class="code-container"><pre class="hljs"><code>RB-INSERT(T, z)
  // 1. 标准BST插入
  y = T.nil
  x = T.root
  while x != T.nil
    y = x
    if z.key &lt; x.key
      x = x.left
    else
      x = x.right
  z.p = y
  if y == T.nil
    T.root = z
  else if z.key &lt; y.key
    y.left = z
  else
    y.right = z
  
  // 2. 初始化新节点
  z.left = T.nil
  z.right = T.nil
  z.color = RED
  
  // 3. 调用修复程序
  RB-INSERT-FIXUP(T, z)

RB-INSERT-FIXUP(T, z)
  while z.p.color == RED
    if z.p == z.p.p.left // 父节点是左孩子
      y = z.p.p.right   // y是叔叔
      if y.color == RED // 情况1
        z.p.color = BLACK
        y.color = BLACK
        z.p.p.color = RED
        z = z.p.p
      else 
        if z == z.p.right // 情况2
          z = z.p
          LEFT-ROTATE(T, z)
        // 情况3
        z.p.color = BLACK
        z.p.p.color = RED
        RIGHT-ROTATE(T, z.p.p)
    else // 父节点是右孩子 (对称情况)
      y = z.p.p.left    // y是叔叔
      if y.color == RED // 情况1
        z.p.color = BLACK
        y.color = BLACK
        z.p.p.color = RED
        z = z.p.p
      else
        if z == z.p.left // 情况2
          z = z.p
          RIGHT-ROTATE(T, z)
        // 情况3
        z.p.color = BLACK
        z.p.p.color = RED
        LEFT-ROTATE(T, z.p.p)
  
  // 4. 确保根节点是黑色
  T.root.color = BLACK
</code></pre></div>
<p><strong>C++ 完整代码</strong>：</p>
<div class="code-container"><pre class="hljs"><code>// 在上一部分的RedBlackTree类中添加
void insert(int key) {
    // 1. 创建新节点，初始化为红色
    Node* z = new Node(key);
    z-&gt;left = T_NIL;
    z-&gt;right = T_NIL;
    z-&gt;color = RED;

    Node* y = nullptr;
    Node* x = this-&gt;root;

    // 2. 执行标准BST插入
    while (x != T_NIL) {
        y = x;
        if (z-&gt;key &lt; x-&gt;key) {
            x = x-&gt;left;
        } else {
            x = x-&gt;right;
        }
    }

    z-&gt;parent = y;
    if (y == nullptr) {
        root = z;
    } else if (z-&gt;key &lt; y-&gt;key) {
        y-&gt;left = z;
    } else {
        y-&gt;right = z;
    }

    // 如果是第一个节点，直接变黑返回
    if (z-&gt;parent == nullptr) {
        z-&gt;color = BLACK;
        return;
    }
    // 如果父节点是根，也无需修复
    if (z-&gt;parent-&gt;parent == nullptr) {
        return;
    }

    // 3. 调用修复函数
    insertFixup(z);
}

void insertFixup(Node* z) {
    Node* y; // Uncle node
    // 循环条件: 父节点是红色 (z是红色, 产生red-red冲突)
    while (z-&gt;parent-&gt;color == RED) {
        // A. 父节点是祖父节点的右孩子
        if (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;right) {
            y = z-&gt;parent-&gt;parent-&gt;left; // 叔叔在左边
            // 情况1: 叔叔是红色
            if (y-&gt;color == RED) {
                z-&gt;parent-&gt;color = BLACK;
                y-&gt;color = BLACK;
                z-&gt;parent-&gt;parent-&gt;color = RED;
                z = z-&gt;parent-&gt;parent; // 问题上传
            } 
            // 情况2 &amp; 3: 叔叔是黑色
            else {
                // 情况2: z是内侧孩子 (三角形)
                if (z == z-&gt;parent-&gt;left) {
                    z = z-&gt;parent;
                    rightRotate(z);
                }
                // 情况3: z是外侧孩子 (直线)
                z-&gt;parent-&gt;color = BLACK;
                z-&gt;parent-&gt;parent-&gt;color = RED;
                leftRotate(z-&gt;parent-&gt;parent);
            }
        } 
        // B. 父节点是祖父节点的左孩子 (对称)
        else {
            y = z-&gt;parent-&gt;parent-&gt;right; // 叔叔在右边
            // 情况1: 叔叔是红色
            if (y-&gt;color == RED) {
                z-&gt;parent-&gt;color = BLACK;
                y-&gt;color = BLACK;
                z-&gt;parent-&gt;parent-&gt;color = RED;
                z = z-&gt;parent-&gt;parent; // 问题上传
            } 
            // 情况2 &amp; 3: 叔叔是黑色
            else {
                // 情况2: z是内侧孩子 (三角形)
                if (z == z-&gt;parent-&gt;right) {
                    z = z-&gt;parent;
                    leftRotate(z);
                }
                // 情况3: z是外侧孩子 (直线)
                z-&gt;parent-&gt;color = BLACK;
                z-&gt;parent-&gt;parent-&gt;color = RED;
                rightRotate(z-&gt;parent-&gt;parent);
            }
        }
        if (z == root) {
            break; // 到达根节点，循环结束
        }
    }
    // 最后，无条件将根节点设为黑色
    root-&gt;color = BLACK;
}
</code></pre></div>
<h4 id="24--插入实例一步步构建红黑树"><strong>2.4、 插入实例：一步步构建红黑树</strong></h4>
<p>让我们插入序列 <code>[41, 38, 31, 12, 19, 8]</code> 来直观感受一下这个过程。</p>
<ol>
<li><strong>Insert 41</strong>: 作为根节点，初为红色，最后被染黑。
<div class="mermaid">graph TD
    A(41 B):::black
</div>
</li>
<li><strong>Insert 38</strong>: 作为41的左孩子，红色。父节点是黑色，无冲突。
<div class="mermaid">graph TD
    A(41 B):::black --&gt; B(38 R):::red
</div>
</li>
<li><strong>Insert 31</strong>: 作为38的左孩子，红色。父节点38也是红色，<strong>红-红冲突</strong>！
<ul>
<li><code>z=31</code>, <code>p=38</code>, <code>g=41</code>。叔叔是 <code>41</code> 的右孩子 <code>NIL</code>，是黑色。</li>
<li><strong>触发情况3 (直线)</strong>：
<ol>
<li><code>p(38)</code> 变黑。</li>
<li><code>g(41)</code> 变红。</li>
<li>对 <code>g(41)</code> 右旋。</li>
</ol>
</li>
</ul>
<div class="mermaid">graph TD
    subgraph "最终结果"
        B(38 B):::black --&gt; C(31 R):::red
        B --&gt; A(41 R):::red
    end
</div>
</li>
<li><strong>Insert 12</strong>: 作为31的左孩子，红色。父节点31是红色，<strong>红-红冲突</strong>！
<ul>
<li><code>z=12</code>, <code>p=31</code>, <code>g=38</code>。叔叔是 <code>38</code> 的右孩子 <code>41</code>，是红色。</li>
<li><strong>触发情况1</strong>：
<ol>
<li><code>p(31)</code> 变黑。</li>
<li><code>uncle(41)</code> 变黑。</li>
<li><code>g(38)</code> 变红。</li>
</ol>
</li>
<li>此时 <code>z</code> 变为 <code>38</code>。因为 <code>38</code> 是根，循环结束。最后根节点 <code>38</code> 被染黑。</li>
</ul>
<div class="mermaid">graph TD
    subgraph "最终结果"
        B(38 B):::black --&gt; C(31 B):::black
        B --&gt; A(41 B):::black
        C --&gt; D(12 R):::red
    end
</div>
</li>
<li><strong>Insert 19</strong>: 作为12的右孩子，红色。父节点12是红色，<strong>红-红冲突</strong>！
<ul>
<li><code>z=19</code>, <code>p=12</code>, <code>g=31</code>。叔叔是 <code>31</code> 的右孩子 <code>NIL</code>，是黑色。</li>
<li><strong>触发情况2 (三角形)</strong>：
<ol>
<li><code>z</code> 指向 <code>p(12)</code>。</li>
<li>对 <code>z(12)</code> 左旋。树变为 <code>31 -&gt; 19 -&gt; 12</code>。</li>
</ol>
</li>
<li>现在 <code>z=12</code>，<code>p=19</code>，<code>g=31</code>，叔叔是 <code>NIL</code> (黑)。<strong>转化为情况3 (直线)</strong>：
<ol>
<li><code>p(19)</code> 变黑。</li>
<li><code>g(31)</code> 变红。</li>
<li>对 <code>g(31)</code> 右旋。</li>
</ol>
</li>
</ul>
<div class="mermaid">graph TD
    subgraph "最终结果"
        B(38 B):::black --&gt; C(19 B):::black
        B --&gt; A(41 B):::black
        C --&gt; D(12 R):::red
        C --&gt; E(31 R):::red
    end
</div>
</li>
<li><strong>Insert 8</strong>: 作为12的左孩子，红色。父节点12是红色，<strong>红-红冲突</strong>！
<ul>
<li><code>z=8</code>, <code>p=12</code>, <code>g=19</code>。叔叔是 <code>19</code> 的右孩子 <code>31</code>，是红色。</li>
<li><strong>触发情况1</strong>：
<ol>
<li><code>p(12)</code> 变黑。</li>
<li><code>uncle(31)</code> 变黑。</li>
<li><code>g(19)</code> 变红。</li>
</ol>
</li>
<li>此时 <code>z</code> 变为 <code>19</code>。<code>19</code> 的父节点是 <code>38</code> (黑色)，无冲突，循环结束。</li>
</ul>
<div class="mermaid">graph TD
    subgraph "最终结果"
        B(38 B):::black --&gt; C(19 R):::red
        B --&gt; A(41 B):::black
        C --&gt; D(12 B):::black
        C --&gt; E(31 B):::black
        D --&gt; F(8 R):::red
    end
</div>
</li>
</ol>
<h3 id="第三部分红黑树的删除操作与双黑修复"><strong>第三部分：红黑树的删除操作与双黑修复</strong></h3>
<p>删除操作比插入操作要复杂得多。根本原因在于，删除一个<strong>黑色</strong>节点会直接破坏<strong>性质5（路径戒律）</strong>，导致某些路径的黑高减少，从而引发树的结构性失衡。我们的修复算法必须想办法弥补这个“丢失的黑色”。</p>
<p>整个删除过程可以分为三个阶段：</p>
<ol>
<li><strong>标准BST删除</strong>：和插入一样，我们首先按照普通二-叉搜索树的规则找到要删除的节点，并将其从树中移除。</li>
<li><strong>定位问题</strong>：确定哪个节点（替代者）和哪种颜色（被删除节点的颜色）是导致问题的根源。</li>
<li><strong>修复（Fixup）</strong>：如果被删除的节点是黑色的，启动一个修复程序 <code>RB-DELETE-FIXUP</code>，通过一系列重新着色和旋转来恢复红黑树的性质。</li>
</ol>
<h4 id="31--辅助工具transplant-移植函数"><strong>3.1、 辅助工具：<code>TRANSPLANT</code> 移植函数</strong></h4>
<p>在现代红黑树的实现中（如CLRS教科书中所述），我们通常使用一个辅助函数 <code>TRANSPLANT</code> 来优雅地处理节点替换。这个函数用一棵子树 <code>v</code> 来替换另一棵子树 <code>u</code>，并正确处理其父节点的指针。</p>
<p><strong>功能</strong>：用节点 <code>v</code> 替换节点 <code>u</code>。</p>
<div class="mermaid">graph TD
    subgraph "Transplant(u, v) 之前"
        P --&gt; u;
        u --&gt; L;
        u --&gt; R;
        ... --&gt; v;
    end

    subgraph "Transplant(u, v) 之后"
        P --&gt; v;
        ...;
        u; L; R;
    end
</div>
<p><strong>伪代码</strong>：</p>
<div class="code-container"><pre class="hljs"><code>RB-TRANSPLANT(T, u, v)
  if u.p == T.nil
    T.root = v
  else if u == u.p.left
    u.p.left = v
  else
    u.p.right = v
  v.p = u.p // 即使 v 是 T.nil, 它的父指针也要设置
</code></pre></div>
<p><strong>C++ 实现</strong>：</p>
<div class="code-container"><pre class="hljs"><code>// 在 RedBlackTree 类中
void transplant(Node* u, Node* v) {
    if (u-&gt;parent == nullptr) {
        root = v;
    } else if (u == u-&gt;parent-&gt;left) {
        u-&gt;parent-&gt;left = v;
    } else {
        u-&gt;parent-&gt;right = v;
    }
    v-&gt;parent = u-&gt;parent;
}
</code></pre></div>
<p><strong>解读</strong>：<code>TRANSPLANT</code> 函数本身并不关心颜色或子树结构，它只负责“指针的重新连接”。这是后续删除逻辑的一个干净的抽象。注意，它处理了 <code>u</code> 是根节点的边界情况，并且正确设置了 <code>v</code> 的父指针。</p>
<h4 id="32--删除的主体逻辑-rb-delete"><strong>3.2、 删除的主体逻辑 <code>RB-DELETE</code></strong></h4>
<p>和标准的BST删除一样，我们需要处理三种情况：</p>
<ol>
<li>要删除的节点 <code>z</code> 没有子节点：直接删除。</li>
<li><code>z</code> 只有一个子节点：用其子节点替换 <code>z</code>。</li>
<li><code>z</code> 有两个子节点：找到 <code>z</code> 的<strong>中序后继</strong>（in-order successor） <code>y</code>（也就是 <code>z</code> 右子树中的最小节点），用 <code>y</code> 的值替换 <code>z</code> 的值，然后问题转化为删除节点 <code>y</code>。由于 <code>y</code> 是其子树的最小值，<code>y</code> 最多只有一个右孩子，所以这又回到了情况1或2。</li>
</ol>
<p>在红黑树中，我们采用一种更直接的方式：</p>
<ul>
<li>我们确定实际要从树中断开连接的节点，称之为 <code>y</code>。如果 <code>z</code> 最多只有一个孩子，则 <code>y</code> 就是 <code>z</code>。如果 <code>z</code> 有两个孩子，则 <code>y</code> 是 <code>z</code> 的中序后继。</li>
<li>我们用一个节点 <code>x</code> 来顶替 <code>y</code> 的位置。<code>x</code> 是 <code>y</code> 的唯一孩子或 <code>T_NIL</code>。</li>
<li><strong>关键点</strong>：我们记录下 <code>y</code> 的<strong>原始颜色</strong>。如果这个颜色是<strong>黑色</strong>，那么树的平衡就被打破了，因为所有经过 <code>y</code> 的路径都少了一个黑色节点。此时，<code>x</code> 节点就继承了这个“黑色的空缺”，我们称 <code>x</code> 为“<strong>双重黑色（Double Black）</strong>”或“<strong>额外黑色（Extra Black）</strong>”。</li>
</ul>
<p><strong>伪代码</strong>：</p>
<div class="code-container"><pre class="hljs"><code>RB-DELETE(T, z)
  y = z
  y_original_color = y.color
  if z.left == T.nil
    x = z.right
    RB-TRANSPLANT(T, z, z.right)
  else if z.right == T.nil
    x = z.left
    RB-TRANSPLANT(T, z, z.left)
  else
    y = TREE-MINIMUM(z.right) // y是z的后继
    y_original_color = y.color
    x = y.right
    if y.p == z
      x.p = y // 特殊情况: y是z的直接子节点
    else
      RB-TRANSPLANT(T, y, y.right)
      y.right = z.right
      y.right.p = y
    RB-TRANSPLANT(T, z, y)
    y.left = z.left
    y.left.p = y
    y.color = z.color

  if y_original_color == BLACK
    RB-DELETE-FIXUP(T, x)
</code></pre></div>
<h4 id="33--删除修复-delete-fixup双黑问题的四种解法"><strong>3.3、 删除修复 (<code>DELETE-FIXUP</code>)：双黑问题的四种解法</strong></h4>
<p>当 <code>y</code> 的原始颜色是黑色时，节点 <code>x</code> 就带上了一层“额外黑色”。我们的目标就是通过一系列操作，将这个额外黑色要么吸收掉，要么沿着树向上传递，直到根节点，或者被一个红色节点吸收。</p>
<p>修复过程是一个循环，只要 <code>x</code> 不是根且 <code>x</code> 的颜色是黑色（这里指<code>x</code>本身是黑色节点，并且还带着“额外黑色”的属性），循环就继续。在循环中，我们关注 <code>x</code> 的 <strong>兄弟节点 <code>w</code></strong> 的情况。</p>
<p>（我们假设 <code>x</code> 是其父节点的<strong>左孩子</strong>，右孩子的情况完全对称）</p>
<h5 id="情况1x-的兄弟-w-是-红色"><strong>情况1：<code>x</code> 的兄弟 <code>w</code> 是 <code>红色</code></strong></h5>
<p><strong>场景描述</strong>：<code>x</code> 是双黑，其兄弟 <code>w</code> 是红色。由于 <code>w</code> 是红色，<code>w</code> 的父节点和子节点必须是黑色。</p>
<div class="mermaid">graph TD
    subgraph "情况1: 红色兄弟 (操作前)"
        style P fill:#666,color:#fff
        style w fill:#f88
        style x fill:#333,stroke:#0ff,stroke-width:3px,color:#fff
        P("P (B/R)") --&gt; x("x (DB)");
        P --&gt; w("w (R)");
        w --&gt; w_L("C (B)")
        w --&gt; w_R("D (B)")
    end
</div>
<p><strong>修复策略：变色+旋转，转化为情况2、3或4</strong></p>
<ol>
<li>将兄弟 <code>w</code> 设为 <strong>黑色</strong>。</li>
<li>将父节点 <code>P</code> 设为 <strong>红色</strong>。</li>
<li>对父节点 <code>P</code> 进行 <strong>左旋 (LEFT-ROTATE)</strong>。</li>
<li>旋转后，<code>x</code> 的新兄弟是 <code>w</code> 的一个黑色子节点。</li>
</ol>
<div class="mermaid">graph TD
    subgraph "情况1: 红色兄弟 (操作后)"
        style w fill:#666,color:#fff
        style P fill:#f88
        style x fill:#333,stroke:#0ff,stroke-width:3px,color:#fff
        w("w (B)") --&gt; P("P (R)");
        w --&gt; w_R("D (B)");
        P --&gt; x("x (DB)");
        P --&gt; w_L("C (B)");
    end
</div>
<p><strong>解读</strong>：此操作的目的是改变局部结构，使得 <code>x</code> 的新兄弟节点变成黑色，从而将问题转化为后续更容易处理的情况。注意，这个操作保持了子树的黑高不变，但 <code>x</code> 的“双黑”问题依然存在，只是它的“环境”变了。</p>
<h5 id="情况2x-的兄弟-w-是-黑色且-w-的两个孩子都是-黑色"><strong>情况2：<code>x</code> 的兄弟 <code>w</code> 是 <code>黑色</code>，且 <code>w</code> 的两个孩子都是 <code>黑色</code></strong></h5>
<p><strong>场景描述</strong>：<code>x</code> 是双黑，其兄弟 <code>w</code> 是黑色，<code>w</code> 的孩子也都是黑色。</p>
<div class="mermaid">graph TD
    subgraph "情况2: 黑色兄弟, 黑色侄子 (操作前)"
        style P,w,w_L,w_R fill:#666,color:#fff
        style x fill:#333,stroke:#0ff,stroke-width:3px,color:#fff
        P("P (B/R)") --&gt; x("x (DB)");
        P --&gt; w("w (B)");
        w --&gt; w_L("C (B)")
        w --&gt; w_R("D (B)")
    end
</div>
<p><strong>修复策略：向上移交问题</strong></p>
<ol>
<li>将兄弟 <code>w</code> 设为 <strong>红色</strong>。</li>
<li>将 <code>x</code> 指向其父节点 <code>P</code>。</li>
</ol>
<div class="mermaid">graph TD
    subgraph "情况2: 黑色兄弟, 黑色侄子 (操作后)"
        style P,w_L,w_R fill:#666,color:#fff
        style w fill:#f88
        style P stroke:#0ff,stroke-width:3px
        P("P (New DB)") --&gt; x("x (B)");
        P --&gt; w("w (R)");
        w --&gt; w_L("C (B)")
        w --&gt; w_R("D (B)")
    end
</div>
<p><strong>解读</strong>：这是唯一一个将问题向上传递的情况。我们可以这样理解：<code>x</code> 的“额外黑色”和 <code>w</code> 的“黑色”合并到了父节点 <code>P</code> 上。我们成功解决了 <code>x</code> 所在子树的黑高问题（通过将<code>w</code>变红，<code>P-w</code>路径的黑高减一，与<code>P-x</code>路径平衡），但代价是父节点 <code>P</code> 成为了新的“双黑”节点。循环将从 <code>P</code> 开始继续。</p>
<h5 id="情况3x-的兄弟-w-是-黑色w-的左孩子是-红色右孩子是-黑色"><strong>情况3：<code>x</code> 的兄弟 <code>w</code> 是 <code>黑色</code>，<code>w</code> 的左孩子是 <code>红色</code>，右孩子是 <code>黑色</code></strong></h5>
<p><strong>场景描述</strong>：<code>x</code> 是双黑，兄弟 <code>w</code> 是黑，内侧侄子是红，外侧侄子是黑。（三角形）</p>
<div class="mermaid">graph TD
    subgraph "情况3: 黑兄弟, 内红外黑侄子 (操作前)"
        style P,w,w_R fill:#666,color:#fff
        style w_L fill:#f88
        style x fill:#333,stroke:#0ff,stroke-width:3px,color:#fff
        P("P (B/R)") --&gt; x("x (DB)");
        P --&gt; w("w (B)");
        w --&gt; w_L("C (R)")
        w --&gt; w_R("D (B)")
    end
</div>
<p><strong>修复策略：变色+旋转，转化为情况4</strong></p>
<ol>
<li>将 <code>w</code> 的左孩子 <code>C</code> 设为 <strong>黑色</strong>。</li>
<li>将兄弟 <code>w</code> 设为 <strong>红色</strong>。</li>
<li>对兄弟 <code>w</code> 进行 <strong>右旋 (RIGHT-ROTATE)</strong>。</li>
<li>旋转后，<code>x</code> 的新兄弟是 <code>C</code>，它有一个红色的右孩子 (<code>w</code>)。</li>
</ol>
<div class="mermaid">graph TD
    subgraph "情况3: 黑兄弟, 内红外黑侄子 (操作后)"
        style P,w_L,w_R fill:#666,color:#fff
        style w fill:#f88
        style x fill:#333,stroke:#0ff,stroke-width:3px,color:#fff
        P("P (B/R)") --&gt; x("x (DB)");
        P --&gt; w_L("C (B)");
        w_L --&gt; w("w (R)");
        w --&gt; w_R("D (B)");
    end
</div>
<p><strong>解读</strong>：和插入操作类似，情况3是一个过渡状态。它的目标是通过一次旋转，将“红色”节点移动到外侧，从而创造出情况4的条件，为最终解决问题做准备。</p>
<h5 id="情况4x-的兄弟-w-是-黑色且-w-的右孩子是-红色"><strong>情况4：<code>x</code> 的兄弟 <code>w</code> 是 <code>黑色</code>，且 <code>w</code> 的右孩子是 <code>红色</code></strong></h5>
<p><strong>场景描述</strong>：<code>x</code> 是双黑，兄弟 <code>w</code> 是黑，外侧侄子是红。（直线）</p>
<div class="mermaid">graph TD
    subgraph "情况4: 黑兄弟, 外红侄子 (操作前)"
        style P,w fill:#666,color:#fff
        style w_R fill:#f88
        style x fill:#333,stroke:#0ff,stroke-width:3px,color:#fff
        P("P (B/R)") --&gt; x("x (DB)");
        P --&gt; w("w (B)");
        w --&gt; w_L("C (B/R)")
        w --&gt; w_R("D (R)")
    end
</div>
<p><strong>修复策略：变色+旋转，终结问题</strong></p>
<ol>
<li>将兄弟 <code>w</code> 的颜色设为 <strong>父节点 <code>P</code> 的颜色</strong>。</li>
<li>将父节点 <code>P</code> 设为 <strong>黑色</strong>。</li>
<li>将 <code>w</code> 的红色右孩子 <code>D</code> 设为 <strong>黑色</strong>。</li>
<li>对父节点 <code>P</code> 进行 <strong>左旋 (LEFT-ROTATE)</strong>。</li>
<li>将 <code>x</code> 指向根节点，强制终止循环。</li>
</ol>
<div class="mermaid">graph TD
    subgraph "情况4: 黑兄弟, 外红侄子 (操作后)"
        style w_P_color fill:#666,color:#fff
        style P,w_R fill:#666,color:#fff
        style x fill:#666,color:#fff
        
        w_P_color("w (P's color)") --&gt; P("P (B)");
        w_P_color --&gt; w_R("D (B)");
        P --&gt; x("x (B)");
        P --&gt; w_L("C (B/R)");
    end
</div>
<p><strong>解读</strong>：这是<strong>终结情形</strong>。这个组合操作一举解决了所有问题。<code>x</code> 的“额外黑色”被彻底吸收。通过将 <code>w</code> 染成父节点原来的颜色，并将父节点染黑，我们补偿了 <code>P-x</code> 路径上丢失的那个黑色。同时，通过将 <code>w</code> 的红色孩子染黑，保证了 <code>P-w</code> 路径的黑高也不变。左旋操作完成了对树结构的最终平衡。至此，红黑性质全部恢复，循环可以结束。</p>
<h4 id="34--删除代码实现"><strong>3.4、 删除代码实现</strong></h4>
<div class="code-container"><pre class="hljs"><code>// 在 RedBlackTree 类中

// 辅助函数：找到子树的最小节点
Node* treeMinimum(Node* node) {
    while (node-&gt;left != T_NIL) {
        node = node-&gt;left;
    }
    return node;
}

// 删除主函数
void remove(int key) {
    Node* z = find(key);
    if (z == T_NIL) {
        return; // Key not found
    }

    Node* y = z;
    Node* x;
    Color y_original_color = y-&gt;color;

    if (z-&gt;left == T_NIL) {
        x = z-&gt;right;
        transplant(z, z-&gt;right);
    } else if (z-&gt;right == T_NIL) {
        x = z-&gt;left;
        transplant(z, z-&gt;left);
    } else {
        y = treeMinimum(z-&gt;right);
        y_original_color = y-&gt;color;
        x = y-&gt;right;
        if (y-&gt;parent == z) {
            x-&gt;parent = y; // Crucial for when x is T_NIL
        } else {
            transplant(y, y-&gt;right);
            y-&gt;right = z-&gt;right;
            y-&gt;right-&gt;parent = y;
        }
        transplant(z, y);
        y-&gt;left = z-&gt;left;
        y-&gt;left-&gt;parent = y;
        y-&gt;color = z-&gt;color;
    }
    delete z;

    if (y_original_color == BLACK) {
        deleteFixup(x);
    }
}

// 删除修复函数
void deleteFixup(Node* x) {
    Node* w; // Sibling
    while (x != root &amp;&amp; x-&gt;color == BLACK) {
        // x is left child
        if (x == x-&gt;parent-&gt;left) {
            w = x-&gt;parent-&gt;right;
            // Case 1: Sibling w is red
            if (w-&gt;color == RED) {
                w-&gt;color = BLACK;
                x-&gt;parent-&gt;color = RED;
                leftRotate(x-&gt;parent);
                w = x-&gt;parent-&gt;right; // New sibling
            }
            // Case 2: Sibling w is black, and both its children are black
            if (w-&gt;left-&gt;color == BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK) {
                w-&gt;color = RED;
                x = x-&gt;parent; // Move up
            } else {
                // Case 3: Sibling w is black, left child is red, right is black
                if (w-&gt;right-&gt;color == BLACK) {
                    w-&gt;left-&gt;color = BLACK;
                    w-&gt;color = RED;
                    rightRotate(w);
                    w = x-&gt;parent-&gt;right; // New sibling
                }
                // Case 4: Sibling w is black, right child is red
                w-&gt;color = x-&gt;parent-&gt;color;
                x-&gt;parent-&gt;color = BLACK;
                w-&gt;right-&gt;color = BLACK;
                leftRotate(x-&gt;parent);
                x = root; // Problem solved, terminate
            }
        } 
        // x is right child (symmetric cases)
        else {
            w = x-&gt;parent-&gt;left;
            // Case 1
            if (w-&gt;color == RED) {
                w-&gt;color = BLACK;
                x-&gt;parent-&gt;color = RED;
                rightRotate(x-&gt;parent);
                w = x-&gt;parent-&gt;left;
            }
            // Case 2
            if (w-&gt;right-&gt;color == BLACK &amp;&amp; w-&gt;left-&gt;color == BLACK) {
                w-&gt;color = RED;
                x = x-&gt;parent;
            } else {
                // Case 3
                if (w-&gt;left-&gt;color == BLACK) {
                    w-&gt;right-&gt;color = BLACK;
                    w-&gt;color = RED;
                    leftRotate(w);
                    w = x-&gt;parent-&gt;left;
                }
                // Case 4
                w-&gt;color = x-&gt;parent-&gt;color;
                x-&gt;parent-&gt;color = BLACK;
                w-&gt;left-&gt;color = BLACK;
                rightRotate(x-&gt;parent);
                x = root;
            }
        }
    }
    x-&gt;color = BLACK; // Ensure property 2 (root is black)
}
</code></pre></div>
<h3 id="第四部分全景视图-实现与深度思考"><strong>第四部分：全景视图、实现与深度思考</strong></h3>
<h4 id="41--补全操作修改与遍历"><strong>4.1、 补全操作：修改与遍历</strong></h4>
<p>虽然我们已经覆盖了最复杂的操作，但为了完整性，我们还需要讨论另外两个基本操作。</p>
<h5 id="411-遍历-traversal"><strong>4.1.1 遍历 (Traversal)</strong></h5>
<p>由于红黑树本质上是一棵二叉搜索树，它的遍历操作与标准BST完全相同。最常用的是<strong>中序遍历（In-order Traversal）</strong>，因为它会按键值的升序访问所有节点。</p>
<ul>
<li><strong>中序遍历 (In-order)</strong>: 左子树 -&gt; 根 -&gt; 右子树 (得到有序序列)</li>
<li><strong>前序遍历 (Pre-order)</strong>: 根 -&gt; 左子树 -&gt; 右子树</li>
<li><strong>后序遍历 (Post-order)</strong>: 左子树 -&gt; 右子树 -&gt; 根</li>
</ul>
<p><strong>伪代码 (中序遍历)</strong></p>
<div class="code-container"><pre class="hljs"><code>INORDER-TREE-WALK(x)
  if x != T.nil
    INORDER-TREE-WALK(x.left)
    print x.key
    INORDER-TREE-WALK(x.right)
</code></pre></div>
<p><strong>C++ 实现</strong></p>
<div class="code-container"><pre class="hljs"><code>// 在 RedBlackTree 类中添加一个公共的启动函数
void inorder() {
    _inorder(this-&gt;root);
}

private:
// 和一个私有的递归辅助函数
void _inorder(Node* node) {
    if (node != T_NIL) {
        _inorder(node-&gt;left);
        std::cout &lt;&lt; node-&gt;key &lt;&lt; " ";
        _inorder(node-&gt;right);
    }
}
</code></pre></div>
<h5 id="412-修改-modificationupdate"><strong>4.1.2 修改 (Modification/Update)</strong></h5>
<p>一个非常重要但经常被忽略的问题是：如何修改红黑树中一个节点的键值？</p>
<p><strong>绝对禁止</strong>直接修改一个节点 <code>x</code> 的 <code>key</code> 值 (<code>x-&gt;key = new_value</code>)。这样做几乎肯定会破坏二叉搜索树的性质（左子&lt;根&lt;右子），而红黑树的所有操作都依赖于这个基本性质。</p>
<p>正确的做法是：</p>
<ol>
<li><strong>删除 (Delete)</strong> 带有旧键值的节点。</li>
<li><strong>插入 (Insert)</strong> 一个带有新键值的新节点。</li>
</ol>
<p>这是一个 <code>Delete</code> + <code>Insert</code> 的组合操作，其时间复杂度为 $O(\log n) + O(\log n) = O(\log n)$。</p>
<h4 id="42--红黑树-vs-avl树"><strong>4.2、 红黑树 vs. AVL树</strong></h4>
<p>红黑树并非唯一的自平衡二叉搜索树。它最常被拿来与<strong>AVL树</strong>进行比较。两者的选择体现了在不同应用场景下的性能权衡。</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left"><strong>AVL树</strong></th>
<th style="text-align:left"><strong>红黑树</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>平衡条件</strong></td>
<td style="text-align:left"><strong>极其严格</strong>：任何节点的左右子树高度差<strong>不能超过1</strong>。</td>
<td style="text-align:left"><strong>相对宽松</strong>：通过5条颜色性质间接约束，最长路径不超过最短路径的<strong>2倍</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>查询性能</strong></td>
<td style="text-align:left"><strong>更快</strong>。由于树的高度更低、更平衡，理论上和实践中的平均查找次数都更少。</td>
<td style="text-align:left"><strong>稍慢</strong>。树可能没有AVL树那么“矮胖”，查询路径可能稍长。</td>
</tr>
<tr>
<td style="text-align:left"><strong>插入/删除性能</strong></td>
<td style="text-align:left"><strong>较慢</strong>。为了维持严格的平衡，插入和删除可能需要进行多次（最坏情况下 $O(\log n)$ 次）旋转。</td>
<td style="text-align:left"><strong>更快</strong>。插入最多需要<strong>2次</strong>旋转，删除最多需要<strong>3次</strong>旋转。重新着色的开销远小于旋转。</td>
</tr>
<tr>
<td style="text-align:left"><strong>空间开销</strong></td>
<td style="text-align:left">每个节点需要存储一个平衡因子（通常是 <code>int</code>，-1, 0, 1）。</td>
<td style="text-align:left">每个节点只需要存储1比特的颜色信息（<code>bool</code> 或 <code>enum</code>）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>适用场景</strong></td>
<td style="text-align:left"><strong>查询密集型</strong>应用，即插入和删除不频繁，但查找非常频繁的场景。</td>
<td style="text-align:left"><strong>写密集型</strong>应用，即插入和删除操作很频繁的场景，如C++ STL的<code>map</code>、<code>set</code>，Java的<code>TreeMap</code>，Linux内核。</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>：没有绝对的“最佳”数据结构，只有“最适合”的。红黑树的胜利在于它在“写操作”和“读操作”之间找到了一个绝佳的平衡点。它牺牲了部分查询性能（但仍然是 $O(\log n)$ 级别），换来了显著更快的插入和删除效率，这使其在通用库和底层系统实现中更受欢迎。</p>
<h4 id="43--完整的c实现"><strong>4.3、 完整的C++实现</strong></h4>
<p>下面是一个将我们之前所有部分代码整合起来的、可编译运行的完整红黑树实现。</p>
<div class="code-container"><pre class="hljs"><code>#include &lt;iostream&gt;

// 节点颜色
enum Color { RED, BLACK };

// 节点定义
struct Node {
    int key;
    Color color;
    Node *parent, *left, *right;
};

// 红黑树类
class RedBlackTree {
private:
    Node* root;
    Node* T_NIL;

    // ... (所有私有辅助函数: leftRotate, rightRotate, insertFixup, deleteFixup, transplant, treeMinimum, _inorder等)
    void leftRotate(Node* x) { /* ... 代码来自第一部分 ... */ }
    void rightRotate(Node* y) { /* ... 代码来自第一部分 ... */ }
    void insertFixup(Node* z) { /* ... 代码来自第二部分 ... */ }
    void deleteFixup(Node* x) { /* ... 代码来自第三部分 ... */ }
    void transplant(Node* u, Node* v) { /* ... 代码来自第三部分 ... */ }
    Node* treeMinimum(Node* node) { /* ... 代码来自第三部分 ... */ }
    
    void _inorder(Node* node) {
        if (node != T_NIL) {
            _inorder(node-&gt;left);
            std::cout &lt;&lt; node-&gt;key &lt;&lt; "(" &lt;&lt; (node-&gt;color == RED ? "R" : "B") &lt;&lt; ") ";
            _inorder(node-&gt;right);
        }
    }

public:
    RedBlackTree() {
        T_NIL = new Node;
        T_NIL-&gt;color = BLACK;
        T_NIL-&gt;left = nullptr;
        T_NIL-&gt;right = nullptr;
        root = T_NIL;
    }

    Node* find(int key) {
        Node* current = root;
        while (current != T_NIL &amp;&amp; key != current-&gt;key) {
            if (key &lt; current-&gt;key) {
                current = current-&gt;left;
            } else {
                current = current-&gt;right;
            }
        }
        return current;
    }

    void insert(int key) { /* ... 代码来自第二部分 ... */ }
    void remove(int key) { /* ... 代码来自第三部分 ... */ }

    void inorder() {
        _inorder(this-&gt;root);
        std::cout &lt;&lt; std::endl;
    }

    // (为方便演示，可以添加打印树结构的函数)
};

// Note: 为了简洁，这里省略了已在前面部分提供的函数体。
// 实际使用时需将之前各部分的代码填充到相应位置。
// 同样需要实现析构函数来释放所有节点内存，防止内存泄漏。

int main() {
    RedBlackTree rbt;
    rbt.insert(41);
    rbt.insert(38);
    rbt.insert(31);
    rbt.insert(12);
    rbt.insert(19);
    rbt.insert(8);

    std::cout &lt;&lt; "After insertion sequence: ";
    rbt.inorder(); // 8(R) 12(B) 19(R) 31(B) 38(B) 41(B) 

    rbt.remove(38);
    rbt.remove(12);
    rbt.remove(19);

    std::cout &lt;&lt; "After some deletions: ";
    rbt.inorder(); // 8(R) 31(B) 41(B) 

    return 0;
}
</code></pre></div>
<h4 id="44--实质性的-有难度的思考型问题"><strong>4.4、 实质性的、有难度的思考型问题</strong></h4>
<p>挑战一些更深层次的问题了，这些问题将迫使你超越具体的实现，从更高维度思考数据结构的设计与扩展。</p>
<p><strong>问题1：数据结构的增强 (Augmentation)</strong><br>
如何对红黑树进行增强，使其能够在 $O(\log n)$ 时间内完成 <code>OS-SELECT(k)</code> 操作（即查找树中第k小的元素）？你需要为节点增加什么额外的信息？在旋转、插入和删除修复过程中，你又该如何维护这些信息？</p>
<p><strong>问题2：证明操作的复杂度边界</strong><br>
在我们的讨论中，我们提到插入最多需要2次旋转，删除最多需要3次旋转。请你严格地、分情况地证明这个结论。</p>
<ul>
<li><strong>插入</strong>：为什么当遇到“情况3”（黑叔叔，直线型）时，问题就一定能被解决，而不会像“情况1”那样继续向上传播？</li>
<li><strong>删除</strong>：分析 <code>DELETE-FIXUP</code> 的所有情况，证明为什么旋转的总次数不会超过3次。</li>
</ul>
<p><strong>问题3：持久化数据结构 (Persistent Data Structures)</strong><br>
设想你需要一个“可回溯”的红黑树。也就是说，每次进行插入或删除操作后，你希望能保留操作前的旧版本，并获得一个操作后的新版本，同时尽可能地复用节点以节省空间。这就是<strong>持久化红黑树</strong>。<br>
请描述实现持久化红黑树的核心思想（提示：路径复制 Path Copying）。在进行一次插入操作时，需要新建多少个节点？为什么它的空间和时间复杂度依然是 $O(\log n)$？</p>
<p><strong>问题4：红黑树与2-3-4树的等价性</strong><br>
红黑树与B树家族中的<strong>2-3-4树</strong>存在着一种深刻的同构（isomorphism）关系。一个2-3-4树可以唯一地映射为一棵红黑树，反之亦然。<br>
请描述这种映射关系。一个“3-节点”（包含两个键）和一个“4-节点”（包含三个键）在红黑树中对应什么样的结构？理解了这种关系后，红黑树的插入修复操作（特别是颜色翻转）是否有了更直观的解释？</p>
<p><strong>问题5：并发环境下的挑战 (Concurrency)</strong><br>
在多线程环境中，如何设计一个线程安全的红黑树？</p>
<ul>
<li>简单的“全局锁”会严重影响性能。请设想一种更细粒度的锁策略（例如，对节点加锁）。</li>
<li>在进行旋转操作时，你需要同时锁定哪些节点以保证操作的原子性？<code>A-&gt;B-&gt;C</code> 变成 <code>B-&gt;A, B-&gt;C</code> 至少需要锁定A, B, C三个节点。</li>
<li>这种细粒度锁策略可能会遇到什么问题（例如，死锁）？你如何解决？</li>
</ul>
<h3 id="第五部分五个核心问题的解答"><strong>第五部分：五个核心问题的解答</strong></h3>
<h4 id="问题1增强红黑树以支持顺序统计-order-statistic-tree"><strong>问题1：增强红黑树以支持顺序统计 (Order-Statistic Tree)</strong></h4>
<p><strong>问题</strong>：如何对红黑树进行增强，使其能够在 $O(\log n)$ 时间内完成 <code>OS-SELECT(k)</code> 操作（即查找树中第k小的元素）？你需要为节点增加什么额外的信息？在旋转、插入和删除修复过程中，你又该如何维护这些信息？</p>
<p><strong>解答</strong>：</p>
<p>这是一个经典的数据结构增强（Augmentation）问题。核心思想是在不破坏数据结构原有性质和时间复杂度的前提下，为其增加新的功能。</p>
<p><strong>1. 增加的额外信息</strong></p>
<p>我们在每个节点 <code>x</code> 中增加一个属性：<code>x.size</code>。该属性存储以 <code>x</code> 为根的子树中的<strong>节点总数</strong>（包括 <code>x</code> 自身）。<br>
<code>x.size</code> 的计算公式为：<br>
<code>x.size = x.left.size + x.right.size + 1</code><br>
对于哨兵节点 <code>T_NIL</code>，我们定义 <code>T_NIL.size = 0</code>。</p>
<p><strong>2. 维护 <code>size</code> 属性</strong></p>
<p>我们必须保证在所有修改树结构的操作（插入、删除、旋转）中，<code>size</code> 属性都能被正确维护。</p>
<ul>
<li><strong>插入 (<code>INSERT</code>)</strong><br>
在从根节点向下查找插入位置的过程中，路径上经过的每一个节点的 <code>size</code> 都必须加1。插入新节点 <code>z</code> 后，设置 <code>z.size = 1</code>。在后续的 <code>INSERT-FIXUP</code> 过程中，只有旋转会改变子树的结构，因此我们只需要在旋转后更新相关节点的 <code>size</code>。</li>
<li><strong>删除 (<code>DELETE</code>)</strong><br>
与插入类似，在查找并删除节点后，从被删除节点的位置开始，向上回溯至根节点，将路径上所有节点的 <code>size</code> 减1。同样，在 <code>DELETE-FIXUP</code> 过程中的旋转操作需要特殊处理。</li>
<li><strong>旋转 (<code>ROTATION</code>)</strong><br>
旋转是维护 <code>size</code> 属性的关键。假设我们对 <code>x</code> 进行左旋，其右孩子为 <code>y</code>。
<div class="mermaid">graph TD
    subgraph "左旋前"
        P --&gt; x;
        x --&gt; a("α");
        x --&gt; y;
        y --&gt; b("β");
        y --&gt; c("γ");
    end

    subgraph "左旋后"
        P --&gt; y;
        y --&gt; x;
        y --&gt; c;
        x --&gt; a;
        x --&gt; b;
    end
</div>
<p>旋转后，<code>x</code> 和 <code>y</code> 的父子关系改变，它们的 <code>size</code> 也必须更新。其他节点的 <code>size</code> 不受影响。</p>
<ul>
<li><code>y</code> 成为了新的根，它的子树现在包含了原来 <code>x</code> 的整个子树。</li>
<li><code>x</code> 成为了 <code>y</code> 的左孩子，它失去了 <code>y</code> 及其右子树 <code>γ</code>，但获得了 <code>y</code> 的左子树 <code>β</code>。</li>
</ul>
<p>更新的顺序至关重要（先更新子节点，再更新父节点）：<br>
<strong><code>LEFT-ROTATE(x)</code> 的 <code>size</code> 维护:</strong></p>
<div class="code-container"><pre class="hljs"><code>y = x.right
// ... 执行旋转的指针操作 ...
// 更新 size
y.size = x.size  // y 成为新的根，继承 x 的总 size
x.size = x.left.size + x.right.size + 1 // x 的新 size 基于其新孩子
</code></pre></div>
<p><strong><code>RIGHT-ROTATE(y)</code> 的 <code>size</code> 维护:</strong></p>
<div class="code-container"><pre class="hljs"><code>x = y.left
// ... 执行旋转的指针操作 ...
// 更新 size
x.size = y.size
y.size = y.left.size + y.right.size + 1
</code></pre></div>
<p>由于每次插入和删除最多只会进行常数次旋转，并且更新 <code>size</code> 的代价是 $O(1)$，因此总的维护成本不会超过 $O(\log n)$。</p>
</li>
</ul>
<p><strong>3. <code>OS-SELECT(k)</code> 的实现</strong></p>
<p><code>OS-SELECT(x, k)</code> 函数的目标是在以 <code>x</code> 为根的子树中查找第 <code>k</code> 小的元素。</p>
<p><strong>伪代码:</strong></p>
<div class="code-container"><pre class="hljs"><code>OS-SELECT(x, k)
  // 计算左子树的大小，并加1得到根的排名
  r = x.left.size + 1
  
  if k == r
    return x // 根节点就是第 k 小的元素
  else if k &lt; r
    return OS-SELECT(x.left, k) // 在左子树中继续查找第 k 小
  else
    return OS-SELECT(x.right, k - r) // 在右子树中查找第 (k-r) 小
</code></pre></div>
<p><strong>C++ 实现:</strong></p>
<div class="code-container"><pre class="hljs"><code>Node* osSelect(int k) {
    return _osSelect(root, k);
}

private:
Node* _osSelect(Node* x, int k) {
    if (x == T_NIL || k &lt;= 0 || k &gt; x-&gt;size) {
        return T_NIL; // Not found
    }
    int r = x-&gt;left-&gt;size + 1;
    if (k == r) {
        return x;
    } else if (k &lt; r) {
        return _osSelect(x-&gt;left, k);
    } else {
        return _osSelect(x-&gt;right, k - r);
    }
}
</code></pre></div>
<p>该算法每次递归都下降一层，因此时间复杂度为 $O(h) = O(\log n)$。我们还可以实现一个逆操作 <code>OS-RANK(x)</code>，用于查找节点 <code>x</code> 在树中的排名，时间复杂度同样为 $O(\log n)$。</p>
<h4 id="问题2证明操作的复杂度边界"><strong>问题2：证明操作的复杂度边界</strong></h4>
<p><strong>问题</strong>：严格证明插入操作最多需要2次旋转，删除操作最多需要3次旋转。</p>
<p><strong>解答</strong>：</p>
<p>这个证明的关键在于分析 <code>fixup</code> 循环的终止条件。</p>
<p><strong>1. 插入操作 (最多2次旋转)</strong></p>
<p><code>RB-INSERT-FIXUP</code> 的循环条件是 <code>z.p.color == RED</code>。</p>
<ul>
<li><strong>情况1 (叔叔是红色)</strong>：此情况不执行任何旋转。它通过重新着色将问题（红-红冲突）向上移动两层（<code>z</code> 指向 <code>z.p.p</code>）。循环继续。</li>
<li><strong>情况2 (叔叔是黑色，三角形)</strong>：此情况执行 <strong>1次旋转</strong>，将自身转化为情况3。此时，<code>z</code> 的指针已经更新，但新的 <code>z</code> 和它的父节点仍然是红-红冲突，满足情况3的条件。</li>
<li><strong>情况3 (叔叔是黑色，直线型)</strong>：此情况执行 <strong>1次旋转</strong>。然后，它将 <code>z.p</code> 设为黑色。这就破坏了 <code>while (z.p.color == RED)</code> 的循环条件。因此，<strong>在执行完情况3后，循环必然终止</strong>。</li>
</ul>
<p><strong>证明路径分析</strong>:</p>
<ol>
<li><strong>路径A (只有情况1)</strong>: <code>Case 1 -&gt; Case 1 -&gt; ... -&gt; Root</code>。这个路径上发生0次旋转。</li>
<li><strong>路径B (最终收敛到情况3)</strong>: <code>Case 1 -&gt; ... -&gt; Case 1 -&gt; Case 3</code>。这个路径上发生 <strong>1次旋转</strong> (来自最终的Case 3)，然后循环终止。</li>
<li><strong>路径C (最终收敛到情况2)</strong>: <code>Case 1 -&gt; ... -&gt; Case 1 -&gt; Case 2 -&gt; Case 3</code>。这个路径上，Case 2 执行1次旋转，然后立即进入 Case 3，再执行1次旋转，然后循环终止。总共 <strong>2次旋转</strong>。</li>
</ol>
<p>由于一个插入操作的修复过程只可能是以上三种路径之一，因此最多发生的旋转次数为2次。</p>
<p><strong>2. 删除操作 (最多3次旋转)</strong></p>
<p><code>RB-DELETE-FIXUP</code> 的循环条件是 <code>x != root &amp;&amp; x.color == BLACK</code> (即 <code>x</code> 是双黑)。</p>
<ul>
<li><strong>情况2 (黑兄弟，黑侄子)</strong>：此情况不执行旋转。它将双黑问题向上传递一层（<code>x</code> 指向 <code>x.p</code>）。循环继续。</li>
<li><strong>情况1 (红兄弟)</strong>：执行 <strong>1次旋转</strong>。这个操作的目的是将 <code>x</code> 的兄弟变成黑色，从而将问题转化为情况2、3或4。<strong>操作后，循环不会终止</strong>，因为 <code>x</code> 依然是双黑，只是环境变了。</li>
<li><strong>情况3 (黑兄弟，内红外黑侄子)</strong>：执行 <strong>1次旋转</strong>。将问题转化为情况4。</li>
<li><strong>情况4 (黑兄弟，外红侄子)</strong>：执行 <strong>1次旋转</strong>。这个操作通过一系列变色彻底解决了双黑问题，并通过 <code>x = root</code> <strong>强制终止循环</strong>。</li>
</ul>
<p><strong>证明路径分析</strong>:<br>
删除的修复路径比插入复杂，我们来分析最坏的情况：</p>
<ol>
<li><strong>起始</strong>：<code>x</code> 是双黑。</li>
<li><strong>进入情况1</strong>：<code>x</code> 的兄弟是红色。执行 <strong>1次旋转</strong>。之后 <code>x</code> 的新兄弟一定是黑色。<code>x</code> 仍然是双黑，循环继续。</li>
<li><strong>进入情况3</strong>：<code>x</code> 的新兄弟是黑色，且内侧孩子是红色。执行 <strong>1次旋转</strong>。问题转化为情况4。<code>x</code> 仍然是双黑。</li>
<li><strong>进入情况4</strong>：<code>x</code> 的新兄弟是黑色，且外侧孩子是红色。执行 <strong>1次旋转</strong>。问题解决，循环终止。</li>
</ol>
<p>这个 <strong>Case 1 -&gt; Case 3 -&gt; Case 4</strong> 的路径是唯一能触发3次旋转的路径。任何其他路径，例如直接进入Case 4，或进入Case 2向上传递，其旋转次数都少于3。因此，删除操作最多需要3次旋转。</p>
<h4 id="问题3持久化红黑树-persistent-red-black-tree"><strong>问题3：持久化红黑树 (Persistent Red-Black Tree)</strong></h4>
<p><strong>问题</strong>：如何实现一个“可回溯”的持久化红黑树？核心思想是什么？时间和空间复杂度如何？</p>
<p><strong>解答</strong>：</p>
<p><strong>1. 核心思想：路径复制 (Path Copying)</strong></p>
<p>持久化数据结构的核心原则是<strong>永不修改现有节点</strong>。当我们对数据结构进行修改时，我们不改变原始版本，而是创建一个包含修改的新版本。为了高效地做到这一点，新旧两个版本会共享大部分未被修改的节点。</p>
<p><strong>路径复制</strong>是实现这一点的关键技术：</p>
<ul>
<li>当我们要插入或删除一个节点时，我们首先需要从根节点向下遍历一条路径。</li>
<li>对于这条路径上的每一个节点，我们都创建一个它的<strong>副本</strong>。</li>
<li>这个新创建的副本的指针将指向下一个新创建的副本（在路径上的那个方向），而它的另一个指针则指向<strong>原始的、未被修改的</strong>子树。</li>
<li>当我们到达需要修改的位置（例如插入新节点或进行旋转），我们对这些新创建的副本进行操作。</li>
<li>最终，我们会得到一个新的根节点，它代表了修改后的树的版本。</li>
</ul>
<p><strong>2. 插入操作示例</strong></p>
<p>假设我们要在下图中插入 <code>22</code>。修改路径是 <code>20 -&gt; 25</code>。</p>
<div class="mermaid">graph TD
    subgraph "原始树 (版本1)"
        A(20) --&gt; B(10);
        A --&gt; C(25);
        C --&gt; D(23);
    end

    subgraph "插入22后 (版本2)"
        A_copy(20') --&gt; B;
        A_copy --&gt; C_copy(25');
        C_copy --&gt; D_copy(23');
        D_copy --&gt; E_new(22);
    end
    
    linkStyle 0 stroke:gray,stroke-dasharray: 5 5;
    linkStyle 1 stroke:gray,stroke-dasharray: 5 5;
    linkStyle 2 stroke:gray,stroke-dasharray: 5 5;
</div>
<ul>
<li>我们创建 <code>20</code> 的副本 <code>20'</code>。<code>20'</code> 的左孩子指针指向原始的 <code>10</code> 节点。</li>
<li>我们创建 <code>25</code> 的副本 <code>25'</code>。<code>20'</code> 的右孩子指针指向 <code>25'</code>。</li>
<li>我们创建 <code>23</code> 的副本 <code>23'</code>。<code>25'</code> 的右孩子指针指向 <code>23'</code>。</li>
<li>最后，我们创建新节点 <code>22</code>，并将其作为 <code>23'</code> 的左孩子。</li>
<li><code>20'</code> 就是版本2的根。版本1和版本2共享了节点 <code>10</code>。</li>
</ul>
<p><strong>3. 复杂性分析</strong></p>
<ul>
<li><strong>时间复杂度</strong>: 插入、删除和查找操作仍然需要遍历一条从根到叶子的路径，其长度为 $O(\log n)$。在路径上的每个节点，我们执行 $O(1)$ 的复制工作。修复过程中的旋转和变色也发生在新复制的路径上。因此，<strong>时间复杂度仍然是 $O(\log n)$</strong>。</li>
<li><strong>空间复杂度</strong>: 每次修改操作（插入/删除），我们只复制了一条路径上的节点。路径的长度是 $O(\log n)$。因此，每次操作会额外创建 $O(\log n)$ 个新节点。<strong>空间复杂度是每次操作 $O(\log n)$</strong>。</li>
</ul>
<p>这种方法在函数式编程语言中非常流行，因为它提供了天然的不可变性，简化了并发编程并提供了强大的版本控制能力。</p>
<h4 id="问题4红黑树与2-3-4树的等价性"><strong>问题4：红黑树与2-3-4树的等价性</strong></h4>
<p><strong>问题</strong>：描述红黑树与2-3-4树的映射关系。理解这种关系如何为红黑树的操作提供直观解释？</p>
<p><strong>解答</strong>：</p>
<p>红黑树可以被看作是 <strong>2-3-4树</strong> 的一种二进制表示形式。2-3-4树是一种B树，它的每个节点可以有1、2或3个键值，并对应有2、3或4个孩子。2-3-4树是<strong>完美平衡</strong>的，即所有叶子节点都在同一深度。</p>
<p><strong>1. 映射关系</strong></p>
<p>我们将2-3-4树的节点映射到红黑树的“节点组”上，其中红色节点被用来“粘合”键值。</p>
<ul>
<li><strong>2-节点 (1个键)</strong>: 映射为一个<strong>黑色</strong>节点。
<div class="mermaid">graph TD
    subgraph "2-3-4 树"
        A["( a )"]
    end
    subgraph "红黑树"
        B(a):::black
    end
</div>
</li>
<li><strong>3-节点 (2个键)</strong>: 映射为一个<strong>黑色</strong>节点和一个<strong>红色</strong>子节点。红黑树的性质（红色节点的孩子必须是黑色）确保了这个红色链接不会连续。
<div class="mermaid">graph TD
    subgraph "2-3-4 树"
        A["( a, b )"]
    end
    subgraph "红黑树 (两种可能)"
        B(b):::black --&gt; C(a):::red
        
        D(a):::black --&gt; E(b):::red
    end
</div>
</li>
<li><strong>4-节点 (3个键)</strong>: 映射为一个<strong>黑色</strong>节点和两个<strong>红色</strong>子节点。
<div class="mermaid">graph TD
    subgraph "2-3-4 树"
        A["( a, b, c )"]
    end
    subgraph "红黑树"
        B(b):::black --&gt; C(a):::red
        B --&gt; D(c):::red
    end
</div>
</li>
</ul>
<p><strong>2. 直观解释红黑树的操作</strong></p>
<p>理解了这种等价性后，红黑树的一些复杂操作就变得非常直观。</p>
<p><strong>以插入修复中的“情况1（红色叔叔）”为例</strong>：</p>
<ul>
<li><strong>在红黑树中</strong>：我们有一个黑色的祖父节点 <code>G</code>，它有两个红色的子节点 <code>P</code> 和 <code>U</code>（叔叔）。这正好对应一个 <strong>4-节点</strong>。我们正在尝试将一个新的红色节点 <code>z</code> 连接到 <code>P</code> 下面。</li>
<li><strong>在2-3-4树中</strong>：这等价于向一个已满的 <strong>4-节点</strong> 中插入一个新的键。</li>
<li><strong>2-3-4树的操作</strong>：当向一个4-节点插入时，该节点会<strong>分裂 (Split)</strong>。中间的键会被<strong>向上推到父节点</strong>中，而原来的4-节点则分裂成两个2-节点。</li>
<li><strong>对应回红黑树</strong>：
<ol>
<li><code>G</code> 变红（中间键向上移动，准备与父节点合并）。</li>
<li><code>P</code> 和 <code>U</code> 变黑（分裂成两个2-节点）。<br>
这与红黑树情况1的“颜色翻转”操作<strong>完全一致</strong>！</li>
</ol>
</li>
</ul>
<p>这个视角告诉我们，红黑树的颜色翻转和旋转，本质上就是在模拟B树（2-3-4树）的<strong>节点分裂</strong>和<strong>键值移动</strong>。红黑树的自平衡，源自于其背后B树的完美平衡特性。</p>
<h4 id="问题5并发环境下的挑战"><strong>问题5：并发环境下的挑战</strong></h4>
<p><strong>问题</strong>：在多线程环境中设计一个线程安全的红黑树会遇到什么挑战？如何解决？</p>
<p><strong>解答</strong>：</p>
<p>在并发环境下实现红黑树是一个极具挑战性的高级课题。简单的<strong>全局锁</strong>（在每次操作开始时锁定整个树，结束后解锁）会使树的操作串行化，完全丧失并发优势，因此不可取。我们需要更细粒度的策略。</p>
<p><strong>1. 核心挑战</strong></p>
<ul>
<li><strong>竞争条件 (Race Conditions)</strong>：多个线程同时读写树的同一部分，可能导致指针错乱、数据丢失或违反红黑树性质。</li>
<li><strong>死锁 (Deadlocks)</strong>：细粒度锁（例如给每个节点一把锁）是必须的，但如果线程A锁定了节点N1并等待N2，而线程B锁定了N2并等待N1，就会发生死锁。</li>
<li><strong>结构修改的原子性</strong>：<strong>旋转</strong>是最大的挑战。一次左旋 <code>LEFT-ROTATE(x)</code> 涉及修改 <code>x</code>, <code>x.p</code>, <code>y</code>, <code>y.left</code> 至少四个节点的指针。这个过程必须是原子的，否则其他线程可能会看到一个处于中间状态的、结构不一致的树。</li>
</ul>
<p><strong>2. 解决方案策略</strong></p>
<p>没有完美的单一解决方案，通常是多种策略的组合。</p>
<ul>
<li><strong>细粒度锁 (Fine-Grained Locking)</strong>
<ul>
<li><strong>锁的类型</strong>：使用<strong>读写锁 (Read-Write Locks)</strong>。多个读线程可以同时持有读锁并遍历树。写线程必须持有写锁，且写锁是排他的。</li>
<li><strong>锁的范围</strong>：
<ol>
<li><strong>手递手锁/锁耦合 (Hand-over-Hand / Lock Coupling)</strong>：一个线程在遍历树时，先获取子节点的锁，然后再释放父节点的锁。这允许多个写操作在树的不同部分并发进行。</li>
<li><strong>范围锁 (Scope Locking)</strong>：在执行修改前，线程需要锁定所有可能受影响的节点。对于旋转，这意味着需要锁定父、子、孙三代共3到5个节点。为了防止死锁，必须规定一个<strong>全局的锁获取顺序</strong>（例如，总是从树的上层向下层获取锁）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>乐观锁 (Optimistic Locking)</strong><br>
这种策略假设冲突很少发生。线程在不加锁的情况下读取节点信息和遍历。
<ol>
<li>当准备进行修改时，它会<strong>验证</strong>自读取以来，它所依赖的节点没有被其他线程修改过（例如，通过版本号或检查指针）。</li>
<li>如果验证通过，则使用原子操作（如 <strong>Compare-and-Swap, CAS</strong>）来提交修改。</li>
<li>如果验证失败，则操作失败，线程需要回退并重试整个过程。</li>
</ol>
</li>
<li><strong>无锁算法 (Lock-Free Algorithms)</strong><br>
这是最复杂但可能性能最高的方案。它完全不使用锁，而是依赖处理器的原子指令（如CAS）来保证数据一致性。实现一个无锁的红黑树极其困难，因为旋转等复杂操作很难被分解为单一的原子指令。这通常需要复杂的内存管理（如使用垃圾回收机制来处理延迟删除的节点）和精巧的算法设计。</li>
</ul>
<p><strong>结论</strong>：<br>
并发红黑树的设计是在<strong>并发度、实现复杂性、和性能开销</strong>之间做的权衡。对于大多数应用，带有<strong>手递手读写锁</strong>的细粒度锁方案是一个合理的起点。而对于性能要求极致的系统内核或数据库，研究者和工程师们则会探索更为复杂的乐观锁或无锁实现。</p>
</article><div class="share-buttons">
<p>分享到：</p>
<a class="share-btn weibo" href="#" onclick="sharePost(event, 'weibo')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Sina Weibo</title><path d="M10.098 20.323c-3.977.391-7.414-1.406-7.672-4.02-.259-2.609 2.759-5.047 6.74-5.441 3.979-.394 7.413 1.404 7.671 4.018.259 2.6-2.759 5.049-6.737 5.439l-.002.004zM9.05 17.219c-.384.616-1.208.884-1.829.602-.612-.279-.793-.991-.406-1.593.379-.595 1.176-.861 1.793-.601.622.263.82.972.442 1.592zm1.27-1.627c-.141.237-.449.353-.689.253-.236-.09-.313-.361-.177-.586.138-.227.436-.346.672-.24.239.09.315.36.18.601l.014-.028zm.176-2.719c-1.893-.493-4.033.45-4.857 2.118-.836 1.704-.026 3.591 1.886 4.21 1.983.64 4.318-.341 5.132-2.179.8-1.793-.201-3.642-2.161-4.149zm7.563-1.224c-.346-.105-.57-.18-.405-.615.375-.977.42-1.804 0-2.404-.781-1.112-2.915-1.053-5.364-.03 0 0-.766.331-.571-.271.376-1.217.315-2.224-.27-2.809-1.338-1.337-4.869.045-7.888 3.08C1.309 10.87 0 13.273 0 15.348c0 3.981 5.099 6.395 10.086 6.395 6.536 0 10.888-3.801 10.888-6.82 0-1.822-1.547-2.854-2.915-3.284v.01zm1.908-5.092c-.766-.856-1.908-1.187-2.96-.962-.436.09-.706.511-.616.932.09.42.511.691.932.602.511-.105 1.067.044 1.442.465.376.421.466.977.316 1.473-.136.406.089.856.51.992.405.119.857-.105.992-.512.33-1.021.12-2.178-.646-3.035l.03.045zm2.418-2.195c-1.576-1.757-3.905-2.419-6.054-1.968-.496.104-.812.587-.706 1.081.104.496.586.813 1.082.707 1.532-.331 3.185.15 4.296 1.383 1.112 1.246 1.429 2.943.947 4.416-.165.48.106 1.007.586 1.157.479.165.991-.104 1.157-.586.675-2.088.241-4.478-1.338-6.235l.03.045z"></path></svg>
<span>微博</span>
</a>
<a class="share-btn twitter" href="#" onclick="sharePost(event, 'twitter')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M21.543 7.104c.015.211.015.423.015.636 0 6.507-4.954 14.01-14.01 14.01v-.003A13.94 13.94 0 0 1 0 19.539a9.88 9.88 0 0 0 7.287-2.041 4.93 4.93 0 0 1-4.6-3.42 4.916 4.916 0 0 0 2.223-.084A4.926 4.926 0 0 1 .96 9.167v-.062a4.887 4.887 0 0 0 2.235.616A4.928 4.928 0 0 1 1.67 3.148 13.98 13.98 0 0 0 11.82 8.292a4.929 4.929 0 0 1 8.39-4.49 9.868 9.868 0 0 0 3.128-1.196 4.941 4.941 0 0 1-2.165 2.724A9.828 9.828 0 0 0 24 4.555a10.019 10.019 0 0 1-2.457 2.549z"></path></svg>
<span>Twitter</span>
</a>
<a class="share-btn linkedin" href="#" onclick="sharePost(event, 'linkedin')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg>
<span>LinkedIn</span>
</a>
<a class="share-btn wechat" href="#" onclick="sharePost(event, 'wechat')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>WeChat</title><path d="M8.691 2.188C3.891 2.188 0 5.476 0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59 0 0 1 .213.665l-.39 1.48c-.019.07-.048.141-.048.213 0 .163.13.295.29.295a.326.326 0 0 0 .167-.054l1.903-1.114a.864.864 0 0 1 .717-.098 10.16 10.16 0 0 0 2.837.403c.276 0 .543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178A1.17 1.17 0 0 1 4.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813 0c.642 0 1.162.529 1.162 1.18a1.17 1.17 0 0 1-1.162 1.178 1.17 1.17 0 0 1-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826 0 1.622-.12 2.361-.336a.722.722 0 0 1 .598.082l1.584.926a.272.272 0 0 0 .14.047c.134 0 .24-.111.24-.247 0-.06-.023-.12-.038-.177l-.327-1.233a.582.582 0 0 1-.023-.156.49.49 0 0 1 .201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.97-.982zm4.844 0c.535 0 .969.44.969.982a.976.976 0 0 1-.969.983.976.976 0 0 1-.969-.983c0-.542.434-.982.969-.982z"></path></svg>
<span>微信</span>
</a>
<a class="share-btn qq" href="#" onclick="sharePost(event, 'qq')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Tencent QQ</title><path d="M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673"></path></svg>
<span>QQ</span>
</a>
<a class="share-btn facebook" href="#" onclick="sharePost(event, 'facebook')">
<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Facebook</title><path d="M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z"></path></svg>
<span>Facebook</span>
</a>
</div>
<div class="giscus-container" style="margin-top: 50px;">
  <script src="https://giscus.app/client.js"
  data-repo="forliage/forliage.github.io"
  data-repo-id="R_kgDONjzd4w"
  data-category="Announcements"
  data-category-id="DIC_kwDONjzd484Cus1G"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"
  data-theme="https://forliage.github.io/giscus.css"
  data-lang="zh-CN"
  crossorigin="anonymous"
  async>
</script>
</div>

</main>
</div>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
<script>
      mermaid.initialize({
        startOnLoad: true
      });
    </script>
<div class="dock">
  <a href="https://forliage.github.io/index.html">🏠</a>
  <a href="https://forliage.github.io/posts.html">📚</a>
  <a href="https://forliage.github.io/about.html">👤</a>
</div>
<script src="../script.js"></script>
<!-- The Modal -->
<div class="modal" id="about-me-modal">
<!-- Modal content -->
<div class="modal-content">
<span class="close-button">×</span>
<h2>About Me</h2>
<p>This is forliage, an undergraduate student of computer science and technology at Zhejiang University.</p>
<p><strong>Motto:</strong> People always say that time heals all wounds, but I don't believe that. Time doen't heal the pain, it just makes us get used to pain. When you lose someone, you don't really forget them; you just learn how to live on without them.</p>
<p><strong>Interests:</strong> Computer Graphics, Computer Version, Computer Animation, HPC, AIGC</p>
<p><strong>Favorite Movie:</strong> The Shawshank Redemption, Dead Poets Society, Zootopia</p>
<p><strong>Favorite Music:</strong> Blank Space, Sorega Daiji, Counting Stars, Whataya Want from Me</p>
<p><strong>Contact Information:</strong>masterforliage@gmail.com</p>
<hr/>
<h3>订阅我的博客</h3>
<p>订阅功能正在建设中，敬请期待！</p>
</div>
</div>
<script src="../modal.js"></script><script src="../trail.js"></script>
<!-- Highlight.js Core -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- Highlight.js Copy Plugin -->
<script src="https://cdn.jsdelivr.net/npm/highlightjs-copy@1.0.6/dist/highlightjs-copy.min.js"></script>
<!-- Initialize Highlight.js and Copy Plugin -->
<script>
  hljs.highlightAll();
  hljs.addPlugin(new CopyButtonPlugin());
</script>
</body>
</html>