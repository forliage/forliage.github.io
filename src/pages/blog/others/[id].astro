---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";

export async function getStaticPaths() {
    const planets = [
        { id: "cmu-15-462", color: "#ff6b6b", title: "CMU 15-462" },
        { id: "cmu-15-458", color: "#4dabf7", title: "CMU 15-458" },
        { id: "stanford-cs231n", color: "#69db7c", title: "Stanford CS231n" },
        { id: "ucsd-cse-272", color: "#da77f2", title: "UCSD CSE 272" },
        { id: "games-101", color: "#ffa94d", title: "Games 101" },
        { id: "games-202", color: "#adb5bd", title: "Games 202" },
    ];
    return planets.map((p) => ({
        params: { id: p.id },
        props: { planet: p },
    }));
}

const { id } = Astro.params;
const { planet } = Astro.props;
---

<Layout title={`${planet.title} - Landing Surface`}>
    <Header />
    <main class="landing-container">
        <!-- Overlay UI -->
        <div class="ui-overlay">
            <a href="/blog/others" class="btn-back">
                <span class="icon">ðŸš€</span> LEAVE PLANET
            </a>
            <div class="planet-title-card">
                <h1>{planet.title}</h1>
                <div class="status-badge">ATMOSPHERE: STABLE</div>
                <!-- Control Status Hint -->
                <div id="control-guide" class="control-guide">
                    <div class="indicator">
                        <span class="dot"></span>
                        <span class="mode-text">CINEMATIC MODE</span>
                    </div>
                    <div class="hint-text">TOGGLE CAPSLOCK TO EXPLORE</div>
                </div>
            </div>
        </div>

        <!-- 3D Environment Canvas -->
        <div
            id="landing-canvas-container"
            data-planet-color={planet.color}
            data-planet-id={planet.id}
        >
        </div>
    </main>
</Layout>

<script>
    import * as THREE from "three";

    // Typed declarations for Three.js objects
    let scene: THREE.Scene;
    let camera: THREE.PerspectiveCamera;
    let renderer: THREE.WebGLRenderer;
    let terrain: THREE.Mesh;
    let requestID: number;
    let seed: number = 0;

    const container = document.getElementById(
        "landing-canvas-container",
    ) as HTMLDivElement;
    const planetColor = container?.dataset.planetColor || "#ffffff";
    const planetId = container?.dataset.planetId || "default";

    // Simple hash for seeding
    function getSeed(str: string) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = (hash << 5) - hash + str.charCodeAt(i);
            hash |= 0;
        }
        return Math.abs(hash);
    }
    seed = getSeed(planetId);

    function init() {
        if (!container) return;

        // 1. Scene Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050507);
        scene.fog = new THREE.FogExp2(0x101015, 0.015); // Clearer atmosphere

        // 2. Camera Setup
        camera = new THREE.PerspectiveCamera(
            55,
            window.innerWidth / window.innerHeight,
            0.1,
            2000,
        );
        camera.position.set(0, 18, 70); // Higher vantage for more ground
        camera.lookAt(0, 0, -40);

        // 3. Renderer Setup
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance",
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // 4. Lighting
        const sun = new THREE.DirectionalLight(0xffffff, 5.0);
        sun.position.set(100, 150, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.set(2048, 2048);
        sun.shadow.camera.left = -100;
        sun.shadow.camera.right = 100;
        sun.shadow.camera.top = 100;
        sun.shadow.camera.bottom = -100;
        scene.add(sun);

        const fillLight = new THREE.PointLight(planetColor, 25, 100);
        fillLight.position.set(-30, 20, 10);
        scene.add(fillLight);

        const amb = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(amb);

        // 5. Geometry & Objects
        generateTerrain();
        addRocks();
        addStars();

        animate();
    }

    function generateTerrain() {
        const size = 500;
        const resolution = 256; // High density for more detail
        const geo = new THREE.PlaneGeometry(size, size, resolution, resolution);
        geo.rotateX(-Math.PI / 2);

        const pos = geo.attributes.position;
        const sx = (seed % 1000) * 0.5;
        const sz = (seed % 777) * 0.3;

        // Vary "personality" (frequency and amplitude) based on seed
        const freqMap = 0.8 + (seed % 4) * 0.15; // 0.8 to 1.25
        const ampMap = 0.9 + (seed % 3) * 0.15; // 0.9 to 1.2

        for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i) + sx;
            const z = pos.getZ(i) + sz;

            // Seeded procedural terrain
            let y = 0;
            y +=
                Math.sin(x * 0.03 * freqMap) *
                Math.cos(z * 0.03 * freqMap) *
                18.0 *
                ampMap;
            y +=
                Math.sin(x * 0.12 * freqMap) *
                Math.sin(z * 0.12 * freqMap) *
                6.0 *
                ampMap;
            y += Math.abs(Math.sin(x * 0.4) * Math.cos(z * 0.4)) * 4.0;
            y += (Math.random() - 0.5) * 0.8;
            pos.setY(i, y);
        }
        geo.computeVertexNormals();

        const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(planetColor),
            roughness: 0.65, // Lower roughness for more defined highlights
            metalness: 0.2,
            flatShading: false, // Smooth shading but with more geometry detail
        });

        terrain = new THREE.Mesh(geo, mat);
        terrain.receiveShadow = true;
        scene.add(terrain);
    }

    function addRocks() {
        const rockCount = 60;
        const freqMap = 0.8 + (seed % 4) * 0.15;
        const ampMap = 0.9 + (seed % 3) * 0.15;

        for (let i = 0; i < rockCount; i++) {
            // Seeded deterministic noise for placement
            const s1 = Math.sin(seed * 0.1 + i * 2.3) * 10000;
            const s2 = Math.cos(seed * 0.2 + i * 1.7) * 10000;
            const noise1 = s1 - Math.floor(s1); // 0 to 1
            const noise2 = s2 - Math.floor(s2); // 0 to 1

            const rx = (noise1 - 0.5) * 220;
            const rz = (noise2 - 0.5) * 220;
            const size = noise1 * 4 + 1;

            const bGeo = new THREE.DodecahedronGeometry(size, 0);
            const bMat = new THREE.MeshPhysicalMaterial({
                color: planetColor,
                roughness: 0.1,
                metalness: 0.4,
                ior: 1.5,
                transmission: 0.6,
                thickness: 2,
                transparent: true,
                opacity: 0.9,
                reflectivity: 0.5,
            });

            const rock = new THREE.Mesh(bGeo, bMat);

            // Sync height with seeded terrain
            const sx = rx + (seed % 1000) * 0.5;
            const sz = rz + (seed % 777) * 0.3;
            const ry =
                Math.sin(sx * 0.03 * freqMap) *
                    Math.cos(sz * 0.03 * freqMap) *
                    18.0 *
                    ampMap +
                Math.sin(sx * 0.12 * freqMap) *
                    Math.sin(sz * 0.12 * freqMap) *
                    6.0 *
                    ampMap +
                Math.abs(Math.sin(sx * 0.4) * Math.cos(sz * 0.4)) * 4.0 -
                size * 0.5;

            rock.position.set(rx, ry, rz);
            rock.rotation.set(noise1 * Math.PI, noise2 * Math.PI, 0);
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
        }
    }

    let stars: THREE.Points;
    function addStars() {
        const starCount = 300;
        const pos = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount; i++) {
            pos[i * 3] = (Math.random() - 0.5) * 1000;
            pos[i * 3 + 1] = Math.random() * 400 + 100; // Elevated sky
            pos[i * 3 + 2] = (Math.random() - 0.5) * 1000;
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));

        const mat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.2,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true,
        });

        stars = new THREE.Points(geo, mat);
        scene.add(stars);
    }

    // --- INTERACTIVE EXPLORATION LOGIC ---
    let isExploring = false;
    const keys = { w: false, a: false, s: false, d: false };
    const player = {
        pos: new THREE.Vector3(0, 15, 60),
        yaw: 0,
        pitch: 0,
        speed: 0.8,
        lookSensitivity: 0.002,
    };

    const guide = document.getElementById("control-guide");
    const modeText = guide?.querySelector(".mode-text");

    function updateExplorationState() {
        const sync = (event: any) => {
            if (typeof event.getModifierState !== "function") return;
            const newState = event.getModifierState("CapsLock");
            if (newState !== isExploring) {
                isExploring = newState;
                if (guide) {
                    guide.classList.toggle("active", isExploring);
                    if (modeText)
                        modeText.textContent = isExploring
                            ? "EXPLORATION MODE ACTIVE"
                            : "CINEMATIC MODE";
                }
            }
        };
        window.addEventListener("keydown", sync);
        window.addEventListener("keyup", sync);
        window.addEventListener("mousedown", sync);
        window.addEventListener("mousemove", sync);
        window.addEventListener("pointerdown", sync);
        window.addEventListener("focus", sync);
    }

    // Capture WASD
    window.addEventListener("keydown", (e) => {
        const k = e.key.toLowerCase();
        if (keys.hasOwnProperty(k)) keys[k as keyof typeof keys] = true;
    });
    window.addEventListener("keyup", (e) => {
        const k = e.key.toLowerCase();
        if (keys.hasOwnProperty(k)) keys[k as keyof typeof keys] = false;
    });

    // Capture Mouse Move for Look
    window.addEventListener("mousemove", (e) => {
        if (!isExploring) return;
        player.yaw -= e.movementX * player.lookSensitivity;
        player.pitch -= e.movementY * player.lookSensitivity;
        player.pitch = Math.max(
            -Math.PI / 3,
            Math.min(Math.PI / 3, player.pitch),
        );
    });

    function getTerrainHeight(x: number, z: number) {
        const sx = x + (seed % 1000) * 0.5;
        const sz = z + (seed % 777) * 0.3;
        const freqMap = 0.8 + (seed % 4) * 0.15;
        const ampMap = 0.9 + (seed % 3) * 0.15;

        let y = 0;
        y +=
            Math.sin(sx * 0.03 * freqMap) *
            Math.cos(sz * 0.03 * freqMap) *
            18.0 *
            ampMap;
        y +=
            Math.sin(sx * 0.12 * freqMap) *
            Math.sin(sz * 0.12 * freqMap) *
            6.0 *
            ampMap;
        y += Math.abs(Math.sin(sx * 0.4) * Math.cos(sz * 0.4)) * 4.0;
        return y + 8.0; // Stand height
    }

    function animate() {
        requestID = requestAnimationFrame(animate);
        const time = Date.now() * 0.0005;

        if (stars) {
            (stars.material as THREE.PointsMaterial).opacity =
                0.5 + Math.sin(time * 4) * 0.3;
        }

        if (isExploring) {
            // Movement Relative to Camera
            const forward = new THREE.Vector3(
                Math.sin(player.yaw),
                0,
                Math.cos(player.yaw),
            ).normalize();
            const right = new THREE.Vector3()
                .crossVectors(new THREE.Vector3(0, 1, 0), forward)
                .normalize();

            if (keys.w) player.pos.addScaledVector(forward, -player.speed);
            if (keys.s) player.pos.addScaledVector(forward, player.speed);
            if (keys.a) player.pos.addScaledVector(right, -player.speed);
            if (keys.d) player.pos.addScaledVector(right, player.speed);

            // Boundary Constraint (180 unit radius)
            const d = player.pos.length();
            if (d > 180) player.pos.setLength(180);

            // Surface Snapping
            player.pos.y = getTerrainHeight(player.pos.x, player.pos.z);

            // Apply to Camera
            camera.position.set(player.pos.x, player.pos.y, player.pos.z);
            camera.rotation.set(0, 0, 0);
            camera.rotation.order = "YXZ";
            camera.rotation.y = player.yaw;
            camera.rotation.x = player.pitch;
        } else {
            // Cinematic Camera Panning (Smooth Transition Back)
            const targetX = Math.sin(time * 0.1) * 15;
            const targetPos = new THREE.Vector3(targetX, 18, 70);
            camera.position.lerp(targetPos, 0.05);

            const targetLook = new THREE.Vector3(0, -5, -60);
            const m = new THREE.Matrix4();
            m.lookAt(camera.position, targetLook, new THREE.Vector3(0, 1, 0));
            camera.quaternion.slerp(
                new THREE.Quaternion().setFromRotationMatrix(m),
                0.05,
            );
        }

        renderer.render(scene, camera);
    }

    // Cleanup on window resize
    const handleResize = () => {
        if (!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };

    window.addEventListener("resize", handleResize);

    // Initial call
    updateExplorationState();
    init();
</script>

<style>
    .landing-container {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #000;
        font-family: "Outfit", sans-serif;
    }
    #landing-canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }

    .ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 100;
        padding: 30px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-start; /* Title to side */
    }

    .btn-back {
        pointer-events: auto;
        text-decoration: none;
        color: #fff;
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        padding: 10px 20px;
        border-radius: 50px;
        font-weight: 700;
        font-size: 0.9rem;
        transition: all 0.3s;
    }
    .btn-back:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
    }

    .planet-title-card {
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(10px);
        padding: 20px 30px;
        border-radius: 15px;
        border-left: 4px solid #fff;
        margin: 20px;
        min-width: 250px;
    }
    h1 {
        font-size: 1.8rem;
        text-transform: uppercase;
        letter-spacing: 4px;
        font-weight: 900;
        margin-bottom: 5px;
        color: #fff;
    }
    .status-badge {
        color: #0f0;
        font-weight: 800;
        letter-spacing: 2px;
        font-size: 0.65rem;
        margin-bottom: 15px;
    }

    /* Control Guide UI */
    .control-guide {
        margin-top: 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding-top: 10px;
        transition: all 0.5s;
    }
    .indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 4px;
    }
    .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #fff;
        box-shadow: 0 0 5px #fff;
        transition: background 0.3s;
    }
    .control-guide.active .dot {
        background: #0f0;
        box-shadow: 0 0 10px #0f0;
    }
    .mode-text {
        color: #fff;
        font-size: 0.75rem;
        font-weight: 800;
        letter-spacing: 1px;
    }
    .hint-text {
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.65rem;
        font-weight: 500;
        letter-spacing: 1px;
    }
    .control-guide.active .mode-text {
        color: #0f0;
    }
</style>
