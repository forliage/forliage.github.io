---
import Layout from "../../layouts/Layout.astro";
import Header from "../../components/Header.astro";

const categories = [
    {
        id: "views",
        title: "Technical Views",
        description: "Personal insights on software trends and engineering philosophy.",
        link: "#",
    },
    {
        id: "papers",
        title: "Paper Insights",
        description: "Deep dives into academic research and breakthrough algorithms.",
        link: "#",
    },
    {
        id: "tips",
        title: "Common Tips",
        description: "A collection of practical engineering tricks and daily shortcuts.",
        link: "#",
    }
];
---

<Layout title="Technique Discussion - Liuye Zhao">
    <Header />

    <main class="tech-page">
        <!-- Background Meteors Container (Reusing from ZJU) -->
        <div id="meteors-container"></div>

        <!-- Back Button -->
        <a href="/blog" class="back-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            Back
        </a>

        <div class="page-header">
            <h1 class="page-title">Technique Discussion</h1>
            <p class="page-subtitle">Exploration, analysis, and engineering wisdom.</p>
        </div>

        <div class="doors-container">
            {categories.map((cat) => (
                <div class="door-wrapper">
                    <div class="door-label-top">
                        <h3>{cat.title}</h3>
                        <p>{cat.description}</p>
                    </div>

                    <a href={cat.link} class="door-cube-scene" id={`scene-${cat.id}`}>
                        <div class="cube-assembly">
                            <!-- The 5 faces of the tunnel -->
                            <div class="face front-frame"></div>
                            <div class="face tunnel-wall top"></div>
                            <div class="tunnel-wall bottom"></div> <!-- Not face class to avoid conflict -->
                            <div class="tunnel-wall left"></div>
                            <div class="tunnel-wall right"></div>
                            <div class="face back-screen">
                                <canvas class="starfield-canvas"></canvas>
                            </div>
                        </div>
                        <!-- Particle Aura Container -->
                        <canvas class="particle-canvas"></canvas>
                    </a>

                    <a href={cat.link} class="enter-btn">ENTER</a>
                </div>
            ))}
        </div>
    </main>
</Layout>

<script>
    class StarfieldEngine {
        canvas: HTMLCanvasElement;
        ctx: CanvasRenderingContext2D;
        stars: { x: number; y: number; z: number; prevZ: number }[];
        speed: number;
        width: number;
        height: number;
        centerX: number;
        centerY: number;
        warpSpeed: boolean;
        animationId: number;

        constructor(canvas: HTMLCanvasElement) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d', { alpha: false })!;
            this.stars = [];
            this.speed = 2; // Base speed
            this.warpSpeed = false;
            
            this.resize();
            this.initStars(800); // Massive star count
            this.animate();

            // Handle resize
            const observer = new ResizeObserver(() => this.resize());
            observer.observe(canvas);

            // Warp effect on hover
            const parent = canvas.closest('.door-cube-scene');
            parent?.addEventListener('mouseenter', () => this.warpSpeed = true);
            parent?.addEventListener('mouseleave', () => this.warpSpeed = false);
        }

        resize() {
            this.width = this.canvas.width = this.canvas.clientWidth;
            this.height = this.canvas.height = this.canvas.clientHeight;
            this.centerX = this.width / 2;
            this.centerY = this.height / 2;
        }

        initStars(count: number) {
            this.stars = [];
            for (let i = 0; i < count; i++) {
                this.stars.push(this.createStar());
            }
        }

        createStar() {
            return {
                x: (Math.random() - 0.5) * this.width * 2, // Spread wider than screen
                y: (Math.random() - 0.5) * this.height * 2,
                z: Math.random() * 1000,
                prevZ: Math.random() * 1000
            };
        }

        animate() {
            // dynamic speed ramp
            const targetSpeed = this.warpSpeed ? 40 : 2;
            this.speed += (targetSpeed - this.speed) * 0.05;

            // Clear with semi-transparent black for trails if warping
            this.ctx.fillStyle = this.warpSpeed ? 'rgba(0, 0, 0, 0.2)' : '#000000';
            this.ctx.fillRect(0, 0, this.width, this.height);

            this.stars.forEach(star => {
                star.prevZ = star.z;
                star.z -= this.speed;

                if (star.z <= 0) {
                    star.z = 1000;
                    star.prevZ = 1000;
                    star.x = (Math.random() - 0.5) * this.width * 2;
                    star.y = (Math.random() - 0.5) * this.height * 2;
                }

                // Project 3D to 2D
                const k = 128.0 / star.z;
                const px = star.x * k + this.centerX;
                const py = star.y * k + this.centerY;

                // Previous pos for trails
                const pk = 128.0 / star.prevZ;
                const ppx = star.x * pk + this.centerX;
                const ppy = star.y * pk + this.centerY;

                if (px >= 0 && px <= this.width && py >= 0 && py <= this.height) {
                    const size = (1 - star.z / 1000) * 3; // Closer stars are bigger
                    const shade = Math.floor((1 - star.z / 1000) * 255);
                    
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = `rgb(${shade},${shade},${shade})`;
                    this.ctx.lineWidth = size;
                    this.ctx.moveTo(ppx, ppy);
                    this.ctx.lineTo(px, py);
                    this.ctx.stroke();
                }
            });

            this.animationId = requestAnimationFrame(() => this.animate());
        }
    }

    class ParticleAuraDisplay {
        canvas: HTMLCanvasElement;
        ctx: CanvasRenderingContext2D;
        particles: { x: number; y: number; vx: number; vy: number; life: number; color: string }[];
        width: number;
        height: number;
        
        constructor(canvas: HTMLCanvasElement) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d')!;
            this.particles = [];
            this.resize();
            this.animate();
            
            const observer = new ResizeObserver(() => this.resize());
            observer.observe(canvas);
        }

        resize() {
            // Canvas covers the whole interactive area
            this.width = this.canvas.width = this.canvas.clientWidth;
            this.height = this.canvas.height = this.canvas.clientHeight;
        }

        spawn() {
            // Emitting from a rectangle in the center (the door frame)
            // Hardcoded approximation of door size relative to canvas
            // Door is approx 280x420 centered
            const cx = this.width / 2;
            const cy = this.height / 2;
            const dw = 280;
            const dh = 420;
            const halfW = dw / 2;
            const halfH = dh / 2;

            // Pick a random point on perimeter
            const side = Math.floor(Math.random() * 4);
            let x, y, vx, vy;
            const speed = Math.random() * 1.5 + 0.5;

            if (side === 0) { // Top
                x = cx - halfW + Math.random() * dw;
                y = cy - halfH;
                vx = (Math.random() - 0.5); vy = -speed;
            } else if (side === 1) { // Right
                x = cx + halfW;
                y = cy - halfH + Math.random() * dh;
                vx = speed; vy = (Math.random() - 0.5);
            } else if (side === 2) { // Bottom
                x = cx - halfW + Math.random() * dw;
                y = cy + halfH;
                vx = (Math.random() - 0.5); vy = speed;
            } else { // Left
                x = cx - halfW;
                y = cy - halfH + Math.random() * dh;
                vx = -speed; vy = (Math.random() - 0.5);
            }

            this.particles.push({
                x, y, vx, vy,
                life: 1.0,
                color: `hsl(${330 + Math.random() * 30}, 80%, 60%)` // Pink/Purple range
            });
        }

        animate() {
            this.ctx.clearRect(0, 0, this.width, this.height);
            
            // Spawn multiple particles per frame for density
            for(let i=0; i<3; i++) this.spawn();

            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.015;

                if (p.life <= 0) {
                    this.particles.splice(i, 1);
                    continue;
                }

                this.ctx.globalAlpha = p.life;
                this.ctx.fillStyle = p.color;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 2.5 * p.life, 0, Math.PI * 2);
                this.ctx.fill();
            }
            this.ctx.globalAlpha = 1;

            requestAnimationFrame(() => this.animate());
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        // Init Background Meteors (ZJU style)
        const meteorsContainer = document.getElementById("meteors-container");
        if (meteorsContainer) {
            const createMeteor = () => {
                const meteor = document.createElement("div");
                meteor.classList.add("meteor");
                meteor.style.left = `${Math.random() * 120}%`;
                meteor.style.top = `${Math.random() * 100 - 50}%`;
                meteor.style.width = `${Math.random() * 100 + 50}px`;
                meteor.style.animationDuration = `${Math.random() * 1 + 1}s`;
                meteorsContainer.appendChild(meteor);
                setTimeout(() => meteor.remove(), 2000);
            };
            setInterval(createMeteor, 300);
        }

        // Init Starfield and Particle Engines
        document.querySelectorAll('.starfield-canvas').forEach(canvas => {
            new StarfieldEngine(canvas as HTMLCanvasElement);
        });
        document.querySelectorAll('.particle-canvas').forEach(canvas => {
            new ParticleAuraDisplay(canvas as HTMLCanvasElement);
        });
    });
</script>

<style>
    :root {
        --door-w: 280px;
        --door-h: 420px;
        --tunnel-depth: 400px; /* Deep tunnel */
    }

    .tech-page {
        min-height: 100vh;
        padding: 6rem 2rem;
        background: #050510; /* Deep space bg */
        color: #fff;
        overflow-x: hidden;
        perspective: 1200px;
        font-family: system-ui, sans-serif;
    }

    /* Common UI Elements */
    .back-button {
        position: fixed; top: 100px; left: 2rem; z-index: 100;
        display: flex; align-items: center; gap: 8px; padding: 12px 20px;
        background: rgba(255, 240, 245, 0.1); backdrop-filter: blur(10px);
        border: 1px solid rgba(240, 117, 174, 0.3); border-radius: 50px;
        color: #f075ae; text-decoration: none; transition: 0.3s;
    }
    .back-button:hover { background: rgba(240, 117, 174, 0.2); }

    .page-header { text-align: center; margin-bottom: 5rem; position: relative; z-index: 10; }
    .page-title {
        font-size: 3.5rem; font-weight: 800; margin-bottom: 0.5rem;
        background: linear-gradient(120deg, #f075ae, #a18cd1);
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .page-subtitle { color: #889; font-size: 1.1rem; }

    /* Meteors */
    #meteors-container { position: fixed; inset: 0; pointer-events: none; }
    :global(.meteor) {
        position: absolute; height: 2px;
        background: linear-gradient(90deg, #a18cd1, transparent);
        opacity: 0; transform: rotate(-45deg);
        animation: shower linear;
    }
    @keyframes shower {
        0% { opacity: 0; transform: rotate(-45deg) translateX(0); }
        10% { opacity: 0.7; }
        100% { opacity: 0; transform: rotate(-45deg) translateX(-1000px); }
    }

    /* --- The Door Assembly --- */
    .doors-container {
        display: flex; justify-content: center; gap: 6rem; flex-wrap: wrap;
        perspective: 2000px; z-index: 10; position: relative;
    }

    .door-wrapper {
        display: flex; flex-direction: column; align-items: center; gap: 2rem;
        position: relative;
    }

    .door-label-top { text-align: center; max-width: 260px; z-index: 20; pointer-events: none;}
    .door-label-top h3 { font-size: 1.6rem; margin: 0 0 0.5rem 0; color: #fff; text-shadow: 0 0 10px rgba(240,117,174,0.5); }
    .door-label-top p { color: #aaa; font-size: 0.9rem; margin: 0; }

    /* The interactive container */
    .door-cube-scene {
        width: 400px; height: 540px; /* Larger than door to hold particles */
        position: relative;
        display: flex; justify-content: center; align-items: center;
        perspective: 1200px;
        text-decoration: none;
    }

    /* Particle Canvas Layer */
    .particle-canvas {
        position: absolute; inset: 0; pointer-events: none; z-index: 15;
    }

    /* The 3D Cube Assembly */
    .cube-assembly {
        width: var(--door-w); height: var(--door-h);
        position: relative;
        transform-style: preserve-3d;
        transform: rotateY(-15deg); /* Initial nice angle */
        transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    }
    
    .door-cube-scene:hover .cube-assembly {
        transform: rotateY(0deg) scale(1.02); /* Face forward on hover */
    }

    /* Faces */
    .face, .tunnel-wall {
        position: absolute;
        backface-visibility: hidden; /* Optimization */
    }

    /* Front Frame (The Entrance) */
    .front-frame {
        width: 100%; height: 100%;
        border: 4px solid #333;
        box-shadow: 0 0 30px rgba(0,0,0,0.8);
        transform: translateZ(0);
        pointer-events: none;
        z-index: 10;
    }

    /* The Tunnel Walls - Using CSS 3D Transforms */
    /* Left Wall */
    .tunnel-wall.left {
        width: var(--tunnel-depth); height: 100%;
        background: linear-gradient(90deg, #111, #000);
        transform-origin: left;
        transform: rotateY(90deg);
        left: 0; top: 0;
    }
    /* Right Wall */
    .tunnel-wall.right {
        width: var(--tunnel-depth); height: 100%;
        background: linear-gradient(-90deg, #111, #000);
        transform-origin: right;
        transform: rotateY(-90deg);
        right: 0; top: 0;
    }
    /* Top Wall */
    .tunnel-wall.top {
        width: 100%; height: var(--tunnel-depth);
        background: linear-gradient(180deg, #111, #000);
        transform-origin: top;
        transform: rotateX(-90deg);
        top: 0; left: 0;
    }
    /* Bottom Wall */
    .tunnel-wall.bottom {
        width: 100%; height: var(--tunnel-depth);
        background: linear-gradient(0deg, #111, #000);
        transform-origin: bottom;
        transform: rotateX(90deg);
        bottom: 0; left: 0;
    }

    /* Back Screen (Canvas for Stars) */
    .back-screen {
        width: 100%; height: 100%;
        background: #000;
        transform: translateZ(calc(-1 * var(--tunnel-depth)));
        display: flex;
        overflow: hidden;
    }
    
    .starfield-canvas {
        width: 100%; height: 100%;
    }

    /* Enter Button */
    .enter-btn {
        margin-top: 1rem;
        padding: 10px 40px;
        border: 1px solid var(--accent);
        color: var(--accent);
        border-radius: 4px;
        text-decoration: none;
        letter-spacing: 2px;
        font-weight: 700;
        transition: 0.3s;
        box-shadow: 0 0 10px rgba(240, 117, 174, 0.2);
    }
    .enter-btn:hover {
        background: var(--accent);
        color: #fff;
        box-shadow: 0 0 30px rgba(240, 117, 174, 0.6);
    }
</style>
