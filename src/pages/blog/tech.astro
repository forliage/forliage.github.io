---
import Layout from "../../layouts/Layout.astro";
import Header from "../../components/Header.astro";

const categories = [
    {
        id: "views",
        title: "Technical Views",
        description: "Personal insights on software trends and engineering philosophy.",
        link: "#",
    },
    {
        id: "papers",
        title: "Paper Insights",
        description: "Deep dives into academic research and breakthrough algorithms.",
        link: "#",
    },
    {
        id: "tips",
        title: "Common Tips",
        description: "A collection of practical engineering tricks and daily shortcuts.",
        link: "#",
    }
];
---

<Layout title="Technique Discussion - Liuye Zhao">
    <Header />

    <main class="tech-page">
        <!-- Background Meteors Container (Reusing from ZJU) -->
        <div id="meteors-container"></div>

        <!-- Back Button -->
        <a href="/blog" class="back-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            Back
        </a>

        <div class="page-header">
            <h1 class="page-title">Technique Discussion</h1>
            <p class="page-subtitle">Exploration, analysis, and engineering wisdom.</p>
        </div>

        <div class="doors-container">
            {categories.map((cat) => (
                <div class="door-wrapper">
                    <div class="door-label-top">
                        <h3>{cat.title}</h3>
                        <p>{cat.description}</p>
                    </div>

                    <a href={cat.link} class="door-cube-scene" id={`scene-${cat.id}`}>
                        <div class="cube-assembly">
                            <!-- The 5 faces of the tunnel -->
                            <div class="face front-frame"></div>
                            <div class="face tunnel-wall top"></div>
                            <div class="face tunnel-wall bottom"></div>
                            <div class="face tunnel-wall left"></div>
                            <div class="face tunnel-wall right"></div>
                            <!-- Back screen for stars -->
                            <div class="face back-screen">
                                <canvas class="starfield-canvas"></canvas>
                            </div>
                        </div>
                        <!-- Particle Aura Container -->
                        <canvas class="particle-canvas"></canvas>
                    </a>

                    <a href={cat.link} class="enter-btn">ENTER</a>
                </div>
            ))}
        </div>
    </main>
</Layout>

<script>
    class StarfieldEngine {
        canvas: HTMLCanvasElement;
        ctx: CanvasRenderingContext2D;
        stars: { x: number; y: number; z: number; size: number; opacity: number; opacitySpeed: number }[];
        width!: number;
        height!: number;
        centerX!: number;
        centerY!: number;
        animationId!: number;

        constructor(canvas: HTMLCanvasElement) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d', { alpha: false })!;
            this.stars = [];
            
            this.resize();
            this.initStars(400); // Dense star count
            this.animate();

            const observer = new ResizeObserver(() => this.resize());
            observer.observe(canvas);
        }

        resize() {
            this.width = this.canvas.width = this.canvas.clientWidth;
            this.height = this.canvas.height = this.canvas.clientHeight;
            this.centerX = this.width / 2;
            this.centerY = this.height / 2;
        }

        initStars(count: number) {
            this.stars = [];
            for (let i = 0; i < count; i++) {
                this.stars.push(this.createStar(true)); // Spread initially
            }
        }

        createStar(randomZ = false) {
            return {
                x: (Math.random() - 0.5) * this.width * 3, // Wide spread
                y: (Math.random() - 0.5) * this.height * 3,
                z: randomZ ? Math.random() * 1000 : 1000, // Spawn far away
                size: Math.random() * 2 + 0.5,
                opacity: Math.random(),
                opacitySpeed: Math.random() * 0.05 + 0.01
            };
        }

        animate() {
            // Clear with SOLID BLACK for the deep space look inside the door
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(0, 0, this.width, this.height);

            const speed = 8; // Constant connection speed

            this.stars.forEach(star => {
                star.z -= speed;

                // Blinking effect
                star.opacity += star.opacitySpeed;
                if (star.opacity > 1 || star.opacity < 0.2) star.opacitySpeed *= -1;

                // Reset star if it passes camera
                if (star.z <= 1) {
                    Object.assign(star, this.createStar(false));
                }

                // Project 3D to 2D
                const k = 128.0 / star.z;
                const px = star.x * k + this.centerX;
                const py = star.y * k + this.centerY;

                // Only draw if within bounds
                if (px >= 0 && px <= this.width && py >= 0 && py <= this.height) {
                    // Size scales with proximity
                    const scaleSize = (1 - star.z / 1000) * 4 * star.size;
                    
                    this.ctx.beginPath();
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${Math.max(0, Math.min(1, star.opacity))})`;
                    this.ctx.arc(px, py, Math.max(0.5, scaleSize), 0, Math.PI * 2);
                    this.ctx.fill();
                }
            });

            this.animationId = requestAnimationFrame(() => this.animate());
        }
    }

    class ParticleAuraDisplay {
        canvas: HTMLCanvasElement;
        ctx: CanvasRenderingContext2D;
        particles: { x: number; y: number; vx: number; vy: number; life: number; color: string }[];
        width!: number;
        height!: number;
        
        constructor(canvas: HTMLCanvasElement) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d')!;
            this.particles = [];
            this.resize();
            this.animate();
            
            const observer = new ResizeObserver(() => this.resize());
            observer.observe(canvas);
        }

        resize() {
            this.width = this.canvas.width = this.canvas.clientWidth;
            this.height = this.canvas.height = this.canvas.clientHeight;
        }

        spawn() {
            const cx = this.width / 2;
            const cy = this.height / 2;
            // Dimensions of the door frame (approximate) - match CSS var --door-w/h
            const dw = 280;
            const dh = 420;
            const hw = dw / 2;
            const hh = dh / 2;

            // Pick a random side
            const side = Math.floor(Math.random() * 4);
            let x = 0, y = 0, vx = 0, vy = 0;
            // Higher speed for wider scattering
            const speed = Math.random() * 3 + 1.5; 

            if (side === 0) { // Top Edge
                x = cx - hw + Math.random() * dw;
                y = cy - hh;
                vx = (Math.random() - 0.5); 
                vy = -speed; // Up
            } else if (side === 1) { // Right Edge
                x = cx + hw;
                y = cy - hh + Math.random() * dh;
                vx = speed; // Right
                vy = (Math.random() - 0.5);
            } else if (side === 2) { // Bottom Edge
                x = cx - hw + Math.random() * dw;
                y = cy + hh;
                vx = (Math.random() - 0.5);
                vy = speed; // Down
            } else { // Left Edge
                x = cx - hw;
                y = cy - hh + Math.random() * dh;
                vx = -speed; // Left
                vy = (Math.random() - 0.5);
            }

            this.particles.push({
                x, y, vx, vy,
                life: 1.0,
                // Pinkish with variation
                color: `rgba(240, 117, 174, ${Math.random() * 0.4 + 0.6})`
            });
        }

        animate() {
            this.ctx.clearRect(0, 0, this.width, this.height);
            
            // Spawn MANY particles per frame for "Dense Ring" effect
            for(let i=0; i<8; i++) this.spawn();

            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02; // Slower fade = longer visible trail

                if (p.life <= 0) {
                    this.particles.splice(i, 1);
                    continue;
                }

                this.ctx.globalAlpha = p.life;
                this.ctx.fillStyle = p.color;
                this.ctx.beginPath();
                // Larger particles
                this.ctx.arc(p.x, p.y, Math.random() * 2 + 1, 0, Math.PI * 2);
                this.ctx.fill();
            }
            this.ctx.globalAlpha = 1;

            requestAnimationFrame(() => this.animate());
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        // Init Background Meteors
        const meteorsContainer = document.getElementById("meteors-container");
        if (meteorsContainer) {
            const createMeteor = () => {
                const meteor = document.createElement("div");
                meteor.classList.add("meteor");
                meteor.style.left = `${Math.random() * 120}%`;
                meteor.style.top = `${Math.random() * 100 - 50}%`;
                meteor.style.width = `${Math.random() * 100 + 50}px`;
                meteor.style.animationDuration = `${Math.random() * 1 + 1}s`;
                meteorsContainer.appendChild(meteor);
                setTimeout(() => meteor.remove(), 2000);
            };
            setInterval(createMeteor, 300);
        }

        // Init Canvases
        document.querySelectorAll('.starfield-canvas').forEach(canvas => {
            new StarfieldEngine(canvas as HTMLCanvasElement);
        });
        document.querySelectorAll('.particle-canvas').forEach(canvas => {
            new ParticleAuraDisplay(canvas as HTMLCanvasElement);
        });
    });
</script>

<style>
    :root {
        --door-w: 280px;
        --door-h: 420px;
        --tunnel-depth: 400px;
        --primary-bg: #fafffa; /* ZJU Default Background */
        --primary-text: #333;
    }

    /* FIX: Scrollbar Jitter */
    body, html {
        margin: 0; padding: 0;
        overflow-x: hidden; width: 100%;
    }

    .tech-page {
        min-height: 100vh;
        padding: 6rem 2rem;
        background: var(--primary-bg);
        color: var(--primary-text);
        position: relative;
        /* Ensure no overflow from 3D elements */
        overflow-x: hidden;
        overflow-y: hidden; 
    }

    /* Common UI Elements */
    .back-button {
        position: fixed; top: 100px; left: 2rem; z-index: 100;
        display: flex; align-items: center; gap: 8px; padding: 12px 20px;
        background: rgba(255, 240, 245, 0.7); backdrop-filter: blur(10px);
        border: 1px solid rgba(240, 117, 174, 0.3); border-radius: 50px;
        color: #f075ae; text-decoration: none; transition: 0.3s;
    }
    .back-button:hover { background: rgba(240, 117, 174, 0.2); }

    .page-header { text-align: center; margin-bottom: 5rem; position: relative; z-index: 10; }
    .page-title {
        font-size: 3.5rem; font-weight: 800; margin-bottom: 0.5rem;
        background: linear-gradient(120deg, #f075ae, #a18cd1);
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .page-subtitle { color: #555; font-size: 1.1rem; }

    /* Meteors */
    #meteors-container { position: fixed; inset: 0; pointer-events: none; }
    :global(.meteor) {
        position: absolute; height: 2px;
        background: linear-gradient(90deg, #a18cd1, transparent);
        opacity: 0; transform: rotate(-45deg);
        animation: shower linear;
    }
    @keyframes shower {
        0% { opacity: 0; transform: rotate(-45deg) translateX(0); }
        10% { opacity: 0.7; }
        100% { opacity: 0; transform: rotate(-45deg) translateX(-1000px); }
    }

    /* --- The Door Assembly --- */
    .doors-container {
        display: flex; justify-content: center; gap: 6rem; flex-wrap: wrap;
        perspective: 2000px; z-index: 10; position: relative;
        max-width: 100%;
    }

    .door-wrapper {
        display: flex; flex-direction: column; align-items: center; gap: 2rem;
        position: relative;
    }

    .door-label-top { text-align: center; max-width: 260px; z-index: 20; pointer-events: none;}
    .door-label-top h3 { font-size: 1.6rem; margin: 0 0 0.5rem 0; color: #222; }
    .door-label-top p { color: #666; font-size: 0.9rem; margin: 0; }

    /* The interactive container */
    .door-cube-scene {
        width: 450px; height: 600px; /* Bounding box for particles */
        position: relative;
        display: flex; justify-content: center; align-items: center;
        perspective: 1000px; /* Stronger perspective */
        text-decoration: none;
        overflow: visible; /* Allow particles to fly out */
    }

    /* Particle Canvas Layer */
    .particle-canvas {
        position: absolute; inset: 0; pointer-events: none; z-index: 15;
    }

    /* The 3D Cube Assembly */
    .cube-assembly {
        width: var(--door-w); height: var(--door-h);
        position: relative;
        transform-style: preserve-3d;
        transform: rotateY(-15deg); 
        transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    }
    
    .door-cube-scene:hover .cube-assembly {
        transform: rotateY(0deg) scale(1.02);
    }

    /* Faces */
    .face { position: absolute; backface-visibility: hidden; }

    /* Front Frame (Visible now!) */
    .front-frame {
        width: 100%; height: 100%;
        /* Metallic / Glassy Border to be visible on light bg */
        border: 4px solid #aaa; 
        background: rgba(0,0,0,0.1);
        box-shadow: 0 0 15px rgba(0,0,0,0.2);
        transform: translateZ(0);
        pointer-events: none;
        z-index: 10;
        border-radius: 2px;
    }

    /* Tunnel Walls - Standard CSS 3D */
    .tunnel-wall { position: absolute; backface-visibility: hidden; }

    .tunnel-wall.left {
        width: var(--tunnel-depth); height: 100%;
        background: linear-gradient(90deg, #222, #000);
        transform-origin: left; transform: rotateY(90deg); left: 0; top: 0;
    }
    .tunnel-wall.right {
        width: var(--tunnel-depth); height: 100%;
        background: linear-gradient(-90deg, #222, #000);
        transform-origin: right; transform: rotateY(-90deg); right: 0; top: 0;
    }
    .tunnel-wall.top {
        width: 100%; height: var(--tunnel-depth);
        background: linear-gradient(180deg, #222, #000);
        transform-origin: top; transform: rotateX(-90deg); top: 0; left: 0;
    }
    .tunnel-wall.bottom {
        width: 100%; height: var(--tunnel-depth);
        background: linear-gradient(0deg, #222, #000);
        transform-origin: bottom; transform: rotateX(90deg); bottom: 0; left: 0;
    }

    /* Back Screen (Canvas) */
    .back-screen {
        width: 100%; height: 100%;
        background: #000;
        transform: translateZ(calc(-1 * var(--tunnel-depth)));
        display: flex; overflow: hidden;
    }
    
    .starfield-canvas { width: 100%; height: 100%; }

    /* Enter Button */
    .enter-btn {
        margin-top: 1rem; padding: 10px 40px;
        border: 2px solid var(--primary-text);
        color: var(--primary-text);
        border-radius: 4px; text-decoration: none;
        letter-spacing: 2px; font-weight: 700; transition: 0.3s;
    }
    .enter-btn:hover {
        background: #f075ae; border-color: #f075ae;
        color: #fff; box-shadow: 0 0 20px rgba(240, 117, 174, 0.4);
    }
</style>
