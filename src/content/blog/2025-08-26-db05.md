---
title: "数据库系统05:关系数据库设计理论"
description: ""
pubDate: "2025-08-26"
heroImage: ""
---

# 数据库系统05:关系数据库设计理论

### **引言：从“能用”到“好用”——设计的进化**

上一讲，我们学会了如何将E-R模型转换为关系模式（一系列的表）。这解决了“从无到有”的问题，我们的数据库现在“能用”了。但“能用”距离“好用”甚至“健壮”还相去甚远。

让我们来看一个看似合理的“大一统”表设计：

**Lending-Schema** (`branch_name`, `branch_city`, `assets`, `customer_name`, `loan_number`, `amount`)

这个表包含了银行分支、客户和贷款的所有信息。直觉上，把相关信息放在一起似乎很方便。但这种“方便”背后隐藏着巨大的危机。

**探究“坏设计”的症状 (The Symptoms of Bad Design):**

1.  **数据冗余 (Data Redundancy):** 如果一个分行（如'Perryridge'分行）有多笔贷款，那么它的`branch_city`和`assets`信息将在每一条贷款记录中重复出现。
2.  **更新异常 (Update Anomaly):** 如果'Perryridge'分行搬迁到了一个新的城市，你需要修改**所有**与该分行相关的贷款记录。如果遗漏了任何一条，就会导致数据不一致（同一个分行在数据库里显示在两个不同的城市）。
3.  **插入异常 (Insertion Anomaly):** 如果银行新开设了一个分行，但在该分行还没有任何贷款业务之前，我们**无法**将这个分行的信息（`branch_name`, `branch_city`, `assets`）存入这张表。因为没有贷款，`customer_name`, `loan_number`等字段将为`NULL`，而这些可能是主键的一部分，从而无法插入。我们被迫在没有业务发生时，无法记录一个客观存在的事物。
4.  **删除异常 (Deletion Anomaly):** 如果客户还清了'Perryridge'分行的最后一笔贷款，我们在删除这条贷款记录的同时，可能会不经意地把'Perryridge'分行本身的所有信息（城市、资产）也从数据库中**永远抹去**了。

**设计哲学的核心问题：** 我们能否设计一种模式，使得“**一件事实在数据库中只被记录一次**”？这就是关系规范化理论（Normalization Theory）要解决的根本问题。其核心思想是**分解 (Decomposition)**：将一个大的、有问题的关系模式，拆分成多个小的、结构良好的关系模式。

### **第一部分：函数依赖 (Functional Dependencies)**

要科学地进行分解，我们不能凭感觉。我们需要一个数学工具来精确描述属性之间的约束关系。这就是**函数依赖 (FD)**。

#### **1.1 什么是函数依赖？**

*   **直观定义：** 如果属性集 $\\alpha$ 的值可以**唯一确定**属性集 $\\beta$ 的值，那么我们说 $\\beta$ **函数依赖于** $\\alpha$，记作 $\\alpha \\rightarrow \\beta$。
*   **形式化定义：** 在关系模式 $R$ 的任意一个合法实例 $r$ 中，对于任意两个元组 $t\_1, t\_2 \\in r$，如果 $t\_1\[\\alpha\] = t\_2\[\\alpha\]$，那么必然有 $t\_1\[\\beta\] = t\_2\[\\beta\]$。

**在Lending-Schema中的例子：**

*   `branch_name` $\\rightarrow$ `branch_city`, `assets` (分行名称唯一确定了其所在城市和资产)
*   `loan_number` $\\rightarrow$ `amount`, `branch_name` (贷款号唯一确定了贷款金额和所属分行)

**FD与键的关系：**

*   **超键 (Superkey):** 如果 $K \\rightarrow R$（即K能决定关系R中的所有属性），则K是R的一个超键。
*   函数依赖是比“键”更普遍、更精细的约束。一个表中可能存在大量非键的函数依赖，而这些正是导致异常的“罪魁祸首”。

#### **1.2 推理的法则：Armstrong公理**

给定的FD集合（如从业务需求中直接得出的）通常是不完备的。我们可以从已知的FD推导出更多隐含的FD。Armstrong公理是这个推理系统的基础，它**是可靠的（sound）和完备的（complete）**。

*   **自反律 (Reflexivity):** 若 $\\beta \\subseteq \\alpha$，则 $\\alpha \\rightarrow \\beta$。（平凡依赖）
*   **增补律 (Augmentation):** 若 $\\alpha \\rightarrow \\beta$，则 $\\gamma\\alpha \\rightarrow \\gamma\\beta$。（在等式两边加上相同属性）
*   **传递律 (Transitivity):** 若 $\\alpha \\rightarrow \\beta$ 且 $\\beta \\rightarrow \\gamma$，则 $\\alpha \\rightarrow \\gamma$。（依赖的传递）

**由这三条基本公理可以推导出一些非常有用的次要规则：**

*   **合并律 (Union):** 若 $\\alpha \\rightarrow \\beta$ 且 $\\alpha \\rightarrow \\gamma$，则 $\\alpha \\rightarrow \\beta\\gamma$。
*   **分解律 (Decomposition):** 若 $\\alpha \\rightarrow \\beta\\gamma$，则 $\\alpha \\rightarrow \\beta$ 且 $\\alpha \\rightarrow \\gamma$。

#### **1.3 属性闭包 ($\\alpha^+$) 与 依赖集闭包 ($F^+$)**

*   **属性集闭包 ($\\alpha^+$):** 给定FD集 $F$，属性集 $\\alpha$ 的闭包 $\\alpha^+$ 是指所有能被 $\\alpha$ 函数决定的属性的集合。
    
    *   **计算算法：**
        1.  `result = α`
        2.  `repeat`
        3.  ```
            `for each FD β → γ in F do`
            ```
            
        4.  ```
               `if β ⊆ result then result = result ∪ γ`
            ```
            
        5.  `until result does not change`
    *   **设计哲学应用：** 属性闭包是极其有用的计算工具。
        *   **判断超键：** 如果 $\\alpha^+$ 包含了关系模式R的所有属性，那么 $\\alpha$ 就是R的一个超键。
        *   **检查FD：** 要判断 $\\alpha \\rightarrow \\beta$ 是否被F所蕴含，只需计算 $\\alpha^+$，然后检查是否 $\\beta \\subseteq \\alpha^+$。
*   **规范覆盖 (Canonical Cover):** 一个FD集F可能包含冗余信息。规范覆盖 $F\_c$ 是与F等价的、**最小化**的FD集。寻找规范覆盖的过程，就像给一个复杂的代数表达式进行化简，这对于后续的分解算法至关重要。
    

### **第二部分：分解**

将一个关系 $R$ 分解成 $R\_1, R\_2, \\ldots, R\_n$。什么样的分解才是“好”的分解？我们必须遵循两个黄金准则。

#### **2.1 准则一：无损连接分解 (Lossless-Join Decomposition)**

*   **要求：** 分解后的关系，通过自然连接，必须能够**精确地、不多不少地**恢复出原始关系。
    *   $r = \\Pi\_{R\_1}(r) \\bowtie \\Pi\_{R\_2}(r) \\bowtie \\ldots \\bowtie \\Pi\_{R\_n}(r)$
*   **为什么重要？** 如果连接是有损的（即连接后的结果比原始表多出了 spurious tuples——伪元组），那么我们就**丢失了信息**——我们不再知道哪些是原始的、合法的关联。这破坏了数据的完整性。
*   **判定定理 (针对两表分解):** 将R分解为$R\_1$和$R\_2$是无损的，当且仅当 $(R\_1 \\cap R\_2) \\rightarrow R\_1$ 或 $(R\_1 \\cap R\_2) \\rightarrow R\_2$ 在F中成立。
    *   **直观解释：** 两个子模式的**公共属性**，必须是其中至少一个子模式的**超键**。这个公共属性就像一个“拉链”，能够保证在连接时，每一部分都能准确地找到它唯一的对应部分。

#### **2.2 准则二：依赖保持分解 (Dependency-Preserving Decomposition)**

*   **要求：** 原始关系R上的所有函数依赖F，在分解后，仍然可以在**单个**子关系 $R\_i$ 上进行检查。
*   **为什么重要？** 这是**性能**和**数据一致性**的关键。如果一个FD $\\alpha \\rightarrow \\beta$ 在分解后，$\\alpha$ 和 $\\beta$ 分散在不同的表中，那么每次插入或更新数据时，为了检查这个FD是否被违反，DBMS将不得不执行一个**昂贵的JOIN操作**来把它们重新组合起来。如果依赖是保持的，检查就可以在单个表内部高效完成。

**设计哲学中的核心权衡：** 追求最高范式（如BCNF）可以最大程度消除冗余，但有时会**牺牲依赖保持**。而稍作妥协（如降到3NF）则可以**保证依赖保持**，但可能**引入少量冗余**。这是数据库设计中一个永恒的、需要根据具体场景进行权衡的经典问题。

### **第三部分：范式 (Normal Forms)**

范式是一系列逐步增强的“健康标准”，用来衡量一个关系模式的设计质量。

#### **3.1 第一范式 (1NF)**

*   **定义：** 关系中所有属性的域都必须是**原子的**。
*   **设计哲学：** 这是关系模型的基石。它确保了表是一个真正的二维结构，简化了数据处理。我们在E-R模型转换时已经讨论过如何通过创建新表来处理多值属性，从而满足1NF。

#### **3.2 Boyce-Codd范式 (BCNF)**

*   **定义：** 对于关系模式R上成立的**每一个**非平凡函数依赖 $\\alpha \\rightarrow \\beta$，$\\alpha$都必须是R的一个**超键**。
*   **直观解释：** 任何一个属性或属性组，都不能决定其他任何属性，除非它本身就是（包含）一个候选键。**“键值决定一切，非键不能决定任何东西”**。
*   **优点：** BCNF能够消除所有由函数依赖引起的冗余。
*   **BCNF分解算法：**
    
    1.  `result = {R}`
    2.  `while result 中存在不满足 BCNF 的模式 Ri:`
    3.  ```
         `在 Ri 中找到一个违反 BCNF 的 FD α → β`
        ```
        
    4.  ```
         `将 Ri 分解为 R1 = (αβ) 和 R2 = (Ri - β)`
        ```
        
    5.  ```
         `result = (result - Ri) ∪ {R1, R2}`
        ```
        
    
    *   这个算法保证是**无损连接**的，并且最终结果中的所有关系都满足BCNF。

#### **3.3 第三范式 (3NF)**

*   **BCNF的问题：** 存在一种情况，BCNF分解无法同时满足无损连接和依赖保持。
    *   **经典例子：** `(J, K, L)`，`F = {JK → L, L → K}`。这个模式不满足BCNF因为 `L → K` 中 `L` 不是超键。但任何将其分解为BCNF的尝试都会破坏 `JK → L` 这个依赖的保持性。
*   **3NF的定义：** 对于关系模式R上成立的**每一个**非平凡函数依赖 $\\alpha \\rightarrow \\beta$，必须满足以下**之一**：
    1.  $\\alpha$ 是R的一个超键。（同BCNF）
    2.  $\\beta - \\alpha$ 中的每一个属性，都包含在R的**某个候选键**中。（即 $\\beta$ 的每个非 $\\alpha$ 属性都是“主属性”）
*   **设计哲学：** 3NF是对BCNF的一个**微小放宽**。它允许一种特殊的、不会引起太多问题的依赖存在：**非主属性对键的传递依赖**。这种放宽的唯一目的，就是为了**确保分解总是能保持依赖**。
*   **BCNF vs. 3NF：**
    *   所有BCNF模式都是3NF模式。
    *   BCNF消除了所有FD冗余，但可能不保持依赖。
    *   3NF保证无损连接和依赖保持，但可能存在少量冗余。在现实世界中，如果依赖保持至关重要，设计到3NF通常是更务实的选择。

#### **3.4 第四范式 (4NF) - 超越函数依赖**

*   **问题引入：** 即使一个模式达到了BCNF，它仍可能存在冗余。
    *   **示例：** `classes(course, teacher, book)`。假设一门课可以由多个老师教，同时需要多本参考书，且老师和参考书之间没有直接关系。例如：'数据库'课由Avi和Hank教，需要《DB Concepts》和《Ullman》两本书。
    *   **冗余：** 为了记录这些信息，我们必须存储所有组合：`(database, Avi, DB Concepts)`, `(database, Avi, Ullman)`, `(database, Hank, DB Concepts)`, `(database, Hank, Ullman)`。这造成了大量的冗余。
*   **多值依赖 (Multivalued Dependency - MVD):**
    *   **概念：** 如果给定一个 $\\alpha$ 的值，有一组与之关联的 $\\beta$ 值，这组 $\\beta$ 值**完全独立于**关系中的任何其他属性 $\\gamma$。记作 $\\alpha \\twoheadrightarrow \\beta$。
    *   **在示例中：** `course` $\\twoheadrightarrow$ `teacher` 且 `course` $\\twoheadrightarrow$ `book`。
*   **第四范式 (4NF) 定义：** 对于关系模式R上成立的**每一个**非平凡多值依赖 $\\alpha \\twoheadrightarrow \\beta$，$\\alpha$都必须是R的一个**超键**。
*   **设计哲学：** 4NF旨在消除由多值依赖引起的冗余。其解决方案仍然是分解：将 `(course, teacher, book)` 分解为 `(course, teacher)` 和 `(course, book)`。