---
title: "数据库系统03:高级SQL"
description: ""
pubDate: "2025-08-26"
heroImage: ""
---

# 数据库系统03:高级SQL

### **引言：从“问问题”到“定规则”**

在前几讲，我们学习了如何使用SQL向数据库“提问”。但一个真正强大的数据库系统，不仅仅是一个被动的问答机。它应该是一个有原则、有纪律、能自我保护的智能体。

*   如果一项业务规则（例如，“员工工资不能超过其经理的工资”）需要在100个不同的应用程序中被遵守，我们应该在哪里强制执行这条规则？是在100个应用程序里分别编写代码，还是在数据的源头——数据库中，只定义一次？
*   如果一个用户只需要查看员工的姓名和部门，我们应该如何防止他接触到敏感的薪资信息？
*   当我们的应用程序（用Java或C++编写）需要与数据库进行复杂的数据交换时，最佳的“翻译”和“沟通”方式是什么？

这些问题，将我们带入了高级SQL的世界。本讲，我们将学习如何使用SQL来**定义规则、保障安全、并与外部世界无缝集成**。

### **第一部分：扩展数据类型与模式**

标准的数据类型（INT, VARCHAR等）是数据库的“基本词汇”，但现实世界远比这复杂。高级SQL允许我们创造自己的“词汇”，让数据模型更精确地反映业务领域。

#### **1.1 域约束 (`CREATE DOMAIN`)**

想象一下，在你的系统中，有多个表都包含“时薪”这个字段，并且业务规定时薪必须大于等于4.00。

**糟糕的设计**：在每个表的`hourly_wage`列上都写一个`CHECK (hourly_wage >= 4.00)`。

*   **问题**：代码重复。如果未来业务规则改变（比如最低时薪提高到5.00），你需要在所有地方手动修改，极易出错和遗漏。

**优雅的设计 (`CREATE DOMAIN`)**:

```
CREATE DOMAIN hourly_wage AS NUMERIC(5, 2)
    CONSTRAINT value_test CHECK (VALUE >= 4.00);

CREATE TABLE employee (
    emp_id    CHAR(10) PRIMARY KEY,
    -- ...
    wage      hourly_wage  -- 使用我们定义的域
);
```

*   **设计哲学：DRY (Don't Repeat Yourself)。** `CREATE DOMAIN` 本质上是创建了一个**带约束的、可复用的自定义类型别名**。它将数据类型和与之关联的完整性规则封装在一起。当业务规则变化时，只需修改`DOMAIN`的定义，所有使用该域的列将自动继承新规则。这是将业务语义与物理实现分离的绝佳体现。

#### **1.2 用户定义类型 (`CREATE TYPE`)**

关系模型要求原子性（第一范式），但有时现实世界的实体本身就是结构化的（比如地址，包含国家、省、市、街道）。

```
CREATE TYPE person_name AS (
    first_name VARCHAR(50),
    last_name  VARCHAR(50)
);

CREATE TABLE student (
    sno   CHAR(10) PRIMARY KEY,
    sname person_name, -- 使用结构化类型
    -- ...
);

-- 查询时可以访问其内部结构
SELECT (sname).first_name FROM student WHERE sno = '...';
```

*   **设计哲学：从关系到对象关系的演进。** UDT是SQL对面向对象思想的一种接纳，允许我们以更自然的方式对复杂实体建模。这使得SQL的能力从处理简单的标量值扩展到了处理结构化数据。这在PostgreSQL等现代对象-关系数据库中得到了广泛支持。

#### **1.3 大对象 (LOBs)：容纳非结构化数据**

关系数据库的核心是结构化数据，但我们如何存储像用户头像（图片）、简历（PDF）、视频这样的二进制文件？

*   `BLOB` (Binary Large Object): 存储二进制数据。
*   `CLOB` (Character Large Object): 存储大量的文本数据。

```
CREATE TABLE students (
    sid   CHAR(10) PRIMARY KEY,
    photo BLOB(20M),
    cv    CLOB(10K)
);
```

*   **设计哲学：指针与实体的分离。** 在数据库表中直接存储一个20MB的文件是灾难性的，这会使表扫描变得极其缓慢。LOBs的实现机制是，在表中只存储一个指向实际大对象数据的**定位器（locator）或指针**。数据本身则存储在数据库管理的另一个专门区域。
    *   **优点**：保持主表记录的短小精悍，查询和扫描主表非常快。
    *   **缺点**：获取LOB数据需要一次额外的I/O操作（通过指针去读取）。
    *   这是空间和时间效率之间的一个经典权衡。

### **第二部分：高级完整性约束**

这是本讲的核心。我们将探讨如何定义超越单一表、甚至全局性的复杂业务规则。

#### **2.1 参照完整性 (`FOREIGN KEY`) 的高级策略**

当被参照表（如`department`）中的一行被删除或主键被更新时，参照表（如`employee`）中依赖于它的行该何去何从？SQL提供了精细的控制策略：

```
CREATE TABLE employee (
    -- ...
    FOREIGN KEY (dept_id) REFERENCES department(dept_id)
        ON DELETE SET NULL
        ON UPDATE CASCADE
);
```

*   **`ON DELETE`/`ON UPDATE` 策略：**
    
    *   **`RESTRICT` (或 `NO ACTION`，默认行为)**：**保守策略**。如果存在引用的行，则禁止删除/更新操作。这是最安全的，但可能不符合业务需求。
    *   **`CASCADE`**: **级联策略**。如果`department`中某部门被删除，所有属于该部门的`employee`记录也**自动被删除**。如果部门ID更新，员工表中的`dept_id`也**自动更新**。适用于强“拥有”关系（如订单与订单项）。
    *   **`SET NULL`**: **解绑策略**。如果某部门被删除，属于该部门的员工的`dept_id`字段被**自动设为NULL**。适用于可选的、非关键的联系。
    *   **`SET DEFAULT`**: **回退策略**。将`dept_id`设为一个预定义的默认值（如“未分配部门”）。
*   **设计哲学：将业务逻辑编码到数据模型中。** 这些策略允许数据库设计者将“当X发生时，Y应该如何处理”这类业务流程，直接声明在表结构中。这比在每个可能删除部门的应用代码中去手动处理员工记录要可靠得多。
    

#### **2.2 断言 (`CREATE ASSERTION`)**

`CHECK`和`FOREIGN KEY`都是针对一张或两张表的约束。如果一个约束需要横跨多张表，甚至涉及聚合计算呢？

**场景示例：**

1.  “一个班级的学生总数不能超过30人。” (涉及`student`和`takes`表)
2.  “所有员工的总工资不能超过公司年度预算的70%。” (涉及`employee`和`budget`表)

这些约束无法用常规手段表达。断言应运而生：

```
CREATE ASSERTION sum_credits_assertion CHECK (
    NOT EXISTS (
        SELECT *
        FROM student s
        WHERE 100 <> (SELECT SUM(credits)
                      FROM takes t, course c
                      WHERE t.s_id = s.s_id AND t.course_id = c.course_id)
    )
);
```

_(这是一个复杂的例子，意在说明其能力)_

*   **设计哲学：全局不变性的保证。** 断言是数据库级别的、全局的谓词，它必须在**任何**数据修改操作（`INSERT`, `UPDATE`, `DELETE`）之后都保持为真。如果任何操作可能导致断言失败，该操作将被**回滚**。
*   **现实世界的权衡：性能的巨大代价。** 因为断言的全局性，DBMS在每次可能影响断言的数据修改后，都必须重新对断言的查询进行求值。对于复杂的断言，这个开销是极其巨大的，可能导致系统性能急剧下降。因此，**尽管断言在理论上非常强大，但在商业数据库系统中很少被完整实现和使用。** 现实世界中，这类复杂约束通常通过**触发器**或在**应用层**的事务中来保证。

#### **2.3 触发器 (`TRIGGER`)**

如果说断言是静态的“法律”，那么触发器就是动态的“行为规则”。它定义了当特定事件发生时，数据库应**自动执行**的一系列操作。

**触发器的核心组成：**

1.  **事件 (Event):** `INSERT`, `DELETE`, `UPDATE`。
2.  **时机 (Timing):** `BEFORE` (事件发生前) 或 `AFTER` (事件发生后)。
3.  **粒度 (Granularity):** `FOR EACH ROW` (行级触发器) 或 `FOR EACH STATEMENT` (语句级触发器)。
4.  **条件 (Condition):** (可选) `WHEN (...)` 子句，只有满足条件时才触发。
5.  **动作 (Action):** 一个SQL代码块 (`BEGIN ... END;`)。

**经典示例：银行账户透支自动转为贷款**

```
CREATE TRIGGER overdraft_trigger
AFTER UPDATE ON account
REFERENCING NEW ROW AS nrow, OLD ROW AS orow -- 引用新旧行数据
FOR EACH ROW
WHEN (nrow.balance < 0) -- 只有当新余额为负时
BEGIN ATOMIC
    -- 1. 将客户信息和贷款号插入borrower表
    INSERT INTO borrower(customer_name, loan_number)
        SELECT D.customer_name, nrow.account_number
        FROM depositor D
        WHERE D.account_number = nrow.account_number;

    -- 2. 创建一笔与透支额等值的贷款
    INSERT INTO loan(loan_number, branch_name, amount)
        VALUES(nrow.account_number, nrow.branch_name, -nrow.balance);

    -- 3. 将原账户余额重置为0
    UPDATE account SET balance = 0 WHERE account_number = nrow.account_number;
END;
```

*   **设计哲学与权衡：数据库 vs. 应用层逻辑**
    
    *   **何时使用触发器？**
        *   **数据为中心的逻辑：** 当一个业务规则与数据本身紧密相关，且无论通过哪个应用访问都必须被强制执行时（如审计日志、维护冗余的汇总数据）。
        *   **原子性要求高：** 当一系列操作必须作为一个不可分割的整体发生时。
    *   **触发器的陷阱（“隐形逻辑”）：**
        *   **可维护性差：** 业务逻辑被隐藏在数据库深处，对不熟悉数据库的开发者来说如同“黑魔法”，难以调试和理解。
        *   **性能问题：** 设计不佳的触发器（特别是行级触发器处理大量更新时）会严重拖慢DML操作。
        *   **级联噩梦：** 一个触发器可能触发另一个表的更新，进而触发第三个触发器，形成复杂的“触发器链”，极难追踪。
*   **行级 vs. 语句级：**
    
    *   **行级 (`FOR EACH ROW`)**: 每次修改一行，触发器动作就执行一次。可以访问被修改行的`NEW`和`OLD`值。适合需要对每一行进行精细化处理的场景。
    *   **语句级 (`FOR EACH STATEMENT`)**: 一条DML语句（即使影响了1000行）只触发一次。无法访问单行的`NEW`/`OLD`值，但可以访问到一个包含所有被修改行的临时表（如SQL Server中的`inserted`/`deleted`表）。适合进行批量统计和汇总。

### **第三部分：授权与访问控制**

数据库安全的核心是**最小权限原则**：只授予用户完成其工作所必需的最少权限。

#### **3.1 `GRANT` 和 `REVOKE`：权限的授予与回收**

*   **授权 (`GRANT`):**
    
    ```
    -- 授予Alice对student表的查询和插入权限
    GRANT SELECT, INSERT ON student TO alice;
    
    -- 允许Bob创建表
    GRANT CREATE TABLE TO bob;
    
    -- 授予所有用户对某个视图的查询权限
    GRANT SELECT ON public_student_info TO PUBLIC;
    
    -- 允许Charlie将他获得的权限再授予别人
    GRANT SELECT ON department TO charlie WITH GRANT OPTION;
    ```
    
*   **回收 (`REVOKE`):**
    
    ```
    REVOKE INSERT ON student FROM alice;
    
    -- 级联回收
    REVOKE SELECT ON department FROM charlie CASCADE; -- 会同时回收charlie授予出去的权限
    ```
    
*   **设计哲学：精确到操作级的权限控制。** SQL的授权模型非常精细，可以控制到表/视图级别上的`SELECT`, `INSERT`, `UPDATE`, `DELETE`等具体操作。`WITH GRANT OPTION`引入了权限的委托和传递，但也带来了级联回收的复杂性。
    

#### **3.2 角色 (`ROLE`)**

为每个用户单独`GRANT`权限是一场管理噩梦。当一个新员工入职时，你需要知道他应该拥有哪20种权限。

**角色 (`ROLE`)** 是解决这个问题的关键。

```
-- 1. 创建角色
CREATE ROLE instructor_role;
CREATE ROLE student_role;

-- 2. 给角色授权
GRANT SELECT ON department TO instructor_role;
GRANT UPDATE(grade) ON takes TO instructor_role;
GRANT SELECT ON course TO student_role;

-- 3. 将角色授予用户
GRANT instructor_role TO 'einstein';
GRANT student_role TO 'alan_turing';
```

*   **设计哲学：用户与权限的解耦。** 角色是权限的**集合**。管理员不再直接管理用户的权限，而是管理角色的权限，然后将角色分配给用户。这极大地简化了权限管理：
    *   新员工入职：授予一个角色即可。
    *   员工离职：回收其角色即可。
    *   职位权限变更：修改角色的权限，所有拥有该角色的用户权限自动更新。

#### **3.3 视图 (`VIEW`) 作为安全机制**

视图不仅可以简化查询，更是一个强大的**行级/列级安全控制工具**。

**场景**：HR助理只能看到自己所在部门员工的非敏感信息。

```
-- 假设HR助理 'hr_asst_1' 属于 'HR' 部门
CREATE VIEW hr_employee_view AS
SELECT emp_id, emp_name, position
FROM employee
WHERE dept_name = 'HR'; -- 行级安全

-- 只授予对视图的查询权限
GRANT SELECT ON hr_employee_view TO hr_asst_1;

-- 禁止其直接访问基表
REVOKE SELECT ON employee FROM hr_asst_1;
```

*   **设计哲学：数据访问的“幕布”。** 视图为用户创建了一个定制化的、受限的数据视窗。用户以为自己在查询一张表，但实际上其访问被视图定义中的`WHERE`子句（行级安全）和`SELECT`列表（列级安全）悄无声息地过滤了。

### **第四部分：应用与数据库的交互**

SQL本身不具备流程控制、UI交互、网络通信等能力。它必须与通用的宿主语言（如C++, Java, Python）协同工作。

#### **4.1 嵌入式SQL (Embedded SQL)：“老派”的融合**

这是一种将SQL语句直接“嵌入”到C或COBOL等语言源代码中的技术。

```
/* C code with Embedded SQL */
EXEC SQL BEGIN DECLARE SECTION;
    char student_name[50];
    int  student_id;
EXEC SQL END DECLARE SECTION;

...
student_id = 12345;
EXEC SQL SELECT s_name INTO :student_name FROM student WHERE s_id = :student_id;
...
```

*   **工作流与设计哲学：预编译。**
    
    1.  **编写**: 程序员编写带有`EXEC SQL ...`块的源代码。
    2.  **预编译**: SQL预编译器扫描代码，将`EXEC SQL`块转换成对应数据库的API函数调用（如OCI调用），并将宿主语言变量（如`:student_name`）处理成函数参数。
    3.  **编译链接**: 标准的C/C++编译器编译生成的纯C/C++代码，并链接数据库客户端库。
    
    *   **游标 (Cursor) 的必要性**: 宿主语言一次只能处理一行数据，而SQL查询可能返回一个庞大的结果集。**游标**就是这个矛盾的解决方案，它扮演了结果集的“迭代器”角色。
        *   `DECLARE CURSOR`: 定义一个查询。
        *   `OPEN CURSOR`: 执行查询，准备好结果集。
        *   `FETCH ... INTO ...`: 从结果集中取出**一行**数据，放入宿主语言变量中。
        *   `CLOSE CURSOR`: 释放资源。
*   **优缺点：**
    
    *   **优点**：在编译时可以对SQL进行语法检查和优化，性能可能很高。
    *   **缺点**：代码可移植性差（与特定数据库的预编译器绑定），开发流程繁琐，不符合现代软件工程的模块化思想。如今已较少使用。

#### **4.2 ODBC & JDBC：现代的“标准连接器”**

**核心设计哲学：通过驱动程序实现统一的API抽象层。** 应用程序不再关心它连接的是Oracle、MySQL还是PostgreSQL。它只需要面向一个标准的API（ODBC或JDBC）编程。

*   **ODBC (Open Database Connectivity):**
    
    *   C语言风格的API，是事实上的跨语言标准。
    *   面向过程，通过句柄（handle）管理连接、语句等资源。
    *   需要配置DSN（数据源名称）来存储连接信息。
*   **JDBC (Java Database Connectivity):**
    
    *   Java平台的标准API，定义在`java.sql`包中。
    *   面向对象，核心类包括：
        *   `DriverManager`/`DataSource`: 获取数据库连接。
        *   `Connection`: 代表与数据库的一个会话。
        *   `Statement`/`PreparedStatement`: 执行SQL语句。`PreparedStatement`是**首选**，因为它预编译SQL，性能更好，并且能从根本上**防止SQL注入攻击**。
        *   `ResultSet`: 结果集的迭代器，功能类似于游标。

**JDBC 核心编程范式:**

```
// 1. 加载驱动 & 获取连接 (try-with-resources for automatic closing)
try (Connection conn = DriverManager.getConnection(URL, USER, PASS)) {
    // 2. 创建 PreparedStatement
    String sql = "SELECT s_name FROM student WHERE dept_name = ?";
    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
        // 3. 绑定参数
        pstmt.setString(1, "Comp. Sci.");

        // 4. 执行查询 & 获取 ResultSet
        try (ResultSet rs = pstmt.executeQuery()) {
            // 5. 遍历结果
            while (rs.next()) {
                String studentName = rs.getString("s_name");
                System.out.println(studentName);
            }
        }
    }
} catch (SQLException e) {
    e.printStackTrace();
}
```

*   **ODBC vs. JDBC 对比**
    *   强调JDBC的面向对象特性、异常处理机制、以及与Java语言的无缝集成是如何让它比ODBC更易用、更健壮。