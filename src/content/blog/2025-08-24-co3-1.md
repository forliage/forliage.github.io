---
title: "计算机组成3-1:数字的表示"
description: ""
pubDate: "2025-08-24"
heroImage: ""
---

# 计算机组成3-1:数字的表示

在高级编程语言（如C/C++或Java）中，我们习惯于直接使用 `int`, `unsigned int`, `float` 等数据类型，并理所当然地认为计算机“知道”如何对它们进行 `+`、`-`、`*`、`/` 等运算。但计算机本身只认识0和1。那么，这些我们习以为常的数据类型和运算是如何从底层的0和1构建起来的呢？

这就是我们这章要解决的核心问题。计算机中的**字 (Word)**，无论是32位还是64位，本质上都只是一个位的集合。这些位的组合本身没有任何意义，是**我们（设计计算机的人）赋予了它们意义**。这种“赋予意义”的过程，就是**约定（Convention）**。通过不同的约定，同一串二进制代码可以表示整数、浮点数、指令、内存地址，甚至是一段文字。

算术运算是计算机最核心的功能之一。它位于指令执行周期的核心环节：

1.  **取指 (Fetch):** 程序计数器 (PC) 指向内存，取出一条指令。
2.  **译码 (Decode):** 指令译码器分析指令，确定要执行的操作（例如，加法）以及操作数来自哪里（例如，寄存器`x5`和`x6`）。
3.  **执行 (Execute):** **算术逻辑单元 (ALU)** 根据指令的要求，对从寄存器中读出的数据执行算术或逻辑运算。
4.  **访存 (Memory):** 如果需要，访问内存进行读写。
5.  **写回 (Write-back):** 将执行结果写回目标寄存器。

我们就从理解ALU如何处理数字开始。

### **第一部分：数字的表示 (Representation of Numbers)**

在深入算术运算之前，我们必须先解决一个更根本的问题：如何在计算机中用二进制表示我们熟悉的数字，特别是负数？

#### **1.1 无符号整数 (Unsigned Integers)**

这是最简单的表示法。对于一个n位的二进制数 $(b\_{n-1}b\_{n-2}...b\_1b\_0)\_2$，它所代表的无符号整数的值为：

$Value = \\sum\_{i=0}^{n-1} b\_i \\times 2^i$

例如，一个8位的二进制数 `10011011`： $Value = 1 \\cdot 2^7 + 0 \\cdot 2^6 + 0 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$ $Value = 128 + 16 + 8 + 2 + 1 = 155$

对于一个n位的无符号整数，其表示范围是 $\[0, 2^n - 1\]$。

*   对于32位无符号整数，范围是 $\[0, 2^{32}-1\]$，大约是40亿。
*   这在计算机中常用于表示内存地址，因为地址没有负数的概念。

#### **1.2 带符号整数 (Signed Integers)**

现实世界充满了负数，计算机必须有能力处理它们。如何用二进制来表示正负呢？人们提出了多种方案，其中最重要的三种是：原码、反码和补码。

**1\. 方案一：原码 (Sign and Magnitude)**

这是最符合人类直觉的一种表示法。我们将最高有效位（Most Significant Bit, MSB）用作**符号位**：0代表正数，1代表负数。其余的位表示数值的**绝对值**。

*   例如，用8位原码表示：
    *   `+5` -> `00000101` (符号位为0，数值为5)
    *   `-5` -> `10000101` (符号位为1，数值为5)

**原码的缺陷：**

1.  **存在两个零：** `+0` -> `00000000`，`-0` -> `10000000`。这给判断一个数是否为零带来了不便。
2.  **算术运算复杂：** 在进行加法时，硬件需要先检查两个操作数的符号位。如果符号相同，则执行加法；如果符号不同，则需要执行减法，并且结果的符号取决于绝对值更大的那个数。这使得加法器的设计异常复杂。

由于这些缺陷，现代计算机几乎不使用原码来表示整数。

**2\. 方案二：反码 (One's Complement)**

反码是为了简化运算而提出的。

*   **正数：** 表示方法与原码和补码相同。
    
*   **负数：** 将其对应正数的数值位（除符号位外）**按位取反**。
    
*   例如，用8位反码表示：
    
    *   `+5` -> `00000101`
    *   `-5` -> `11111010` (对`00000101`除符号位外取反，有时也约定为全部位取反)

**反码的缺陷：**

*   **仍然存在两个零：** `+0` -> `00000000`，`-0` -> `11111111`。
*   **加法运算存在“循环进位”问题：** 当最高位产生进位时，需要将这个进位加到最低位上，这同样增加了硬件的复杂性。

**3\. 方案三：补码 (Two's Complement) - 现代计算机的标准**

补码是目前计算机系统中最普遍采用的整数表示方法，因为它完美地解决了原码和反码的缺陷。

*   **定义：**
    
    *   **正数：** 表示方法与原码相同。
    *   **负数：** 将其对应正数的**所有位按位取反，然后加1**。
*   例如，用8位补码表示 `-5`：
    
    1.  `+5` 的二进制表示是 `00000101`。
    2.  所有位按位取反得到 `11111010` (这其实是反码)。
    3.  加 1 得到 `11111011`。所以 `-5` 的8位补码表示是 `11111011`。
*   **从补码求原值：** 如果一个补码的符号位是1，说明它是一个负数。要求它的绝对值，可以再次执行“按位取反，末位加1”的操作。
    
    *   对 `11111011` 操作：
    
    1.  按位取反 -> `00000100`
    2.  末位加 1 -> `00000101`，即5。所以该数是-5。

**为什么补码如此优秀？**

**a. 唯一的零表示：** 在补码中，`+0` 是 `00000000`。我们来计算一下 `-0`：

1.  `+0` -> `00000000`
2.  取反 -> `11111111`
3.  加 1 -> `(1)00000000`。对于8位表示，最高位的进位被舍弃，结果仍然是 `00000000`。 这样，零的表示就唯一了。

**b. 统一的加减法运算：** 这是补码最神奇的特性。**硬件不需要区分加法和减法，也不需要关心操作数的符号**。减法 $A-B$ 可以直接转换为加法 $A+(-B)$，然后使用同一个加法器完成。

*   例如，计算 `5 - 3`，即 `5 + (-3)` (使用4位补码)：
    *   `+5` -> `0101`
    *   `+3` -> `0011` -> `-3` (取反`1100`，加1`1101`)
    *   `0101 + 1101 = (1)0010`。舍弃进位，结果是 `0010`，即 `+2`。完全正确！

**c. 数学原理：模运算 (Modular Arithmetic)** 补码的本质是模运算。可以把n位二进制数想象成一个容量为 $2^n$ 的时钟。

例如，对于一个4位系统（模为 $2^4=16$），数字 `15` (`1111`) 在这个时钟上与 `-1` 是等价的。因为从0点逆时针走1步（-1）和顺时针走15步（+15）到达的是同一个位置。 数学上，一个负数 $-X$ 的补码表示是 $2^n - X$。 我们知道 $X + \\bar{X} = 2^n - 1$。所以 $\\bar{X}+1 = 2^n - X$。这恰好就是“取反加一”的数学解释。

**补码的表示范围：** 对于n位补码，其表示范围是 $\[-2^{n-1}, 2^{n-1}-1\]$。

*   这是一个不对称的范围，负数比正数多一个。
*   例如8位补码范围是 $\[-128, 127\]$。`-128` 的补码是 `10000000`。

**各种表示法对比 (以4位为例):**

十进制

原码

反码

补码

+7

0111

0111

0111

...

...

...

...

+1

0001

0001

0001

+0

0000

0000

0000

\-0

1000

1111

(不存在)

\-1

1001

1110

1111

...

...

...

...

\-7

1111

1000

1001

\-8

(无法表示)

(无法表示)

1000

### **第二部分：整数的算术运算与ALU设计**

现在我们已经确立了使用补码来表示整数，接下来就可以设计能够执行运算的硬件了。

#### **2.1 整数加减法**

*   **加法:** 两个补码数直接相加，就像无符号数一样，从最低位开始，逐位相加并处理进位。
*   **减法:** 将减数B取补码（即求 $-B$），然后与被减数A相加。即 $A - B = A + (-B)$。

#### **2.2 溢出 (Overflow)**

当运算结果超出了n位补码所能表示的范围时，就会发生**溢出**。

*   **无符号数溢出：** 非常容易判断。当两个无符号数相加，**最高位产生了进位**（carry-out），就意味着发生了溢出。
    
    *   例如，8位无符号数 `255 + 1` (`11111111 + 00000001`)，结果是 `(1)00000000`，产生了进位，发生了溢出。
*   **带符号数（补码）溢出：** 判断稍微复杂一些，**不能简单地看最高位是否有进位**。
    
    *   `5 + (-3)` -> `0101 + 1101 = (1)0010`。有进位，但结果`+2`是正确的，没有溢出。
    
    **溢出的根本原因：** 结果的符号与我们期望的符号不一致。
    
    *   **正数 + 正数 = 负数** -> 溢出
        *   例如，8位补码中 `127 + 1` (`01111111 + 00000001 = 10000000`)，结果是-128。
    *   **负数 + 负数 = 正数** -> 溢出
        *   例如，8位补码中 `-128 + (-1)` (`10000000 + 11111111 = (1)01111111`)，结果是+127。
    *   **正数 + 负数** -> **永远不会溢出**。因为结果的绝对值一定小于或等于两个操作数中绝对值较大的那个。
    
    **硬件层面的判断方法：** 一个更通用的判断方法是比较**最高有效位（符号位）的进位（$C\_{in}$）**和**从最高有效位产生的进位（$C\_{out}$）**。 **如果 $C\_{in} \\neq C\_{out}$，则发生溢出。**
    
    *   例1: `7 + 1` (4位) -> `0111 + 0001`。符号位(第3位)的$C\_{in}=1$, $C\_{out}=0$。两者不等，发生溢出。
    *   例2: `(-2) + (-7)` (4位) -> `1110 + 1001`。符号位的$C\_{in}=0$, $C\_{out}=1$。两者不等，发生溢出。
    *   例3: `2 + (-5)` (4位) -> `0010 + 1011`。符号位的$C\_{in}=0$, $C\_{out}=0$。两者相等，未溢出。

**溢出处理：**

*   **在某些语言（如C）中，** 默认忽略整数溢出，这可能导致难以察觉的程序bug。
*   **在某些高级语言或特定模式下，** 溢出会触发一个**异常（Exception）**或**中断（Interrupt）**。CPU会暂停当前程序，跳转到操作系统预设的异常处理程序。此时，CPU会将导致异常的指令地址存入一个特殊寄存器（如MIPS中的`EPC`），以便操作系统处理完毕后能返回或终止程序。

#### **2.3 设计一个算术逻辑单元 (ALU)**

ALU是CPU的计算核心，它是一个组合逻辑电路，可以执行多种算术和逻辑运算。我们将从最简单的1位ALU开始，逐步构建一个完整的32位ALU。

**Step 1: 构造一个1位的逻辑单元**

我们希望ALU能执行`AND`和`OR`操作。我们可以用一个\*\*多路选择器（MUX）\*\*来实现。

*   输入：`a`, `b`，以及一个选择信号`Operation`。
*   输出：`Result`。
*   当`Operation = 0`时，`Result = a AND b`。
*   当`Operation = 1`时，`Result = a OR b`。

**Step 2: 构造一个1位的加法器**

要实现加法，我们需要一个**全加器（Full Adder）**。一个全加器有三个输入（`a`, `b`, `CarryIn`）和两个输出（`Sum`, `CarryOut`）。

*   $Sum = A \\oplus B \\oplus CarryIn$
*   $CarryOut = (A \\cdot B) + (CarryIn \\cdot (A \\oplus B))$

**Step 3: 组合逻辑单元和加法器，构成1位ALU**

现在，我们把逻辑运算和加法运算组合起来。我们可以用一个更大的MUX来选择输出结果。

*   `Operation`控制线扩展到2位，例如：
    *   `00`: `a AND b`
    *   `01`: `a OR b`
    *   `10`: `a + b`

**Step 4: 扩展1位ALU以支持减法**

我们知道 $A - B = A + (-B)$，而 $-B$ 的补码是 $\\bar{B} + 1$。

*   **$\\bar{B}$**：我们可以通过在b输入端增加一个反相器来实现。
*   **$+1$**：这个“+1”可以通过将全加器的第一个`CarryIn`设置为1来实现。

于是，我们引入一个新的控制信号`Bnegate`。

*   当`Bnegate = 0`时，ALU执行加法。b直接输入，`CarryIn`来自前一位。
*   当`Bnegate = 1`时，ALU执行减法。b被取反后输入，并且将最低位的`CarryIn`强制设为1。

**Step 5: 构造一个完整的32位ALU**

有了1位ALU的设计，我们就可以像搭积木一样把它串联起来，构成一个32位的ALU。这种最简单的设计被称为**行波进位加法器（Ripple-Carry Adder）**。

*   将32个1位ALU连接起来。
*   第 `i` 位的`CarryOut`连接到第 `i+1` 位的`CarryIn`。
*   所有1位ALU共享相同的控制线（`Operation`, `Bnegate`）。

**Step 6: 增加更多功能 - 比较和零检测**

*   **比较 (Set on Less Than, `slt`)**: `slt rd, rs, rt`指令的功能是：如果 `rs < rt`，则 `rd = 1`，否则 `rd = 0`。
    *   我们如何判断 `rs < rt`？ 只要计算 `rs - rt`，然后检查结果的符号位即可。如果结果为负，则 `rs < rt`。
    *   我们可以在最高位（第31位）的ALU上增加一个额外的输出`Less`，它直接与加法结果的符号位相连。对于`slt`操作，我们将这个`Less`信号扩展到32位（即`00...01`或`00...00`）作为最终输出。
*   **零检测 (Zero Detection)**: 很多指令需要判断运算结果是否为零（例如分支指令`beq`）。
    *   这可以通过一个巨大的或门（或者与非门）实现：将ALU所有32位的输出结果`Result`连接到这个门的输入。只有当`Result`所有位都为0时，`Zero`输出才为1。

**最终的ALU设计** 一个功能相对完整的ALU会包含以下输入和输出：

*   **输入:**
    *   `A[31:0]`, `B[31:0]`: 两个32位操作数。
    *   `ALUControl[3:0]`: 控制信号，决定执行何种操作 (AND, OR, ADD, SUB, SLT等)。
*   **输出:**
    *   `Result[31:0]`: 32位运算结果。
    *   `Zero`: 1位信号，当结果为0时为1。
    *   `Overflow`: 1位信号，当发生有符号溢出时为1。

**行波进位加法器的性能瓶颈** 虽然行波进位加法器设计简单，但它有一个致命的性能缺陷。计算最高位（例如第31位）的结果，必须等待第30位的`CarryOut`。而第30位又必须等待第29位，依此类推。这个进位信号就像波浪一样，从最低位“传播”到最高位。 因此，加法器的总延迟与位数 `n` 成正比，即 $O(n)$。对于64位甚至更宽的加法器，这种延迟是不可接受的。

**拓展思考：如何加速加法？** 为了解决这个问题，工程师们设计了更复杂的**高速加法器**，如**超前进位加法器 (Carry-Lookahead Adder, CLA)**。其核心思想是：不等待进位信号逐位传播，而是通过更复杂的逻辑电路“预先计算”出每一位的进位。我们将在下一部分详细探讨这些高级设计。

**本讲小结**

今天，我们完成了从抽象数字到具体硬件运算的第一步。

1.  我们理解了数字在计算机中的表示方式，并明确了为何**补码**在现代计算机中占据主导地位。
2.  我们探讨了整数加减法的实现，以及在运算中必须处理的**溢出**问题。
3.  我们从零开始，一步步设计了一个功能性的32位ALU，并了解了其最基本的设计——**行波进位加法器**，及其性能局限性。