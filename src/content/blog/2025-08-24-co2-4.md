---
title: "计算机组成2-4:过程调用与指令寻址"
description: ""
pubDate: "2025-08-24"
heroImage: ""
---

# 计算机组成2-4:过程调用与指令寻址

### **第四部分：程序的模块化与寻址**

**本讲提纲：**

8.  **构建程序的基石——过程调用**：我们将系统地学习实现一个过程调用所需要的六个步骤，并深入探讨**栈 (Stack)** 这种关键数据结构的作用。我们会学习专门用于过程调用的指令，理解**调用者 (Caller)** 和**被调用者 (Callee)** 之间的协作规约，并区分哪些寄存器需要保存，哪些不需要。
9.  **指令在哪里？——指令寻址**：我们将总结RISC-V中的各种寻址模式，特别是分支和跳转指令是如何计算它们的目标地址的。

### **8\. 过程调用**

过程是结构化编程的核心。一个程序员只需要知道一个过程的功能（它做什么），而无需关心其内部实现（它怎么做），就可以直接使用它。这种抽象能力是构建大型复杂软件系统的关键。

为了让硬件支持过程调用，必须提供一种机制来完成以下任务。

#### **8.1 过程调用的六个步骤**

一个完整的函数调用和返回过程，可以分解为以下六个标准步骤：

**调用方 (Caller) 的职责：**

1.  **参数传递 (Place Parameters)**：将调用函数时传入的参数，放置在一个被调用函数(Callee)可以访问到的地方。
2.  **转移控制 (Transfer Control)**：跳转到被调用函数的起始指令处开始执行。

**被调用方 (Callee) 的职责：** 3. **获取存储资源 (Acquire Storage)**：如果被调用函数需要额外的存储空间（例如，用于局部变量），它需要进行分配。 4. **执行任务 (Perform Task)**：执行函数体内的代码，完成指定的功能。

**返回阶段的职责：** 5. **返回结果 (Place Result)**：将被调用函数的返回值，放置在一个调用函数(Caller)可以访问到的地方。 6. **返回控制 (Return Control)**：跳转回调用函数当初发起调用的**下一条**指令，继续执行。

这六个步骤构成了一个完整的“调用-返回”协定。现在，我们来逐一揭示RISC-V是如何通过指令集和编程规约来实现它们的。

#### **8.2 步骤2 & 6：控制权的转移与返回**

这是过程调用中最核心的硬件支持。

*   **如何跳转到被调用函数？** 我们可以用 `beq x0, x0, ProcedureAddress` 这样的无条件跳转指令。但这还不够。
*   **如何返回？** 被调用函数执行完毕后，它必须知道应该返回到**哪里**。这个“返回地址”就是调用指令的下一条指令的地址。

为了解决这个问题，RISC-V提供了一条专门的指令：

**`jal rd, Label` (Jump and Link)**

`jal` 指令巧妙地**一步完成了两件事**：

1.  **Link (链接)**：将**返回地址**（即 `jal` 指令自身的地址 + 4）保存到目标寄存器 `rd` 中。
2.  **Jump (跳转)**：无条件地跳转到 `Label` 标记的指令处执行。

按照RISC-V的软件约定，返回地址通常保存在 **`x1`** 寄存器中，它有一个别名 `ra` (Return Address)。所以，一个标准的函数调用是： `jal ra, ProcedureAddress`

现在，被调用函数 `ProcedureAddress` 知道了返回地址就在 `ra` 寄存器里。当它执行完毕后，如何返回呢？它需要一条指令，能够跳转到 `ra` 寄存器里存储的地址。这条指令是：

**`jalr rd, offset(rs1)` (Jump and Link Register)**

`jalr` 指令也非常强大，它跳转的目标地址是**动态计算**出来的：`rs1` 寄存器的值 + `offset`。

1.  **Link**：同样，它会把返回地址（`jalr` 指令地址 + 4）存入 `rd`。
2.  **Jump**：跳转到 `rs1 + offset`。

一个标准的函数返回是： `jalr x0, 0(ra)`

*   `rs1` 是 `ra`，`offset` 是0，所以跳转目标是 `ra` 寄存器中的地址。
*   `rd` 是 `x0`。`x0` 寄存器永远为0，写入操作会被硬件忽略。这巧妙地利用了 `x0` 的特性，使得 `jalr` 在这里只执行跳转功能，而不保存新的返回地址（因为我们不需要）。

#### **8.3 步骤1 & 5：参数传递与返回值**

参数和返回值需要在调用者和被调用者之间传递。有两种主要方式：

1.  **使用寄存器**：对于少量参数/返回值，这是最快、最高效的方式。
2.  **使用内存**：当参数/返回值数量很多，或者它们是大型数据结构（如数组、结构体）时，需要借助内存。

RISC-V软件规约约定：

*   **参数寄存器 (Argument Registers)**：**`x10` - `x17`** (别名 `a0` - `a7`) 用于传递最多8个参数。
*   **返回值寄存器 (Return Value Registers)**：**`x10` - `x11`** (别名 `a0` - `a1`) 用于返回最多2个值。

#### **8.4 步骤3：为局部变量分配存储**

如果一个函数内部定义了局部变量（如C语言中的自动变量 `auto`），或者参数数量超过8个，寄存器就不够用了。这时，我们需要在**内存**中为这些数据分配空间。

这个用于过程调用的内存区域，被称为**栈 (Stack)**。

**栈的特性：**

*   **后进先出 (Last-In, First-Out, LIFO)**：栈就像一个盘子堆，最后放上去的盘子最先被拿走。
*   **栈指针 (Stack Pointer, `sp`)**：RISC-V中使用 `x2` 寄存器（别名 `sp`）作为栈指针，它始终指向栈顶。
*   **生长方向**：在RISC-V中，栈从**高地址向低地址生长**。
    *   **入栈 (Push)**：分配空间。将 `sp` 的值减小。`sp = sp - N`。
    *   **出栈 (Pop)**：释放空间。将 `sp` 的值增大。`sp = sp + N`。

**示例：在栈上分配24个字节（3个双字）的空间** `addi sp, sp, -24` # Push: sp 向低地址移动 **释放这24个字节** `addi sp, sp, 24` # Pop: sp 向高地址移动

#### **8.5 寄存器使用的冲突与解决方案**

现在出现了一个严重的问题：寄存器是全局共享的资源，总共只有32个。当函数 `A` 调用函数 `B` 时，函数 `B` 可能会覆盖掉函数 `A` 正在使用的某个寄存器里的重要数据。

例如，函数 `A` 用 `x19` 存放一个循环变量 `i`，然后调用了函数 `B`。如果 `B` 为了自己的计算也用了 `x19`，那么当 `B` 返回时，`A` 中的 `i` 的值就被破坏了。

为了解决这个问题，RISC-V软件规约将寄存器分为两类：

1.  **临时寄存器 (Temporary Registers)**：**`t0-t6` (`x5-x7`, `x28-x31`)**
    
    *   **规约**：被调用者 (Callee) **可以随意使用**这些寄存器，**无需恢复**它们原来的值。
    *   **调用者 (Caller) 的责任**：如果调用者在调用一个函数前，某个临时寄存器里有它稍后还需使用的重要数据（称为**活跃数据, live data**），那么调用者**必须**在调用前，自己负责将这个寄存器的值**保存**到栈上，并在调用返回后，再从栈上**恢复**它。
2.  **保留寄存器 (Saved Registers)**：**`s0-s11` (`x8-x9`, `x18-x27`)**
    
    *   **规约**：被调用者 (Callee) 如果要使用这些寄存器，**必须**在函数的开头将它们的原始值**保存**到栈上，并在函数返回前，将它们从栈上**恢复**。
    *   **调用者 (Caller) 的保证**：调用者可以放心地认为，在调用一个函数后，所有保留寄存器的值都和调用前一模一样。

**`ra` (`x1`)** 和**参数寄存器 `a0-a7`** 的行为类似于临时寄存器。

这个规约精妙地在调用者和被调用者之间分配了保存寄存器的责任，使得双方合作无间。

#### **8.6 过程调用实例：叶子过程 (Leaf Procedure)**

一个不调用任何其他过程的过程，称为**叶子过程**。

**示例：编译一个叶子过程 `leaf_example`**

```
long long leaf_example(long long g, long long h, long long i, long long j) {
                    long long f = (g + h) - (i + j);
                    return f;
                }
                
```

**编译步骤：**

1.  **参数分配**：`g, h, i, j` 分别通过 `a0-a3` (`x10-x13`) 传入。
2.  **寄存器分配**：
    *   我们可以用**临时寄存器** `t0, t1` (`x5, x6`) 来存放中间结果 `g+h` 和 `i+j`。
    *   最终结果 `f` 可以直接计算到返回值寄存器 `a0` (`x10`) 中。
3.  **代码生成**：

```
leaf_example:
                    add  x5, x10, x11      # t0 = g + h
                    add  x6, x12, x13      # t1 = i + j
                    sub  x10, x5, x6       # f (in a0) = t0 - t1
                    jalr x0, 0(ra)         # return f
                
```

**分析**：这个叶子过程非常简单，它只使用了临时寄存器和参数寄存器。根据规约，它**不需要**在栈上保存任何东西，也**不需要**分配栈空间。

#### **8.7 过程调用实例：非叶子过程 (Non-leaf Procedure)**

当一个过程需要调用其他过程时，情况就复杂了。

**示例：编译一个递归计算阶乘的函数 `fact`**

```
int fact(int n) {
                    if (n < 1) return 1;
                    else return n * fact(n - 1);
                }
                
```

**分析**：函数 `fact` 调用了它自身，所以它是一个非叶子过程。

*   当 `fact(n)` 调用 `fact(n-1)` 时，`fact(n)` 必须保存两样东西，否则它们会被 `fact(n-1)` 的调用所覆盖：
    1.  **参数 `n`**：因为在 `fact(n-1)` 返回后，还需要用 `n` 来做乘法。参数 `n` 在 `a0` 中，而 `fact(n-1)` 的调用会用新的参数 `n-1` 覆盖 `a0`。
    2.  **返回地址 `ra`**：因为 `fact(n-1)` 的调用会用新的返回地址（返回到 `fact(n)` 内部）覆盖掉 `ra` 原来的值（返回到 `fact(n)` 的调用者）。
*   **解决方案**：`fact` 函数必须在栈上分配空间，来保存 `n` 和 `ra`。

**RISC-V 代码**：

```
fact:
                    # 序言 (Prologue): 保存寄存器, 分配栈帧
                    addi sp, sp, -16        # 为 n 和 ra 分配 16 字节栈空间
                    sd   ra, 8(sp)           # 保存返回地址
                    sd   a0, 0(sp)           # 保存参数 n

                    # 检查基本情况: if (n < 1)
                    slti t0, a0, 1          # t0 = (n < 1) ? 1 : 0
                    beq  t0, x0, L1          # if (n >= 1), goto L1

                    # 基本情况: return 1
                    addi a0, x0, 1          # 返回值 a0 = 1
                    # 结尾 (Epilogue): 恢复寄存器, 释放栈帧, 返回
                    addi sp, sp, 16         # 释放栈帧
                    jalr x0, 0(ra)          # 返回 (此时 ra 未被修改)

                L1: # 递归情况
                    # 准备调用 fact(n-1)
                    addi a0, a0, -1         # 参数 a0 = n - 1
                    jal  ra, fact            # 调用 fact(n-1), a0 中是其返回值

                    # 从 fact(n-1) 返回后
                    # 恢复 n 和 ra
                    ld   t1, 0(sp)           # 临时寄存器 t1 = n (从栈中恢复)
                    ld   ra, 8(sp)           # 恢复返回地址
                    addi sp, sp, 16         # 释放栈帧

                    # 计算 n * fact(n-1)
                    mul  a0, t1, a0          # 返回值 a0 = n * fact(n-1)
                    jalr x0, 0(ra)          # 返回
                
```

这个例子完美地展示了非叶子过程的完整结构：

*   **序言 (Prologue)**：在函数开头，分配栈帧，保存需要保留的寄存器（`s0-s11`）和在后续调用中可能被覆盖的活跃数据（如本例中的 `ra` 和 `a0`）。
*   **函数体 (Body)**：执行函数的核心逻辑。
*   **结尾 (Epilogue)**：在函数返回前，从栈中恢复寄存器，释放栈帧，然后跳转返回。

#### **8.8 内存布局**

一个运行中的程序，其内存通常被划分为以下几个段：

*   **保留区 (Reserved)**：通常是低地址区域，操作系统保留。
*   **文本段 (Text Segment)**：存放程序指令（机器码），通常是只读的。
*   **静态数据段 (Static Data Segment)**：存放全局变量和静态变量。
    *   **全局指针 `gp` (`x3`)**：RISC-V 约定 `gp` 指向静态数据段的中间，这样可以用一个寄存器和有符号偏移量方便地访问整个静态数据区。
*   **动态数据段 (Heap)**：用于程序运行时动态分配的内存（如C语言的 `malloc`），从低地址向高地址生长。
*   **栈段 (Stack Segment)**：用于过程调用，存放局部变量、保存的寄存器等，从高地址向低地址生长。

### **9\. 指令寻址**

寻址模式 (Addressing Mode) 指的是指令如何指定其操作数的地址。我们已经接触过几种：

1.  **寄存器寻址 (Register Addressing)**：操作数在寄存器中，如 `add x5, x6, x7`。
2.  **基址+偏移量寻址 (Base + Offset Addressing)**：操作数在内存中，地址由 `基址寄存器 + 立即数偏移量` 得到，如 `ld x5, 64(x6)`。
3.  **立即数寻址 (Immediate Addressing)**：操作数是指令自身包含的立即数，如 `addi x5, x6, 100`。

现在我们关注控制流指令（分支和跳转）是如何确定它们的**目标指令地址**的。

#### **9.1 PC 相对寻址 (PC-Relative Addressing)**

用于**条件分支指令** (`beq`, `bne`, `blt` 等)。

**动机**：大多数分支的目标都离分支指令本身不远（例如 `if` 语句和短循环）。 **原理**：指令中不存放完整的32位或64位目标地址，而是存放一个带符号的**偏移量 (offset)**。目标地址由当前**程序计数器 (Program Counter, PC)** 的值加上这个偏移量得到。 `Target Address = PC + Offset`

**优点**：

*   **节省指令空间**：偏移量通常比完整地址短得多，可以节省指令中的宝贵位。
*   **位置无关代码 (Position-Independent Code)**：由于目标地址是相对当前PC计算的，这段代码无论被加载到内存的哪个位置，分支逻辑都能正常工作，这对于现代操作系统和动态链接库至关重要。

**RISC-V实现细节**：

*   分支指令（如SB-type）中的12位立即数表示的是\*\*半字（2字节）\*\*的偏移量。
*   实际的字节偏移量是 `立即数 << 1`。这是因为RISC-V指令是4字节对齐的，指令地址的最低两位永远是00，没必要在指令中编码。
*   PC的值通常是**当前分支指令的地址**。

**示例：`beq x5, x6, L1`** 假设 `beq` 指令在地址 `80020`，目标 `L1` 在地址 `80000`。

*   偏移量（字节） = `80000 - 80020 = -20`。
*   指令中编码的立即数 = `-20 / 2 = -10`。
*   当CPU执行这条指令时，会计算 `PC + (-10 << 1) = 80020 - 20 = 80000`，从而正确跳转。

#### **9.2 伪直接寻址 (Pseudodirect Addressing)**

用于\*\*`jal` 指令\*\*。

**动机**：`jal` 需要比条件分支更大的跳转范围，以支持调用程序中任意位置的函数。 **原理**：

*   `jal` 指令（UJ-type）中有一个20位的立即数。
*   目标地址由 **PC + 20位立即数符号扩展后左移1位** 得到。 `Target Address = PC + sign_extend(imm[20:1] << 1)`
*   这提供了一个大约 $\\pm 1 \\text{MB}$ 的跳转范围。

#### **9.3 如何实现更远的跳转？**

如果需要跳转到超过 $\\pm 1 \\text{MB}$ 范围之外的地址，或者需要跳转到一个完全由程序动态计算出的32位/64位绝对地址，该怎么办？ 这时需要两条指令的配合：

1.  **`lui rd, immediate` (Load Upper Immediate)**：将一个20位的立即数加载到一个寄存器 `rd` 的**高20位**，低12位清零。
2.  **`jalr rd, offset(rs1)`**：
    *   `lui` 先构建出目标地址的高位部分并存入一个临时寄存器（比如 `t0`）。
    *   `jalr` 再利用其 `基址+偏移量` 的寻址方式，将 `t0` 作为基址，用12位的偏移量补上目标地址的低12位，从而构成一个完整的32位地址并跳转。

这个两步过程可以实现对整个32位地址空间的任意跳转。

**本讲小结**

在这一讲，我们完成了对计算机指令集核心功能的探索。

1.  **过程调用支持**：我们详细学习了实现过程调用所需的软硬件协同机制，理解了 `jal` 和 `jalr` 指令的精妙设计，掌握了栈在参数传递、局部变量存储和寄存器保存中的关键作用，并明确了调用者和被调用者之间的寄存器使用规约。
2.  **指令寻址**：我们总结了RISC-V的寻址模式，重点分析了用于条件分支的**PC相对寻址**和用于函数调用的**伪直接寻址**，理解了它们的设计动机和实现原理。 。