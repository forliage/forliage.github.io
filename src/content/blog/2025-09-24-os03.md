---
title: "操作系统03:进程"
description: ""
pubDate: "2025-09-24"
heroImage: ""
---

# 操作系统03:进程

### 1.进程的概念

##### 1.1.进程的概念

操作系统执行各种程序：

*   批处理系统 – job
*   分时系统——用户程序或任务  
    （教科书上,job=process）

进程——以顺序方式执行的程序

一个进程包括：

*   text section (code)
*   program counter
*   stack (function parameters, local vars, return addresses)
*   data section (global vars)
*   heap (dynamically allocated memory)

**Data Structure:Heap**

*   Heap is a "complete" binary tree
    *   Except the leaf level, all levels are full. The leaf level is filled from left to right
    *   The node's value should be larger/smaller than its children
*   (a) is a heap
*   (b) is not for it is not complete
*   (c) is not bacause 6 < 8

flowchart LR %% (a) subgraph A\["(a)"\] direction TB A9((9)) A8((8)) A4((4)) A6((6)) A2((2)) A3((3)) A9 --> A8 A9 --> A4 A8 --> A6 A8 --> A2 A4 --> A3 end %% (b) subgraph B\["(b)"\] direction TB B9((9)) B8((8)) B4((4)) B6((6)) B2((2)) B3((3)) B9 --> B8 B9 --> B4 B8 --> B6 B4 --> B2 B4 --> B3 end %% (c) subgraph C\["(c)"\] direction TB C9((9)) C6((6)) C4((4)) C8((8)) C2((2)) C3((3)) C9 --> C6 C9 --> C4 C6 --> C8 C6 --> C2 C4 --> C3 end

**Data Structure: Stack**

*   典型的栈是计算机内存中具有固定起始点和可变大小的区域
*   初始时栈的大小为零
*   栈指针通常以硬件寄存器形式存在，指向栈中最近被引用的位置
*   压栈操作：将数据项放置于栈指针所指位置，并根据数据项大小调整栈指针地址
*   弹出操作：移除栈指针当前指向位置的数据项，并将栈指针地址按该数据项大小进行回调。

##### 1.2.进程的状态

随着进程的执行，其状态会发生变化

*   **new**: 该流程正在创建中
*   **running**:指令正在执行
*   **waiting**:该进程正在等待/阻塞某个事件发生
*   **ready**: 该进程正在等待分配给处理器
*   **terminated**:该进程已完成执行

flowchart LR new((new)) -->|admitted| ready((ready)) ready -->|scheduler dispatch| running((running)) running -->|exit| terminated((terminated)) running -->|I/O or event wait| waiting((waiting)) waiting -->|I/O or event completion| ready running -->|interrupt| ready

##### 1.3.进程控制块（PCB）

与每个进程相关的信息

*   进程状态（新建、就绪等）
*   程序计数器（下条指令的地址）
*   CPU寄存器内容
*   CPU调度信息（优先级）
*   内存管理信息
*   计费信息（CPU使用时间、时间限制、进程编号）
*   I/O状态信息（已分配设备和已打开文件）

### 2.进程调度

##### 2.1.进程调度队列

*   Job queue——系统中所有进程的集合
*   Ready queue——驻留于主内存中、处于就绪状态并等待执行的所有进程集合
*   Device queue——等待I/O设备的进程集合
*   进程在不同队列间迁移

##### 2.2.进程调度表示法

**A queueing-diagram**:

flowchart LR RQ\[ready queue\] --> CPU((CPU)) CPU -->|I/O request| IOREQ\[I/O request\] IOREQ --> IOQ\[I/O queue\] IOQ --> IO((I/O)) IO -->|completion| RQ CPU -->|time slice expired| TSE\[time slice expired\] TSE --> RQ CPU -->|fork a child| F\[fork a child\] F --> CHILD((child executes)) CHILD --> RQ CPU -->|wait for an interrupt| WAIT\[wait for an interrupt\] WAIT --> INT((interrupt occurs)) INT --> RQ

**Schedulers**:

*   什么是调度程序？一段程序代码
*   长期调度程序（或作业调度程序）——选择哪些进程应被加载到内存中（就绪队列）
*   短期调度程序（或CPU调度程序）——选择下一个应执行的进程并分配CPU时间
*   短期调度程序调用频率极高（毫秒级）（必须快速）
*   长期调度程序调用频率极低（秒级、分钟级）（可容忍较慢）
*   长期调度程序控制多任务处理程度
*   进程可分为：
    *   I/O 密集型进程——耗费更多时间进行 I/O 操作而非计算，呈现多次短暂的 CPU 突发
    *   CPU 密集型进程——耗费更多时间进行计算，呈现少数极长的 CPU 突发

##### 2.3.上下文切换

*   当CPU切换到另一个进程时，系统必须保存旧进程的状态并为新进程加载保存的状态。
*   上下文切换时间属于开销；切换期间系统不会执行有效工作——通常耗时数毫秒。
*   该时间取决于硬件支持。在SPARC架构中，系统提供了寄存器组。

### 3.进程的操作

##### 3.1.进程创建

*   父进程创建子进程，子进程再创建其他进程，形成进程树结构
    
*   资源共享
    
    *   父子进程共享全部资源
    *   子进程共享父进程部分资源
    *   父子进程不共享资源
*   执行方式
    
    *   父子进程并行执行
    *   父进程等待子进程终止
*   Chrome示例
    
*   地址空间
    
    *   子进程是父进程的副本
    *   子进程加载有程序
*   UNIX示例
    
    *   **fork**系统调用创建新进程
    *   **fork**后使用**exec**系统调用替换进程内存空间为新程序

存在多种“exec”API。例如：`execve() execv() execle() execvp() execlp()`等。

flowchart LR F((fork)) W((wait)) E((exec)) X((exit)) R\[resumes\] F -->|parent| W F -->|child| E E --> X X --> W W -->|resumes| R

##### 3.2.C语言程序分叉独立进程

```
int main()
{
    pid_t pid;
    /*fork another process*/
    pid = fork();
    if (pid < 0) { /*error occurred*/
        fprintf(stderr, "Fork Failed");
        exit(-1);
    }
    else if (pid == 0) { /*child process*/
        exexlp("/bin/ls", "ls", NULL)
    }
    else{ /*parent process*/
        /*parent will wait for the child to complete*/
        wait(NULL);
        printf("Child Complete");
        exit(0);
    }
}
```

##### 3.3.进程终止

*   进程执行最后一条语句并请求操作系统删除自身（退出）
    *   子进程向父进程输出数据（通过wait）
    *   操作系统释放进程资源
*   父进程可终止子进程执行（中止）
    *   子进程超出分配资源
    *   子进程任务不再需要执行
    *   若父进程正在退出
        *   部分操作系统禁止父进程终止时子进程继续运行
            *   所有子进程终止 - 级联终止
        *   在其他操作系统中，子进程可能成为孤儿进程

### 4.协作进程

##### 4.1.概念

*   独立进程不能影响或受其他进程执行的影响
*   协作进程可以影响或受其他进程执行的影响
*   进程协作的优势
    *   信息共享
    *   计算加速（多CPU环境）
    *   模块化
    *   便捷性

##### 4.2.生产者-消费者问题

生产者-消费者模式：生产者进程生成信息，消费者进程进行消费。

*   无界缓冲区模式：对缓冲区大小不设实际限制。若无新项，消费者需等待。
*   有界缓冲区模式：假设存在固定缓冲区大小。若缓冲区已满，生产者必须等待。

**有界缓冲区-共享内存解决方案**

Shared data

```
#define BUFFER_SIZE 10
typedef struct {
  ...
} item;

item buffer[BUFFER_SIZE]
int in = 0;
int out = 0;
```

**有界缓冲区 – 插入方法**

```
while (true) {
  /*Produce an item*/
  while ((in + 1) % BUFFER_SIZE == out)
    ; /*do nothing -- no free buffers*/
  buffer[in] = item;
  in = (in + 1) % BUFFER_SIZE;
}
```

**有界缓冲区 – 删除方法**

```
while (true) {
  while (in == out)
     ; // do nothing -- nothing to consume

  // remove an item from the buffer
  item = buffer[out];
  out = (out + 1) % BUFFER_SIZE;
return item;
}
```

### 5.进程间通信

*   进程间通信与同步机制
*   进程间通信模型：消息传递与共享内存
*   消息系统——进程间通信无需依赖共享变量
*   进程间通信机制提供两种操作：
    *   send(消息)——消息大小固定或可变
    *   receive(消息)
*   若进程P与Q需通信，须：
    *   建立通信链路
    *   通过发送/接收交换消息
*   通信链路实现方式：
    *   物理链路（如共享内存、硬件总线）
    *   逻辑链路（如逻辑属性）

##### 5.1.Direct Communication

*   进程必须显式命名彼此：
    *   send(P, message) –向进程P发送消息
    *   receive(Q, message) –从进程Q接收消息
*   通信链路的特性：
    *   链路自动建立
    *   每个链路仅关联一对通信进程
    *   每对进程间仅存在一条链路
    *   链路可能为单向，但通常为双向

##### 5.2.Indirect Communication

*   消息通过邮箱（也称为端口）进行发送和接收
    *   每个邮箱都有唯一的标识符
    *   进程只有共享同一个邮箱才能通信
*   通信链路的特性
    *   仅当进程共享共同邮箱时建立链路
    *   一条链路可关联多个进程
    *   每对进程可共享多个通信链路
    *   链路可为单向或双向
*   操作：
    *   创建新邮箱
    *   通过邮箱收发消息
    *   销毁邮箱
*   基本操作定义如下：
    *   send(A, message) – 向邮箱 A 发送消息
    *   receive(A, message) – 从邮箱 A 接收消息
*   邮箱共享
    *   $P\_1$、$P\_2$和$P\_3$共享邮箱A
    *   $P\_1$发送；$P\_2$和$P\_3$接收
    *   谁收到消息？
*   解决方案
    *   允许链接最多关联两个进程
    *   每次仅允许一个进程执行接收操作
    *   允许系统任意选择接收者。发送方将获知接收者身份。

##### 5.3.Synchronization

*   消息传递可分为阻塞式与非阻塞式
*   阻塞式被视为同步模式
    *   阻塞式发送会使发送方阻塞直至消息被接收
    *   阻塞式接收会使接收方阻塞直至有可用消息
*   非阻塞式被视为异步模式
    *   非阻塞式发送会使发送方发送消息后继续执行
    *   非阻塞式接收会使接收方接收有效消息或空值

##### 5.4.Buffering

*   链接关联的消息队列；通过三种方式实现：

1.  零容量——0条消息 发送方必须等待接收方（会合）
2.  有界容量——有限长度的n条消息 链接满时发送方必须等待
3.  无界容量——无限长度 发送方永不等待

*   缓冲控制

### 6.客户端-服务器系统中的通信

##### 6.1.Sockets

套接字被定义为通信的端点

IP地址与端口的组合

套接字161.25.19.8:1625指代主机161.25.19.8上的1625端口

通信发生于一对套接字之间

##### 6.2.远程过程调用

远程过程调用（RPC）在联网系统中抽象化进程间的过程调用。

存根——客户端对服务器端实际过程的代理。

客户端存根定位服务器并序列化参数。

服务器端存根接收该消息，解包序列化参数，并在服务器上执行过程。