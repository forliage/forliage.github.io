---
title: "计算机图形学04:动手实践 - 你的第一个OpenGL程序"
description: ""
pubDate: "2025-08-27"
heroImage: ""
---

# 计算机图形学04:动手实践 - 你的第一个OpenGL程序

### **引言：从理论到代码的桥梁**

到目前为止，我们讨论的都是抽象的概念。但要让计算机为我们绘制图形，我们需要一个具体的工具，一个能让我们通过代码直接与图形硬件（GPU）对话的接口。这个接口，就是**图形应用程序接口 (Graphics API)**。

目前业界主流的图形API有三个：

*   **OpenGL (Open Graphics Library):** 我们本课程的重点。它是一个**跨平台**的图形API，意味着你写的代码可以在Windows, macOS, Linux, 甚至移动设备上运行。
*   **Direct3D:** 微软公司的私有API，仅限于Windows和Xbox平台。它是PC游戏领域的主导者。
*   **Vulkan:** 最新的跨平台API，被看作是OpenGL的继任者。它提供了更底层的硬件控制，性能更高，但学习曲线也更陡峭。

我们选择OpenGL作为学习工具，因为它历史悠久、概念清晰、跨平台性好，非常适合用于教学和理解计算机图形学的核心原理。

### **1\. 什么是OpenGL？**

在开始编程之前，我们必须搞清楚OpenGL究竟是什么。

*   **它是一个规范 (Specification)，而不是一个库。** OpenGL本身只是一份长篇文档，由Khronos Group这个行业联盟维护。这份文档精确地定义了一系列函数和常量，以及调用它们后图形硬件应该产生的行为。
*   **它是一个状态机 (State Machine)。** 这是理解OpenGL工作方式的**核心关键**。你可以把OpenGL想象成一个非常复杂的绘图机器人。你不能一次性告诉它“画一个红色的、在(0,0)位置的、旋转了45度的正方形”。你必须分步下达指令来改变它的“状态”：
    1.  “机器人，把你的画笔颜色设置为**红色**。” (设置当前颜色状态)
    2.  “机器人，移动到**变换后的A点**。” (提交一个顶点)
    3.  “机器人，移动到**变换后的B点**。” (提交一个顶点)
    4.  ... 这个“当前颜色”就是OpenGL状态机中的一个状态变量。后续所有绘制顶点的命令，都会使用这个颜色，直到你再次下达命令去改变它。
*   **它是一个底层接口。** OpenGL的核心只关心一件事情：接收顶点数据，并将它们按照当前的状态渲染成屏幕上的像素。它不负责创建窗口、处理鼠标键盘输入、加载图片或模型文件。

### **2\. 为什么需要GLUT？**

既然OpenGL不负责创建窗口，那我们的图形要画在哪里呢？这就是我们需要辅助库的原因。**GLUT (OpenGL Utility Toolkit)** 就是这样一个库。

*   **它的作用：** GLUT为我们处理了所有与操作系统相关的繁琐事务，例如：
    *   创建和管理窗口。
    *   处理用户的键盘、鼠标输入事件。
    *   提供一个简单的事件循环机制。
*   **它的地位：** GLUT是一个非常古老的库，但因其简单易用，至今仍在教学中广泛使用。在现代的、更复杂的项目中，人们通常会使用它的继任者，如 **freeglut**，或者功能更强大的 **GLFW**, **SDL** 等。

在本课程中，我们将使用GLUT来快速搭建我们的程序框架，从而把精力完全集中在OpenGL的绘图命令上。

### **3\. 搭建你的开发环境**

我们将以在Windows上使用Visual Studio为例，来搭建我们的开发环境。macOS和Linux的配置过程类似，主要是库文件的路径和链接方式不同。

1.  **准备工作：**
    
    *   **IDE:** 安装一个现代的C++集成开发环境，如 Visual Studio 2022 Community (免费)。
    *   **GLUT库:** 从网上下载预编译好的GLUT库文件。你通常会得到三个文件：
        *   `glut.h`: 头文件，告诉编译器GLUT有哪些函数。
        *   `glut32.lib`: 静态链接库文件，在编译链接时使用。
        *   `glut32.dll`: 动态链接库文件，在程序运行时需要。
2.  **配置Visual Studio项目 (一次性工作):**
    
    *   **第一步：放置文件。** 将上述三个文件放到Visual Studio或系统能够找到的地方。一个常规的做法是：
        *   `glut.h` 放到 `.../VC/Tools/MSVC/x.x.x/include/GL/` 目录下。
        *   `glut32.lib` 放到 `.../VC/Tools/MSVC/x.x.x/lib/x64/` (或x86) 目录下。
        *   `glut32.dll` 放到 `C:/Windows/System32` (64位系统) 或 `C:/Windows/SysWOW64` (32位程序在64位系统上) 目录下。
        *   _(专业建议：更好的做法是为项目单独创建一个`lib`和`include`文件夹，然后在项目属性中指定路径，这样项目更具可移植性)_
3.  **创建你的第一个项目：**
    
    *   打开Visual Studio，选择“创建新项目”。
    *   选择“控制台应用”（C++）。
    *   给项目命名，例如 `HelloOpenGL`。
    *   **重要设置：** 创建项目后，右键点击项目名称 -> 属性。在 C/C++ -> 预编译头 中，将“预编译头”选项设置为“不使用预编译头”。这可以避免一些初学者常见的编译问题。
    *   在链接器 -> 输入 -> 附加依赖项中，添加 `opengl32.lib` 和 `glut32.lib`。

现在，你的开发环境已经准备就绪，可以开始编写代码了！

### **4\. 代码剖析：绘制一个红色正方形**

让我们来逐行分析并理解第一个OpenGL程序。这个程序将在屏幕中央绘制一个红色的正方形。

```
#include <GL/glut.h> // 引入GLUT头文件，它会自动包含OpenGL的核心头文件
#include <stdlib.h>  // 标准库

// 核心绘图函数
void redraw() {
    // 1. 清除颜色缓冲区
    glClear(GL_COLOR_BUFFER_BIT);

    // 2. 开始定义一个或多个图元
    glBegin(GL_QUADS); // 我们要画四边形(s)

        // 3. 设置当前颜色为红色 (R=1, G=0, B=0)
        glColor3f(1.0f, 0.0f, 0.0f);

        // 4. 定义四边形的四个顶点
        glVertex3f(-0.5f,  0.5f, 0.0f); // 左上
        glVertex3f( 0.5f,  0.5f, 0.0f); // 右上
        glVertex3f( 0.5f, -0.5f, 0.0f); // 右下
        glVertex3f(-0.5f, -0.5f, 0.0f); // 左下

    // 5. 结束图元定义
    glEnd();

    // 6. 交换前后缓冲区
    glutSwapBuffers();
}

// 程序主入口
int main(int argc, char *argv[]) {
    // A. 初始化GLUT
    glutInit(&argc, argv);

    // B. 设置显示模式
    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);

    // C. 创建窗口
    glutCreateWindow("My First OpenGL App");

    // D. 注册回调函数
    glutDisplayFunc(redraw); // 告诉GLUT，当需要重绘时，调用我们的redraw函数

    // E. 进入主事件循环
    glutMainLoop();

    return 0; // 这行代码永远不会被执行到
}
```

#### **主函数 `main` 的流程解析：**

*   **A. `glutInit`**: 初始化GLUT库。这是所有GLUT程序的第一步。
*   **B. `glutInitDisplayMode`**: 设置窗口的显示模式。
    *   `GLUT_RGBA`: 指定颜色模式为RGBA（红、绿、蓝、透明度）。
    *   `GLUT_DOUBLE`: **非常重要！** 这指定了使用**双缓冲 (Double Buffering)**。
*   **C. `glutCreateWindow`**: 创建一个带有指定标题的窗口。
*   **D. `glutDisplayFunc`**: 这是**回调机制**的体现。我们在这里注册了我们的`redraw`函数。这意味着我们把`redraw`函数的控制权交给了GLUT。当操作系统认为窗口需要被重绘时（例如，窗口刚创建、被其他窗口遮挡后又出现），GLUT就会自动调用我们注册的`redraw`函数。
*   **E. `glutMainLoop`**: 启动GLUT的事件循环。这是一个**无限循环**，它会持续监听鼠标、键盘、重绘等事件。一旦进入这个循环，程序控制权就完全交给了GLUT，它会根据发生的事件去调用我们之前注册的各种回调函数。

#### **绘图函数 `redraw` 的流程解析：**

1.  **`glClear(GL_COLOR_BUFFER_BIT)`**: 清空画布。`GL_COLOR_BUFFER_BIT`告诉`glClear`我们要清空的是颜色缓冲区，将其重置为默认的背景色（默认为黑色）。
2.  **`glBegin(primitive_type)` / `glEnd()`**: 这是一对经典的、现已**废弃**（但教学中极为有用）的函数，用于定义一系列顶点来构成一个或多个图元。`GL_QUADS`表示我们接下来定义的顶点将用于构成四边形（每四个顶点一组）。
3.  **`glColor3f(...)`**: 设置OpenGL状态机中的“当前颜色”。`3f`表示3个浮点数参数。此后定义的所有顶点都将是红色的，直到下一次调用`glColor`。
4.  **`glVertex3f(...)`**: 定义一个三维顶点。在`glBegin`/`glEnd`块中，OpenGL会收集这些顶点，并根据`glBegin`指定的图元类型将它们组合起来。
5.  **`glutSwapBuffers()`**: **双缓冲**的体现。想象我们有两块画板：**前台缓冲区**（当前屏幕上显示的）和**后台缓冲区**（我们在内存中偷偷绘制的）。我们所有的绘制命令（`glClear`, `glVertex`等）都是在后台缓冲区进行的。当`redraw`函数完成所有绘制后，调用`glutSwapBuffers()`会将后台缓冲区的内容瞬间“交换”到前台，成为屏幕上显示的内容。这样做可以避免用户看到图形绘制的中间过程，防止画面闪烁。

编译并运行这段代码，你将看到一个黑色的窗口，中央有一个红色的正方形。恭喜你，你已经完成了从0到1的跨越！

思考以下问题：

1.  你应该使用哪种图元类型来绘制这个形状？`GL_TRIANGLES`? `GL_LINE_LOOP`? 或者其他？
2.  如果用 `GL_TRIANGLES`，你需要定义多少个顶点？`glVertex`函数需要被调用多少次？
3.  如果用 `GL_LINE_LOOP`，又需要多少个顶点？
4.  尝试将两个三角形设置成不同的颜色。