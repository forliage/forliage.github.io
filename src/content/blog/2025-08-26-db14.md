---
title: "数据库系统设计09:恢复系统(Recovery System)"
description: ""
pubDate: "2025-08-26"
heroImage: ""
---

# 数据库系统设计09:恢复系统(Recovery System)

一个数据库系统，无论其查询优化器多么智能，并发控制协议多么精妙，如果它无法在断电、宕机甚至磁盘损坏后，保证数据的安全和正确，那么它就是一文不值的。**可靠性，是数据库最核心的价值主张。** 而实现这份可靠性的重任，就落在了恢复系统的肩上。

恢复系统的使命，就是坚定不移地捍主ACID中的两大承诺：

*   **原子性 (Atomicity):** 保证事务“要么全做，要么全不做”。对于未完成的事务，必须撤销其所有影响。
*   **持久性 (Durability):** 保证已提交的事务，其结果永不丢失。

今天，我们将扮演灾难恢复工程师的角色，直面各种可能发生的故障。我们将学习数据库是如何通过一种看似简单却无比强大的工具——**日志 (The Log)**，来记录系统的一举一动，并以此为基础，构建起一套能在任何混乱中重建秩序的恢复算法。我们将重点剖析在现代数据库中被广泛采用的**ARIES**算法，理解其`Analysis-Redo-Undo`三阶段恢复的精髓。

### **第一部分：基于日志的恢复基础**

一切恢复技术，都始于日志。日志是数据库的“黑匣子”，它以一种**仅追加 (append-only)** 的方式，忠实地记录了所有对数据库状态产生影响的操作。

#### **1.1 故障的分类**

*   **事务故障 (Transaction Failure):** 逻辑错误（如除以零）、违反完整性约束、死锁牺牲品等。
    *   **恢复动作:** **中止 (Abort)** 并 **撤销 (Undo)** 该事务的所有修改。
*   **系统崩溃 (System Crash):** 软件错误（OS/DBMS bug）、硬件故障（断电、CPU/内存故障）等。
    *   **假设:** **易失性存储（内存）的内容全部丢失**，但**非易失性存储（磁盘）的内容保持完好**（可能处于一个不一致的状态）。
    *   **恢复动作:** 重启后，**撤销**所有在崩溃时**未提交**的事务，并**重做**所有**已提交**但其修改可能未写入磁盘的事务。
*   **介质故障 (Media Failure):** 磁盘磁头损坏、磁盘控制器故障等，导致部分或全部磁盘数据永久丢失。
    *   **恢复动作:** 从最近的**备份 (Backup/Dump)** 中恢复数据库，然后利用日志**重放 (Replay)** 备份点之后的所有已提交事务。

#### **1.2 日志记录 (Log Records)**

日志文件由一系列日志记录构成。每条记录都必须包含足够的信息来支持`Undo`和`Redo`。

*   **$<T\_i, \\text{start}>$:** 事务$T\_i$开始。
*   **$<T\_i, X, V\_{old}, V\_{new}>$:** 事务$T\_i$将数据项$X$的值从$V\_{old}$（前像, Before Image）修改为$V\_{new}$（后像, After Image）。这是最核心的**更新日志记录**。
*   **$<T\_i, \\text{commit}>$:** 事务$T\_i$成功提交。
*   **$<T\_i, \\text{abort}>$:** 事务$T\_i$中止。
*   **`<checkpoint>`:** 检查点记录（稍后详述）。

#### **1.3 预写日志协议 (Write-Ahead Logging, WAL)**

**这是整个恢复系统的第一黄金法则，不可动摇！**

*   **规则:**
    
    1.  在将一个被修改的数据页**刷新 (flush)** 到磁盘**之前**，必须**首先**确保与该修改相关的**所有日志记录**（特别是包含$V\_{old}$的Undo信息）都已经被写入到**稳定的日志存储**中。
    2.  事务只有在其\*\*`<commit>`日志记录\*\*被写入稳定日志存储后，才能被认为是已提交。
*   **为什么？**
    
    *   **保证原子性:** 如果系统在数据页写入磁盘后、事务提交前崩溃，我们需要利用日志中的$V\_{old}$来`Undo`这个修改。如果日志没先写，`Undo`信息就丢失了，数据库就永久地处于一个“脏”状态。
    *   **保证持久性:** 当事务提交时，我们只需保证`<commit>`日志落盘即可向用户确认。即使此时数据页还在内存中，系统崩溃后我们也能通过日志中的$V\_{new}$来`Redo`这个修改，确保其持久性。

#### **1.4 缓冲区管理策略与恢复**

恢复系统的设计，与缓冲区管理器如何处理脏页（被修改过的页）密切相关。

*   **STEAL vs. NO-STEAL:**
    *   **STEAL (窃取):** 允许将**未提交事务**修改过的脏页，在事务提交前就写入磁盘。
        *   **优点:** 内存利用率高，不需要为未提交的事务保留所有脏页。
        *   **缺点:** **需要`Undo`日志。** 如果系统崩溃，这些被“窃取”出去的脏页必须被回滚。
    *   **NO-STEAL (不窃取):** **禁止**将未提交事务修改过的脏页写入磁盘。
        *   **优点:** **不需要`Undo`日志**，恢复简单。
        *   **缺点:** 严重限制了缓冲池的管理，可能需要为长事务缓存大量脏页。
*   **FORCE vs. NO-FORCE:**
    *   **FORCE (强制):** 在事务**提交时**，**强制**将该事务修改过的所有脏页都写入磁盘。
        *   **优点:** **不需要`Redo`日志。** 提交即意味着数据已落盘。
        *   **缺点:** 提交延迟高，将大量随机I/O集中在提交点。
    *   **NO-FORCE (不强制):** 事务提交时，**不要求**立即写入脏页。
        *   **优点:** 提交快，可以将多个事务的脏页批量、异步地写入，优化I/O。
        *   **缺点:** **需要`Redo`日志。** 如果提交后、脏页写入前崩溃，需要重做。

**现代数据库的选择：** 为了高性能，几乎所有现代数据库都采用 **`STEAL` + `NO-FORCE`** 策略。这意味着，**我们的恢复系统必须同时支持`Undo`和`Redo`。**

### **第二部分：ARIES**

ARIES (Algorithm for Recovery and Isolation Exploiting Semantics) 是IBM Almaden研究中心发明的恢复算法，已成为事实上的工业标准。它优雅地处理了`STEAL`+`NO-FORCE`策略带来的所有复杂性。

#### **2.1 ARIES的核心思想**

1.  **重复历史 (Repeating History):** 恢复的第一步，是通过`Redo`将数据库恢复到**崩溃前的瞬间状态**，包括所有未提交事务所做的修改。
2.  **撤销未完成的事务 (Undoing losers):** 在恢复到崩溃前状态后，再统一地`Undo`那些在崩溃时还未提交的“失败者”事务。
3.  **补偿日志记录 (Compensation Log Records, CLRs):** `Undo`操作本身也是对数据库的修改，也必须记录日志，这种日志就是CLR。CLR记录了`Undo`操作，它只需要`Redo`信息，不需要`Undo`信息（因为我们从不撤销一个撤销操作）。这能防止在`Undo`过程中再次崩溃时，系统进行重复的、不必要的`Undo`。

#### **2.2 正常运行期间的工作**

*   **记录日志:** 任何更新操作都会生成一条$<T\_i, X, V\_{old}, V\_{new}>$日志。
*   **维护事务表 (Transaction Table):** 内存中，记录所有活动事务的状态、最后一条日志记录的指针等。
*   **维护脏页表 (Dirty Page Table):** 内存中，记录所有在缓冲池中被修改过（变脏）的页。
*   **定期执行检查点 (Checkpointing):** 这是为了**缩短恢复时间**的关键机制。

**检查点的作用:** 如果没有检查点，系统崩溃后，我们需要从**日志的起点**开始扫描，这可能非常耗时。检查点告诉恢复系统：“在这个点之前提交的事务，其数据修改肯定已经写入磁盘了，你不需要再为它们`Redo`了。”

**模糊检查点 (Fuzzy Checkpoint) 流程:**

1.  开始检查点，写入`<checkpoint, start>`日志，并暂停接收新的事务。
2.  将当时的**事务表**和**脏页表**的内容，写入到检查点日志记录中。
3.  写入`<checkpoint, end>`日志。
4.  将检查点日志强制刷盘。

*   **关键:** 在检查点期间，**事务可以继续执行**，脏页也不需要立即刷盘。这使得检查点对系统性能的影响降到最低。

#### **2.3 崩溃恢复的ARIES三阶段**

当系统从崩溃中重启时，恢复管理器开始执行：

##### **阶段一：分析 (Analysis Phase)**

*   **目标:** 确定在崩溃瞬间，哪些事务是**未完成的 (losers)**，哪些页是**脏的**。
*   **流程:**
    1.  从最近一个**完整的检查点**开始，**向前**扫描日志直到末尾。
    2.  根据日志记录，重建崩溃瞬间的**事务表**和**脏页表**。
        *   看到$<T\_i, \\text{start}>$，将$T\_i$加入事务表。
        *   看到$<T\_i, \\text{commit/abort}>$，将$T\_i$从事务表中移除。
        *   看到更新日志，如果被修改的页不在脏页表中，则加入。
*   **产出:**
    *   一个**失败者事务列表 (Loser List)**。
    *   一个需要进行恢复检查的**脏页表**。
    *   `Redo`阶段需要开始扫描的**最早的日志点**（通常是脏页表中最“老”的那个脏页对应的第一条日志）。

##### **阶段二：重做 (Redo Phase)**

*   **目标:** 将数据库恢复到崩溃前的确切状态，确保所有**已提交**事务的持久性，同时也**恢复未提交事务**的修改。
*   **流程:**
    1.  从分析阶段确定的`Redo`起始点开始，**向前**扫描日志直到末尾。
    2.  对于每一条**更新日志记录**或**CLR**: a. 检查其修改的数据页P是否在脏页表中。 b. 如果是，并且日志中的LSN（日志序列号）**大于**磁盘上页面P中记录的LSN，则**无条件地重做 (Redo)** 这个修改（将$V\_{new}$写入页），并更新页面的LSN。
*   **幂等性 (Idempotency):** `Redo`操作是幂等的。即使一个修改已经写入磁盘，再次`Redo`也不会出错。
*   **结果:** 此阶段结束后，磁盘状态与崩溃前瞬间的内存状态完全一致。

##### **阶段三：撤销 (Undo Phase)**

*   **目标:** 撤销所有在**失败者列表**中的事务。
*   **流程:**
    1.  从**失败者列表**中所有事务的**最后一条日志记录**开始，**向后**扫描日志。
    2.  对于遇到的每一条属于失败者事务的**普通更新日志**: a. 执行`Undo`操作（将$V\_{old}$写回数据项）。 b. 为这个`Undo`操作，生成一条**CLR**，并写入日志。 c. 继续处理该事务的前一条日志记录（通过日志记录中的`PrevLSN`指针可以快速跳转）。
    3.  当一个失败者事务的所有修改都被`Undo`后（即处理到它的`<start>`日志），为它写入一条`<abort>`日志。
*   **CLR的重要性:** 如果在`Undo`阶段再次崩溃，重启后，分析阶段会看到这些CLR。在`Redo`阶段，这些CLR会被重做，确保`Undo`操作本身是持久的。当再次进入`Undo`阶段时，系统看到CLR就知道这个`Undo`已经做过了，会跳过它，继续处理更早的日志，从而避免了重复`Undo`。

### **第三部分：介质恢复**

WAL和ARIES可以处理事务故障和系统崩溃，但如果**承载日志或数据文件的磁盘本身损坏了**，它们就无能为力了。

#### **3.1 备份与归档 (Backup & Archiving)**

*   **全量备份 (Full Dump):** 定期地将整个数据库复制到一个独立的、安全的存储介质（如磁带、云存储）上。
*   **增量备份 (Incremental Backup):** 只备份自上一次备份以来发生变化的数据。
*   **日志归档 (Log Archiving):** 日志文件是循环使用的。当一个日志文件被写满后，在重用它之前，必须将其内容**归档**到一个安全的长期存储中。这是实现**时间点恢复 (Point-in-Time Recovery, PITR)** 的基础。

#### **3.2 介质故障的恢复流程**

1.  **替换硬件:** 首先，更换损坏的磁盘。
2.  **恢复备份:** 将最近一次的**全量备份**恢复到新磁盘上。
3.  **应用增量备份:** 按顺序应用后续的增量备份。
4.  **前滚日志 (Roll Forward):**
    *   从备份点开始，获取所有后续的**归档日志**和**当前日志**。
    *   **重放 (Replay)** 这些日志中所有**已提交事务**的\*\*`Redo`\*\*部分。
    *   这个过程就像一个长时间的ARIES `Redo`阶段，将数据库的状态“前滚”到崩溃前的最新时刻。

#### **3.3 高可用性方案**

对于需要7x24小时服务的关键系统，停机进行备份恢复是不可接受的。因此，诞生了各种高可用性技术。

*   **主从复制 (Master-Slave Replication):**
    *   所有写操作在主库完成，然后通过**日志流 (Log Shipping)** 或**触发器**等方式，异步或同步地复制到一个或多个从库。
    *   当主库故障时，可以手动或自动地将一个从库**提升 (Promote)** 为新的主库。
*   **存储冗余 (RAID):** 通过磁盘阵列技术，在硬件层面提供数据冗余，可以容忍单个（或多个）磁盘的物理损坏。
*   **集群与分布式数据库:** 将数据分布在多个节点上，每个节点都有数据的副本。单个节点的故障不会影响整个系统的可用性。