---
title: "计算机动画05:群组动画(上)"
description: ""
pubDate: "2025-08-23"
heroImage: ""
---

# 计算机动画05:群组动画(上)

### **1\. 大自然的交响曲：无处不在的集体行为**

*   **海洋中的芭蕾**：一群热带鱼在珊瑚礁中同步穿梭，它们形成整齐的队形，仿佛有一个无形的指挥官在引导。它们如何做到在高速游动中既不互相碰撞，又能协同一致地躲避天敌？
*   **天空中的墨舞**：黄昏时分，成千上万只椋鸟在空中汇聚成一团变幻莫测的“黑云”。这种现象被称为“**Murmuration**”，是一种令人叹为观止的空中舞蹈。它们没有领导，没有预设的编排，每一个个体都只是在响应它身边的同伴，却共同创造出了一场宏大的、流动的视觉盛宴。
*   **生命的漩涡**：在海洋中，当沙丁鱼群面临捕食者的威胁时，它们会迅速聚集，形成一个巨大的、旋转的“鱼球”。这是一种防御机制，通过集体的力量迷惑敌人，增加个体存活的几率。图中那名潜水员的存在，让我们得以一窥这个生命漩涡内部的壮观景象。
*   **草原上的秩序**：广袤的牧场上，羊群悠闲地吃草或迁徙。它们总能保持一种微妙的平衡——既聚集在一起以获得安全感，又为彼此留出足够的空间。

这些例子，都展示了一种强大的、自下而上形成的组织力量——**集体行为 (Collective Behavior)**。

这种力量不仅限于动物世界。在我们人类社会中，它同样无处不在：

*   **历史的洪流**：想象一下古代战场的冲锋陷阵，或是现代城市中繁忙的交通枢纽。在东京涩谷那著名的十字路口，每当绿灯亮起，来自四面八方的人潮交汇穿行，每个人都在独立地走向自己的目的地，却共同构成了一幅高效而有序的流动图景。
*   **城市的脉搏**：高速公路立交桥上川流不息的车辆，大型集会上人群情绪的共振与传递。这些都是由无数个体的决策汇聚而成的宏观现象。

所有这些，都向我们提出了一个深刻的挑战：**我们如何用计算机来模拟这些由大量自主个体组成的复杂动态系统？** 这正是群组动画所要解答的核心命题。

### **2\. 银幕上的魔法：群组动画的应用实例**

让我们将目光从现实世界转向光影的艺术，看看群组动画技术是如何在电影和游戏中施展魔法的。

*   **《狮子王》的里程碑** 大家一定都记得迪士尼经典动画《狮子王》中那个令人心悸的片段——牛羚大奔逃。年幼的辛巴被困在峡谷中，成千上万的牛羚从他身边雷鸣般地奔腾而过。在那个年代，要让每一头牛羚都看起来独一无二、动态自然，是一项巨大的技术挑战。这正是群组动画技术的早期应用，通过算法赋予每个个体基本的行为逻辑，从而生成了这场动画史上的经典场面。
    
*   **游戏世界的虚拟军团** 在现代电子游戏中，无论是《全面战争》系列里的万人同屏厮杀，还是《魔兽世界》里的团队副本，大规模的NPC（非玩家角色）互动已经成为常态。要让这些虚拟士兵看起来训练有素，懂得列队、冲锋、包抄和躲避，而不是一群混乱的乌合之众，就需要高效的群组AI和动画系统在背后支撑。这一切都必须在玩家的设备上实时演算，对算法的效率提出了极高的要求。
    

### **3\. 核心理论：解构集体行为**

我们已经欣赏了许多集体行为的现象，现在，让我们深入其科学内核，给它一个更精确的定义。

**什么是集体行为 (Collective Behavior)？**

"成群的动物——如鱼群、鸟群和昆虫群——通常会展现出由**个体间社会互动 (social interactions among individuals)** 产生的**复杂而协调的行为 (complex and coordinated behaviours)**。"

这个定义中有两个关键词：**互动**与**涌现**。

*   **互动**：行为的根源不是来自一个中央大脑的命令，而是来自个体与它局部邻居之间的简单互动。
*   **涌现 (Emergence)**：这是整个领域最迷人、也最重要的概念。所谓“涌现”，指的是**由许多微观、简单的单元通过互动，在宏观层面自发地、不可预知地产生出全新的、复杂的属性和规律的现象。**
    *   **一个神经元没有智慧，但亿万个神经元连接起来，就涌现出了“意识”。**
    *   **一个水分子没有“流动性”，但无数个水分子聚集起来，就涌现出了“波浪”和“漩涡”。**
    *   同样，在群组动画中，**一个Boid（我们稍后会讲到的虚拟生物）只遵循三条简单规则，但成千上万个Boids聚集起来，就能涌现出逼真的鸟群飞行行为。**

这是一种“整体大于部分之和”的哲学思想在科学和工程领域的体现。我们的目标，就是去设计那些简单的**局部规则**，以便在全局层面“涌现”出我们想要的宏大效果。

这个领域的研究是高度交叉的，它吸引了生物学、物理学、计算机科学等领域的顶尖学者。其中，**德国马克斯·普朗克集体行为研究所的Iain Couzin教授**是该领域的泰山北斗。他的团队通过精密的实验和数学建模，揭示了鱼群、蝗虫群等生物群体的决策机制。他们的研究成果常常登上《自然》和《科学》等顶级期刊的封面，极大地启发了计算机图形学中的群组模拟算法。我强烈推荐同学们去访问他的实验室网站，那里有大量精彩的论文和演示视频。

### **4\. 群组动画的基本框架**

现在，让我们回到计算机图形学的语境下，为“群组”建立一个清晰的工程框架。

**群组的定义**

在同一物理环境下，拥有一致或相似目标的一群个体，其行为模式会因群体的存在而显著区别于其独处时的行为。

**行为的层次结构**

为了管理复杂性，我们将群组行为分解为三个层次：

*   **群 (Crowd) 层次**：关注最高层的宏观表现，如人群的整体流向、密度变化、形成的队形。
*   **组 (Group) 层次**：关注由若干个体组成的小团体行为，比如一家人手拉手在公园散步，或是一队士兵在战场上协同作战。
*   **个体 (Individual) 层次**：关注最基础单元的行为，即单个角色的动画、物理和基本决策，如行走、跑步、避开障碍物。

**核心区别：粒子系统 vs. 智能体系统**

请大家务必记住这个关键区别：

*   **粒子系统 (Particle System)**：其中的每个“粒子”是**没有智能**的。它们就像尘埃，只被动地遵循全局的物理力（如重力、风力）。适合模拟火花、雨雪、瀑布等。
*   **群组系统 (Agent-based System)**：其中的每个“个体”是一个**智能体 (Agent)**。它拥有自己的“感知-思考-行动”循环。它能“看到”周围的环境和邻居，并据此**自主决策**。这才是模拟生命群体的正确方法。

**我们今天要讨论的所有技术，都属于智能体系统的范畴。**

### **5\. 需求的驱动：为何要攻克群组动画？**

投入如此巨大的精力去研究这项技术，其背后有着强大的工业需求：

1.  **创造视觉奇观**：在电影和游戏中，宏大的群体场面是营造史诗感和沉浸感的关键。没有群组动画，我们就不可能看到《指环王》里的半兽人大军，也不可能体验到《僵尸世界大战》里令人窒息的尸潮。
2.  **解放生产力**：让动画师手动去调整成千上万个角色的动作是一项无法完成的任务。群组动画通过**程序化生成 (Procedural Generation)** 的方式，将动画师的角色从“操作工”提升为“导演”。他们只需设定好宏观规则和行为逻辑，剩下的细节就交给计算机自动完成。
3.  **降低制作成本与风险**：如果要在现实中拍摄上万人的战争场面，所需要的人力、物力和财力是天文数字，而且危险性极高。通过CG技术，我们能以更低的成本、更高的效率和绝对的安全性，实现比实拍更壮观、更具想象力的效果。

从《阿凡达》到《猩球崛起》，从《长城》到《流浪地球》，几乎所有视觉大片的背后，都有群组动画技术在默默贡献力量。

### **6\. 技术的挑战：群组动画的“硬骨头”**

实现逼真的群组动画，我们需要啃下几块“硬骨头”：

*   **海量数据与计算**：成千上万个智能体，每个都包含模型、骨骼、动画和AI数据，这对内存和计算资源是巨大的考验。
*   **秩序与混乱的统一**：群体运动既要有整体的规律性（如大方向一致），又要有局部的随机性（每个个体细微的差异），如何完美平衡这两者，是艺术和技术的双重挑战。

这些宏观特点，具体到技术实现上，就分解为以下几个核心问题：

*   **运动控制 (Motion Control)**：如何设计算法，让每个智能体都能自主导航、避免碰撞、并表现出符合角色设定的行为？**这是我们本次讲座的重中之重。**
*   **高效渲染 (Rendering)**：如何在一帧的时间内（通常是1/60秒）渲染出成千上万个高质量的角色？
*   **艺术创作 (Authoring)**：如何为艺术家提供直观、高效的工具，让他们能够轻松地“导演”一场群体大戏？
*   **细节层次 (Level of Detail, LOD)**：远处的角色不需要那么精细。如何根据距离动态切换不同复杂度的模型和动画，以节省计算资源？
*   **碰撞处理 (Collision Detection & Response)**：如何快速、稳定地处理个体之间、个体与环境之间的碰撞？

### **7\. 运动控制的“三位一体”模型**

为了解决最核心的运动控制问题，**Craig Reynolds** 提出了一套经典的分层架构，它将一个智能体的复杂运动行为分解为三个清晰的层次。我们可以称之为运动控制的“三位一体”模型。

graph TD A\["**Action Selection (行为选择)**  
_战略层：决定做什么？_  
例如：追逐敌人、逃往出口"\] --> B; B\["**Steering (导航)**  
_战术层：如何到达那里？_  
计算一个期望的力或加速度"\] --> C; C\["**Locomotion (运动)**  
_执行层：如何移动身体？_  
播放动画、更新物理状态"\] --> D\[最终的屏幕动画\]; style A fill:#ffc,stroke:#333,stroke-width:2px style B fill:#cdf,stroke:#333,stroke-width:2px style C fill:#cfc,stroke:#333,stroke-width:2px

1.  **行为选择 (Action Selection) - 战略层**
    
    *   这是智能体的“**大脑**”。它基于高级AI逻辑（如状态机、行为树）来做出决策。它回答的问题是：“**我应该做什么？**” 例如，一个士兵在战场上，它的状态可能是“巡逻”、“发现敌人”、“攻击”、“寻找掩体”或“撤退”。这一层决定了当前的目标和意图。
2.  **导航 (Steering) - 战术层**
    
    *   这是智能体的“**驾驶员**”。一旦大脑确定了目标（比如“攻击那个敌人”），导航层就负责计算出为了实现这个目标，在当前这一帧应该施加一个怎样的**力 (Steering Force)** 或加速度。它处理的是抽象的运动行为，如“追逐(Seek)”、“躲避(Flee)”、“跟随路径(Path Following)”等。它回答的问题是：“**我该如何前往那里？**” **我们接下来要详细讲解的Boids模型和各种导航行为，都属于这一层。**
3.  **运动 (Locomotion) - 执行层**
    
    *   这是智能体的“**身体**”。它接收来自导航层的指令（那个力），并将其应用到角色的物理模型上，更新其在世界中的位置和朝向。同时，它会根据当前的速度和状态，选择并播放最合适的动画片段（如行走、跑步、攻击动画）。它回答的问题是：“**我该如何具体地移动我的四肢？**”

这种分层的好处是**解耦**。我们可以独立地设计和替换每一层的算法。例如，我们可以用同一套导航算法，来驱动人形角色、汽车或者飞船，只需要为它们更换不同的运动层实现即可。

**两种核心控制思想**

在实现群体运动时，主要有两种哲学：

*   **自下而上 (Bottom-up)**：通过为每个个体设定简单的局部规则，让宏观的群体行为**自然涌现**。这就像一个自由发展的社会，充满了生机和不可预测性。**Boids模型是其典型代表。**
*   **自上而下 (Top-down)**：由设计者直接定义一个全局的“场”（如速度场或密度场），来**强制引导**个体的运动。这就像一个规划好的城市交通系统，高效且可控。**流场跟随 (Flow Field Following) 是其典型代表。**

在现代的工业应用中，往往是**两者结合**，用“自上而下”的方法进行宏观引导，用“自下而上”的规则处理局部细节，以兼顾可控性与真实感。

### **8\. 工业界的“神兵利器”**

在深入算法的海洋之前，让我们先参观一下工业界的“军火库”，看看艺术家和工程师们都在使用哪些强大的商业软件。

*   **Golaem Crowd**、**Atoms Crowd**、**Anima**：这些是当今影视和建筑可视化领域的主流选择，它们通常作为插件深度集成在Maya、Houdini等软件中，提供了友好的艺术家工作流和强大的功能集。
    
*   **Massive：群组模拟的传奇** 这款软件在群组动画领域的地位，如同Photoshop在图像处理领域的地位一样，是开创性的。它正是为了制作\*\*《指环王》三部曲\*\*中史诗般的战争场面而诞生的。
    
    *   **它的缔造者**，是来自新西兰的天才工程师**Stephen Regelous**。他花了两年时间，为导演Peter Jackson打造了这把“神兵”，并因此获得了奥斯卡科学与工程奖。
    *   **Massive的核心理念**，就是为每个数字角色赋予一个基于**模糊逻辑**的“大脑”。这个大脑能够处理复杂的感知信息（“我看到了什么？”、“我听到了什么？”），并做出近似人类的、非二元的决策。它为艺术家提供了一套可视化的AI创建工具，使得没有编程背景的人也能“设计灵魂”。
    *   可以说，Massive不仅是一款软件，它更是一套关于如何创造大规模、可信的数字生命的完整哲学。

从《金刚》中的恐龙奔逃，到《阿凡达》里潘多拉星球的生态，再到《僵尸世界大战》中堆积如山的尸潮，这些令人印象深刻的画面背后，都有Massive或类似技术的强大支持。

### **9\. 万物之源：Boids模型深度解析**

好了，铺垫了这么多，现在让我们正式进入本次讲座的硬核部分。我们将一起从零开始，推导和理解群组动画历史上最重要、最基础的模型——**Boids模型**。

这个模型由我们反复提到的Craig W. Reynolds于1987年在SIGGRAPH上发表。论文标题是《Flocks, Herds, and Schools: A Distributed Behavioral Model》。截至今天，这篇论文的谷歌学术引用量已经超过了15000次，是计算机图形学领域引用次数最高的论文之一，其影响力可见一斑。

**Boids的核心思想**

Reynolds的洞见是革命性的：**我们不必去模拟整个鸟群，我们只需要模拟一只鸟，然后让成千上万只这样的“鸟”在一起互动，真实的鸟群行为就会奇迹般地涌现出来。**

这里的“鸟”，他称之为 **Boid** (bird-oid object的缩写，意为“类鸟物体”)。

**如何模拟一只Boid？**

Reynolds提出，每个Boid的行为都由三条简单到不可思议的、基于其局部邻居的规则来驱动。这三条规则是优先级递减的：

1.  **碰撞避免 (Collision Avoidance) / 分离 (Separation)**：避免与附近的同伴撞在一起。
2.  **速度匹配 (Velocity Matching) / 对齐 (Alignment)**：尝试与附近同伴的平均速度和方向保持一致。
3.  **群体聚集 (Flock Centering) / 内聚 (Cohesion)**：尝试朝附近同伴的平均位置移动，以保持群体的聚集性。

就是这三条简单的规则，构成了所有复杂群体行为的**数字DNA**。现在，让我们用数学和代码的语言，将它们精确地表达出来。

首先，定义我们的基础数据结构。

**Boid的数据结构 (C++)**

```cpp
#include <vector>

struct Vector3 {
    float x, y, z;
    // ... 向量的各种运算，如加、减、数乘、点积、叉积、归一化、求长度等
};

class Boid {
public:
    Vector3 position;      // 位置
    Vector3 velocity;      // 速度 (方向和大小)
    Vector3 acceleration;  // 加速度
    
    float max_speed;       // 最大速度限制
    float max_force;       // 最大转向力限制
    float perception_radius; // 感知半径
    
    void update() {
        // 更新物理状态：速度 += 加速度, 位置 += 速度
        velocity += acceleration;
        // 限制速度
        velocity.limit(max_speed); 
        position += velocity;
        // 每帧重置加速度
        acceleration *= 0; 
    }
    
    void applyForce(const Vector3& force) {
        acceleration += force;
    }
    
    // ... 其他方法
};
```

我们的主循环将是：对于场景中的每一个Boid，计算它基于三条规则所受到的合力，然后更新它的物理状态。

#### **规则一：分离 (Separation)**

**目标**：避免与邻居挤作一团。

**直觉**：检查所有在感知范围内的邻居。如果某个邻居离我太近，我就产生一个远离它的力。离得越近，这个排斥力就越强。

**数学推导**： 假设当前Boid为 $b\_i$，其位置为 $\\vec{P}\_i$。对于感知范围内的任意一个邻居 $b\_j$ (位置为 $\\vec{P}\_j$)，它们之间的距离向量是 $\\vec{D} = \\vec{P}\_i - \\vec{P}\_j$。 我们想要一个排斥力，方向与 $\\vec{D}$ 相同，大小与距离成反比。一个常见的做法是让力的大小与距离的平方成反比，即 $1/|\\vec{D}|^2$。 所以，来自邻居 $b\_j$ 的排斥力可以表示为 $\\frac{\\hat{D}}{|\\vec{D}|}$ 或者更简单的 $\\frac{\\vec{D}}{|\\vec{D}|^2}$。 将所有邻居产生的排斥力相加，就得到了总的分离力。

**伪代码**：

```
function separation(boids):
  steering_force = Vector3(0, 0, 0)
  total = 0
  
  for each other_boid in boids:
    distance = distance(self.position, other_boid.position)
    
    // 检查邻居是否在感知范围内且距离大于0
    if distance > 0 and distance < self.perception_radius:
      // 计算一个与距离成反比的排斥力
      diff = self.position - other_boid.position
      diff.normalize()
      diff = diff / distance // 距离越近，力越大
      steering_force += diff
      total += 1
      
  if total > 0:
    steering_force /= total // 求平均力
    
  // 如果平均力不为零，将其调整到期望的大小
  if steering_force.length() > 0:
    steering_force.normalize()
    steering_force *= self.max_speed
    steering_force -= self.velocity // 转向力 = 期望速度 - 当前速度
    steering_force.limit(self.max_force)
    
  return steering_force
```

**可视化**：

graph TD subgraph Separation Boid\_i((Boid i)); Neighbor\_1((Neighbor 1)); Neighbor\_2((Neighbor 2)); Boid\_i -- "Repulsion Force 1" --> F1( ); Boid\_i -- "Repulsion Force 2" --> F2( ); F1 --> Resultant{Resultant Force}; F2 --> Resultant; style F1 fill:#fff,stroke:#fff style F2 fill:#fff,stroke:#fff linkStyle 0 stroke:red,stroke-width:2px,stroke-dasharray: 5 5; linkStyle 1 stroke:red,stroke-width:2px,stroke-dasharray: 5 5; linkStyle 2 stroke:blue,stroke-width:3px; linkStyle 3 stroke:blue,stroke-width:3px; end

#### **规则二：对齐 (Alignment)**

**目标**：与邻居飞向同一个方向。

**直觉**：观察我感知范围内的所有邻居，计算出它们的平均飞行速度（方向和速率），然后调整我自己的速度，使其趋向于这个平均速度。

**数学推导**： 假设在Boid $b\_i$ 的感知范围内有 $N$ 个邻居，它们的速度分别是 $\\vec{V}_1, \\vec{V}_2, ..., \\vec{V}_N$。 它们的平均速度是 $\\vec{V}_{avg} = \\frac{1}{N} \\sum_{j=1}^{N} \\vec{V}_j$。 对齐行为的目标就是让Boid $b\_i$ 产生一个转向力，使其自身的速度 $\\vec{V}_i$ 逐渐靠近 $\\vec{V}_{avg}$。这个期望的转向力 (Steering Force) 就是 $\\vec{F}_{align} = \\vec{V}_{avg} - \\vec{V}\_i$。

**伪代码**：

```
function alignment(boids):
  steering_velocity = Vector3(0, 0, 0)
  total = 0
  
  for each other_boid in boids:
    distance = distance(self.position, other_boid.position)
    
    if distance > 0 and distance < self.perception_radius:
      steering_velocity += other_boid.velocity
      total += 1
      
  if total > 0:
    steering_velocity /= total // 求平均速度
    steering_velocity.normalize()
    steering_velocity *= self.max_speed // 期望以最大速度朝该方向前进
    
    steering_force = steering_velocity - self.velocity
    steering_force.limit(self.max_force)
    return steering_force
    
  return Vector3(0, 0, 0)
```

**可视化**：

graph TD subgraph Alignment Boid\_i((Boid i)); Neighbor\_1\["Neighbor 1 -->"\]; Neighbor\_2\["Neighbor 2 -->"\]; Neighbor\_3\["Neighbor 3 -->"\]; Neighbor\_1 --> Avg\_Vel{Avg Velocity}; Neighbor\_2 --> Avg\_Vel; Neighbor\_3 --> Avg\_Vel; Boid\_i -- "Steering towards Avg" --> Avg\_Vel; linkStyle 0 stroke:green; linkStyle 1 stroke:green; linkStyle 2 stroke:green; linkStyle 3 stroke:blue,stroke-width:3px,stroke-dasharray: 5 5; end

#### **规则三：内聚 (Cohesion)**

**目标**：保持群体的紧凑，向群体中心靠拢。

**直觉**：找到我感知范围内的所有邻居，计算出它们的几何中心点，然后产生一个朝向该中心点的力。

**数学推导**： 假设在Boid $b\_i$ 的感知范围内有 $N$ 个邻居，它们的位置分别是 $\\vec{P}_1, \\vec{P}_2, ..., \\vec{P}_N$。 它们的几何中心（质心）是 $\\vec{P}_{center} = \\frac{1}{N} \\sum_{j=1}^{N} \\vec{P}_j$。 Boid $b\_i$ 想要朝这个中心点移动，所以目标位置是 $\\vec{P}_{center}$。从当前位置 $\\vec{P}_i$ 指向目标位置的期望速度向量是 $\\vec{V}_{desired} = \\vec{P}_{center} - \\vec{P}_i$。 相应的转向力就是 $\\vec{F}_{cohesion} = \\vec{V}\_{desired} - \\vec{V}\_i$。

**伪代码**：

```
function cohesion(boids):
  center_of_mass = Vector3(0, 0, 0)
  total = 0
  
  for each other_boid in boids:
    distance = distance(self.position, other_boid.position)
    
    if distance > 0 and distance < self.perception_radius:
      center_of_mass += other_boid.position
      total += 1
      
  if total > 0:
    center_of_mass /= total // 计算几何中心
    
    // 计算朝向中心的期望速度
    desired_velocity = center_of_mass - self.position
    desired_velocity.normalize()
    desired_velocity *= self.max_speed
    
    // 计算转向力
    steering_force = desired_velocity - self.velocity
    steering_force.limit(self.max_force)
    return steering_force
    
  return Vector3(0, 0, 0)
```

#### **组合规则 (Arbitration)**

现在我们有了三个独立的力，如何将它们组合起来应用到Boid上？

最简单的方法是**加权求和**： $$\\vec{F}_{total} = w_{sep}\\vec{F}_{sep} + w_{align}\\vec{F}_{align} + w_{coh}\\vec{F}\_{coh}$$ 其中 $w$ 是权重系数，可以由艺术家调整以获得不同的群体效果（比如，增加内聚权重会让群体更紧密，增加分离权重会让群体更松散）。

**主循环伪代码**：

```cpp
// 在主程序中
std::vector<Boid> flock;
// ... 初始化flock ...

// 每一帧的更新循环
void update_simulation() {
  for (Boid& b : flock) {
    // 计算三个规则的力
    Vector3 separation_force = b.separation(flock);
    Vector3 alignment_force = b.alignment(flock);
    Vector3 cohesion_force = b.cohesion(flock);
    
    // 施加权重
    separation_force *= 1.5; // 分离的优先级通常最高
    alignment_force *= 1.0;
    cohesion_force *= 1.0;
    
    // 应用合力
    b.applyForce(separation_force);
    b.applyForce(alignment_force);
    b.applyForce(cohesion_force);
    
    // 更新boid的物理状态
    b.update();
  }
}
```

一个更健壮的方法是**优先级仲裁**。因为“避免碰撞”通常比“保持队形”更紧急。我们可以设置一个力的上限 `max_force`。优先分配给分离力，如果还有余量，再分配给对齐力，以此类推。

### **拓展与补充**

Boids模型虽然简单，但它为整个领域奠定了基础。后来的无数研究都是在它的基础上进行扩展和改进的：

*   **障碍物躲避 (Obstacle Avoidance)**：除了躲避同伴，Boids还需要能躲避环境中的柱子、墙壁等。这通常通过在其前方投射一个“感知触须”来实现，如果触须碰到障碍物，就产生一个法向的排斥力。
*   **领导者跟随 (Leader Following)**：可以指定一个或几个Boid为领导者，其他Boid的行为规则里增加一条“跟随领导者”的力。
*   **路径跟随 (Path Following)**：让整个群体沿着一条预设的路径前进。
*   **流场 (Flow Field)**：如前所述的自上而下的控制方法，可以与Boids的局部规则结合，实现宏观可控、微观生动的效果。
*   **更复杂的行为**：如捕食者(Predator)与猎物(Prey)的行为。捕食者会有一个“追逐”力，而猎物会有一个强大的“逃离”力，并且猎物看到捕食者时，它的分离、对齐、内聚规则的权重会发生动态变化。