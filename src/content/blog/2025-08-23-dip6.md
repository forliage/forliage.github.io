---
title: "图像信息处理6:傅里叶变换与频域滤波"
description: ""
pubDate: "2025-08-23"
heroImage: ""
---

# 图像信息处理6:傅里叶变换与频域滤波

### **1\. 傅里叶分析的历史与思想**

#### **1.1 从泰勒级数到傅里叶级数**

*   **函数逼近思想：** 数学的核心思想之一是用简单的“基函数”的线性组合来逼近复杂的函数。
*   **泰勒级数：** 使用**幂函数** ($x^n$) 作为基函数，在某一点的邻域内逼近一个解析函数。 $$ f(x) = \\sum\_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!}(x-a)^n $$
*   **傅里叶的革命性思想：** 18世纪，法国数学家约瑟夫·傅里叶在研究热传导问题时提出，**任何周期函数**都可以表示为一系列不同频率的**正弦和余弦函数**的加权和。这就是**傅里叶级数 (Fourier Series)**。

#### **1.2 傅里叶级数 (Fourier Series, FS)**

对于一个在 $\[-\\pi, \\pi\]$ 上周期为 $2\\pi$ 的函数 $f(x)$，其傅里叶级数展开为： $$ f(x) = \\frac{a\_0}{2} + \\sum\_{n=1}^{\\infty} \[a\_n \\cos(nx) + b\_n \\sin(nx)\] $$ 其中，系数 $a\_n$ 和 $b\_n$ 利用三角函数的**正交性**计算得到： $$ a\_0 = \\frac{1}{\\pi} \\int\_{-\\pi}^{\\pi} f(x) dx \\quad (\\text{直流分量/平均值}) $$ $$ a\_n = \\frac{1}{\\pi} \\int\_{-\\pi}^{\\pi} f(x) \\cos(nx) dx \\quad (\\text{偶次谐波分量}) $$ $$ b\_n = \\frac{1}{\\pi} \\int\_{-\\pi}^{\\pi} f(x) \\sin(nx) dx \\quad (\\text{奇次谐波分量}) $$

*   **核心：** 傅里叶级数将一个复杂的周期波分解为**基频** ($n=1$) 和其**整数倍谐波** ($n=2, 3, \\dots$) 的叠加。$a\_n, b\_n$ 的大小代表了对应频率分量的“强度”。

### **2\. 傅里叶变换 (Fourier Transform, FT)**

傅里叶变换将傅里叶级数的思想从**周期函数**推广到了**非周期函数**。可以想象成将函数的周期 $T$ 趋向于无穷大，此时，离散的谐波频率会变得连续，求和也随之变成了积分。

#### **2.1 复数与欧拉公式回顾**

为了更简洁地表达傅里叶变换，我们需要使用复数。

*   一个复数 $z = a+jb$，其中 $j=\\sqrt{-1}$。
*   **欧拉公式 (Euler's Formula):** 将三角函数与复指数函数联系起来： $$ e^{j\\theta} = \\cos(\\theta) + j\\sin(\\theta) $$ 这意味着一个简单的复指数 $e^{j\\theta}$ 同时包含了正弦和余弦两种信息。
*   **幅度和相位：** $z = |z|e^{j\\phi(z)}$，其中 $|z|=\\sqrt{a^2+b^2}$ 是幅度，$\\phi(z)=\\text{atan2}(b,a)$ 是相位。

#### **2.2 连续傅里叶变换 (FT)**

*   **正变换 (Forward FT):** 将一个时域/空域函数 $f(x)$ 变换到频域，得到频谱函数 $F(u)$。 $$ F(u) = \\mathcal{F}{f(x)} = \\int\_{-\\infty}^{\\infty} f(x) e^{-j2\\pi ux} dx $$ 这里的 $u$ 代表频率。$F(u)$ 是一个复数函数，包含了每个频率分量的**幅度和相位**信息。
    
*   **逆变换 (Inverse FT, IFT):** 将频谱函数 $F(u)$ 变换回时域/空域。 $$ f(x) = \\mathcal{F}^{-1}{F(u)} = \\int\_{-\\infty}^{\\infty} F(u) e^{j2\\pi ux} du $$
    

#### **2.3 图像中的频率**

*   **低频 (Low Frequency):** 对应图像中**灰度变化缓慢**的区域，如大片的平滑表面、模糊的背景。
*   **高频 (High Frequency):** 对应图像中**灰度变化剧烈**的区域，如物体的**边缘、细节、纹理和噪声**。

### **3\. 离散傅里叶变换 (Discrete Fourier Transform, DFT)**

在计算机中，我们处理的是离散的、有限长度的信号（如图像像素），因此需要使用离散傅里叶变换。

#### **3.1 一维DFT**

对于一个长度为 $N$ 的离散序列 $f\[x\], x=0, 1, \\dots, N-1$，其DFT为：

*   **正变换 (Forward DFT):** $$F\[u\] = \\sum\_{x=0}^{N-1} f\[x\] e^{-j2\\pi ux/N}, \\quad u=0, 1, \\dots, N-1$$
*   **逆变换 (Inverse DFT):** $$f\[x\] = \\frac{1}{N} \\sum\_{u=0}^{N-1} F\[u\] e^{j2\\pi ux/N}, \\quad x=0, 1, \\dots, N-1$$

#### **3.2 二维DFT (用于图像)**

对于一幅大小为 $M \\times N$ 的图像 $f(x, y)$，其二维DFT为：

*   **正变换 (Forward 2D DFT):** $$ F(u, v) = \\sum\_{x=0}^{M-1} \\sum\_{y=0}^{N-1} f(x, y) e^{-j2\\pi (\\frac{ux}{M} + \\frac{vy}{N})}, \\quad u=0,..,M-1; v=0,..,N-1 $$
*   **逆变换 (Inverse 2D DFT):** $$ f(x, y) = \\frac{1}{MN} \\sum\_{u=0}^{M-1} \\sum\_{v=0}^{N-1} F(u, v) e^{j2\\pi (\\frac{ux}{M} + \\frac{vy}{N})} $$
*   **可分离性：** 二维DFT可以分解为先对图像的每一行做一维DFT，然后对结果的每一列再做一维DFT。

#### **3.3 傅里叶谱 (Fourier Spectrum)**

由于 $F(u,v)$ 是复数，我们通常将其分解为**幅度谱**和**相位谱**进行分析和可视化。

*   **幅度谱 (Magnitude/Amplitude Spectrum):** $$ |F(u, v)| = \\sqrt{\\text{Re}(F(u,v))^2 + \\text{Im}(F(u,v))^2} $$ 幅度谱表示了每个频率分量的强度或能量。它包含了图像的**主要结构信息**。
    
*   **相位谱 (Phase Spectrum):** $$ \\phi(u, v) = \\text{atan2}(\\text{Im}(F(u,v)), \\text{Re}(F(u,v))) $$ 相位谱记录了每个频率分量的位置信息。**相位谱对于图像的重构至关重要，它包含了物体的空间位置信息**。如果只用幅度谱重建图像，会丢失所有位置信息；而只用相位谱（配上一个常数幅度）重建，仍然能大致看清物体的轮廓。
    
*   **可视化：** DFT的幅度谱动态范围通常非常大（直流分量 $F(0,0)$ 能量最高），直接显示效果很差。我们通常对其进行对数变换以增强低能量频率分量的可视化效果： $$ D(u, v) = c \\log(1 + |F(u, v)|) $$ 此外，DFT的默认输出会将低频分量放在频谱图的四个角落。为了便于观察，我们通常使用 `fftshift` 操作将其移动到中心。
    

### **4\. 快速傅里叶变换 (Fast Fourier Transform, FFT)**

*   **问题：** 直接计算DFT的复杂度为 $O(N^2)$（一维）或 $O(M^2N^2)$（二维），对于大尺寸图像来说计算量巨大。
*   **Cooley-Tukey算法 (FFT):** 1965年，Cooley和Tukey重新发现了FFT算法。其核心思想是**分治法 (Divide and Conquer)**。
    *   **原理：** 将一个长度为 $N$ 的DFT问题，递归地分解为两个长度为 $N/2$ 的子问题（例如，将原序列分为偶数项和奇数项）。
    *   **复杂度：** 这种分解将计算复杂度从 $O(N^2)$ 显著降低到 $O(N \\log N)$。对于图像，则从 $O(M^2N^2)$ 降低到 $O(MN \\log(MN))$。这使得频域处理在实际中成为可能。

### **5\. 频域滤波 (Frequency Domain Filtering)**

频域滤波提供了一种与空间域滤波完全不同的视角。其基本流程如下：

1.  **变换到频域：** 对输入图像 $f(x,y)$ 进行FFT，得到其频谱 $F(u,v)$。
2.  **滤波操作：** 设计一个**滤波器函数** $H(u,v)$，并将其与图像频谱 $F(u,v)$ 进行**逐点相乘**。 $$ G(u, v) = F(u, v) \\cdot H(u, v) $$
3.  **变换回空域：** 对滤波后的频谱 $G(u,v)$ 进行逆FFT，得到最终的输出图像 $g(x,y)$。

#### **5.1 卷积定理 (Convolution Theorem)**

频域滤波的核心理论基础是卷积定理，它在空域和频域之间建立了一座桥梁。

*   **定理：** 两个函数在**空间域的卷积**，等价于它们各自的傅里叶变换在**频域的逐点相乘**。 $$ f(x, y) \* h(x, y) \\iff F(u, v) \\cdot H(u, v) $$ 反之亦然： $$ f(x, y) \\cdot h(x, y) \\iff F(u, v) \* H(u, v) $$
*   **意义：** 对于大的卷积核，在空间域直接计算卷积可能非常耗时。利用卷积定理，我们可以通过两次FFT和一次频域乘法来完成滤波，当核足够大时，这种方法的效率远高于空间域卷积。

#### **5.2 常用滤波器设计**

1.  **理想低通滤波器 (Ideal Low-Pass Filter, ILPF):**
    
    *   **原理：** 设定一个截止频率 $D\_0$。在以原点为中心的半径 $D\_0$ 范围内，滤波器函数值为1（通过），范围外为0（截止）。
    *   **问题：** 会产生严重的**振铃效应 (Ringing artifacts)**，因为其在频域的矩形函数对应空域的sinc函数。
2.  **高斯低通滤波器 (Gaussian Low-Pass Filter, GLPF):**
    
    *   **原理：** 滤波器函数 $H(u,v)$ 是一个高斯函数。 $$ H(u, v) = e^{-D(u,v)^2 / (2D\_0^2)} $$ 其中 $D(u,v)$ 是点 $(u,v)$ 到频域中心的距离。
    *   **优点：** 变换平滑，不会产生振铃效应。
3.  **高通滤波器 (High-Pass Filter, HPF):**
    
    *   **原理：** 与低通滤波器相反，它允许高频分量通过，抑制低频分量。
    *   **关系：** $H\_{HPF} = 1 - H\_{LPF}$
    *   **应用：** 边缘检测、图像锐化。

#### **5.3 C++ 代码示例 (使用OpenCV)**

```
#include <opencv2/opencv.hpp>
                #include <iostream>

                // 函数：将DFT结果移动到中心以便观察
                void fftShift(cv::Mat& magI) {
                    magI = magI(cv::Rect(0, 0, magI.cols & -2, magI.rows & -2));
                    int cx = magI.cols / 2;
                    int cy = magI.rows / 2;
                    cv::Mat q0(magI, cv::Rect(0, 0, cx, cy));   // Top-Left
                    cv::Mat q1(magI, cv::Rect(cx, 0, cx, cy));  // Top-Right
                    cv::Mat q2(magI, cv::Rect(0, cy, cx, cy));  // Bottom-Left
                    cv::Mat q3(magI, cv::Rect(cx, cy, cx, cy)); // Bottom-Right
                    cv::Mat tmp;
                    q0.copyTo(tmp);
                    q3.copyTo(q0);
                    tmp.copyTo(q3);
                    q1.copyTo(tmp);
                    q2.copyTo(q1);
                    tmp.copyTo(q2);
                }

                int main() {
                    cv::Mat I = cv::imread("your_image.jpg", cv::IMREAD_GRAYSCALE);
                    if(I.empty()) return -1;
                    
                    // 1. 扩展图像到最佳尺寸，并转为浮点型
                    cv::Mat padded;
                    int m = cv::getOptimalDFTSize(I.rows);
                    int n = cv::getOptimalDFTSize(I.cols);
                    cv::copyMakeBorder(I, padded, 0, m - I.rows, 0, n - I.cols, cv::BORDER_CONSTANT, cv::Scalar::all(0));
                    cv::Mat planes[] = {cv::Mat_<float>(padded), cv::Mat::zeros(padded.size(), CV_32F)};
                    cv::Mat complexI;
                    cv::merge(planes, 2, complexI);

                    // 2. 进行傅里叶变换
                    cv::dft(complexI, complexI);

                    // 3. 计算幅度和相位，并进行可视化
                    cv::split(complexI, planes); // planes[0] = Re, planes[1] = Im
                    cv::Mat magI;
                    cv::magnitude(planes[0], planes[1], magI);
                    magI += cv::Scalar::all(1); // log(1 + mag)
                    cv::log(magI, magI);
                    cv::normalize(magI, magI, 0, 1, cv::NORM_MINMAX);
                    fftShift(magI); // 移动到中心

                    // 4. 创建一个高斯低通滤波器
                    cv::Mat filter = cv::Mat(complexI.size(), CV_32FC2, cv::Vec2f(0,0));
                    int D0 = 30; // 截止频率
                    for (int i = 0; i < filter.rows; ++i) {
                        for (int j = 0; j < filter.cols; ++j) {
                            float d = std::sqrt(std::pow(i - filter.rows/2, 2) + std::pow(j - filter.cols/2, 2));
                            float h = std::exp(-d*d / (2*D0*D0));
                            filter.at<cv::Vec2f>(i, j)[0] = h;
                            filter.at<cv::Vec2f>(i, j)[1] = h;
                        }
                    }
                    fftShift(filter); // 将滤波器也移位以匹配

                    // 5. 应用滤波器并进行逆变换
                    cv::Mat filtered_complex;
                    cv::mulSpectrums(complexI, filter, filtered_complex, 0);
                    cv::dft(filtered_complex, filtered_complex, cv::DFT_INVERSE | cv::DFT_REAL_OUTPUT);
                    
                    cv::Mat result;
                    cv::normalize(filtered_complex, result, 0, 255, cv::NORM_MINMAX);
                    result.convertTo(result, CV_8U);

                    cv::imshow("Input Image", I);
                    cv::imshow("Spectrum Magnitude", magI);
                    cv::imshow("Filtered Image", result);
                    cv::waitKey(0);

                    return 0;
                }
                
```