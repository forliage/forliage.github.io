---
title: "x86汇编02:数据"
description: ""
pubDate: "2025-08-25"
heroImage: ""
---

# x86汇编02:数据

### **1.数制：与机器对话的语言**

计算机的物理基础是晶体管，它只有两种稳定状态：开和关，对应电路中的高电平和低电平。这种二元性（Duality）是计算机世界最底层的设计约束。因此，一切上层建筑都必须建立在二进制之上。

**设计的核心问题：** 如何用一种只有两个符号（0和1）的系统来表示世间万物？ **答案：** 采用**位置计数法**（Positional Notation）。一个符号的“值”不仅取决于符号本身，还取决于它所在的位置。

一个通用的位置计数法可以表示为： $$D = \\sum\_{i=-m}^{n-1} d\_i \\cdot b^i$$ 其中，$D$ 是数值，$b$ 是基数（Base），$d\_i$ 是第 $i$ 位的数码（Digit）。

#### **1.1 二进制 (Binary)**

这是机器的母语。基数 $b=2$，数码 $d\_i \\in {0, 1}$。

*   例如，二进制数 `1101.1` 表示： $1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 + 1 \\cdot 2^{-1} = 8 + 4 + 0 + 1 + 0.5 = 13.5$ (十进制)

#### **1.2 十六进制 (Hexadecimal)**

二进制对人类来说太长、太容易出错。`1101010110111110` 这样的数字，你能一眼看出它的值吗？显然不能。我们需要一种更紧凑、更便于人类读写的二进制“速记法”。

**设计的选择：** 为什么是十六进制，而不是八进制或四进制？ 因为在现代计算机体系结构中，数据处理的基本单位是**字节（Byte）**，即8个比特。一个字节可以完美地被分成两组，每组4个比特。而4个比特能表示的数字范围是 $2^4 = 16$（从0000到1111）。这使得十六进制与字节的结构形成了完美的对应关系。

*   基数 $b=16$，数码 $d\_i \\in {0, 1, ..., 9, A, B, C, D, E, F}$。
*   **核心关系**：1位十六进制数 对应 4位二进制数。

```
  Hex | Binary || Hex | Binary
                 -----|--------||-----|--------
                   0  |  0000  ||  8  |  1000
                   1  |  0001  ||  9  |  1001
                   2  |  0010  ||  A  |  1010
                   3  |  0011  ||  B  |  1011
                   4  |  0100  ||  C  |  1100
                   5  |  0101  ||  D  |  1101
                   6  |  0110  ||  E  |  1110
                   7  |  0111  ||  F  |  1111
                
```

#### **1.3 进制转换 (Conversions)**

*   **二进制 $\\leftrightarrow$ 十六进制 (最重要的转换！)** 这是汇编程序员必须掌握的肌肉记忆。转换方法是简单的分组替换。
    
    *   **二进制转十六进制**：从右向左，每4位一组，不足4位在左边补0，然后替换。 `1101010110111110` (二进制) `1101 0101 1011 1110` (分组) `D 5 B E` (替换) -> `0xD5BE`
    *   **十六进制转二进制**：每1位扩展成4位。 `0x1AF` `1 A F` `0001 1010 1111` -> `000110101111` (二进制)
*   **十进制 $\\rightarrow$ 二进制/十六进制** 方法：**除基取余法**（整数部分）。
    
    *   **十进制转二进制**：连续除以2，直到商为0，余数倒序排列。 例：转换 $26\_{10}$ $26 \\div 2 = 13 ... 0$ $13 \\div 2 = 6 ... 1$ $6 \\div 2 = 3 ... 0$ $3 \\div 2 = 1 ... 1$ $1 \\div 2 = 0 ... 1$ 倒序取余数：`11010`。所以 $26\_{10} = 11010\_2$。
        
    *   **十进制转十六进制**：同理，连续除以16。 例：转换 $427\_{10}$ $427 \\div 16 = 26 ... 11$ (B) $26 \\div 16 = 1 ... 10$ (A) $1 \\div 16 = 0 ... 1$ (1) 倒序取余数：`1AB`。所以 $427\_{10} = 1AB\_{16}$。
        
*   **二进制/十六进制 $\\rightarrow$ 十进制** 方法：**按权展开求和法**。
    
    *   $11010\_2 = 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0 = 16+8+2 = 26\_{10}$
    *   $1AB\_{16} = 1 \\cdot 16^2 + 10 \\cdot 16^1 + 11 \\cdot 16^0 = 256 + 160 + 11 = 427\_{10}$

### **2.二进制数据的组织**

CPU和内存并不是逐个比特（bit）地处理数据，这样做效率太低。硬件设计者将比特捆绑成更大的、有固定尺寸的块来进行处理。这些尺寸单位的演化，本身就是一部x86体系结构的发展史。

**核心设计原则：** 数据总线的宽度、寄存器的大小、ALU的处理能力，这三者共同决定了处理器“最喜欢”处理的数据尺寸，我们称之为**机器字长（Word Size）**。

graph TD subgraph "数据单位的层级" QWORD("**四字 Quad Word (64位)**  
x86-64 架构") DWORD("**双字 Double Word (32位)**  
IA-32 架构 (386+)") WORD("**字 Word (16位)**  
16位架构 (8086)") BYTE("**字节 Byte (8位)**  
最小可寻址单位") BIT("**位 Bit (1位)**  
基本信息单元") end QWORD --> DWORD --> WORD --> BYTE --> BIT

*   **位 (Bit, b)**: 数据的最小单位，一个0或1。
*   **字节 (Byte, B)**: **8个位**。这是现代计算机中**最重要**的数据单位。为什么？因为内存是以字节为单位进行编址的，即**字节寻址（Byte-addressable）**。内存中的每个字节都有一个唯一的地址。这是内存系统设计的基石。
*   **字 (Word)**: **2个字节 (16位)**。这是Intel 8086处理器的原生数据大小，因此“字”在x86语境下特指16位。
*   **双字 (Double Word, DWORD)**: **4个字节 (32位)**。随着80386处理器的出现，x86进入32位时代，双字成为当时主流的数据处理单位。
*   **四字 (Quad Word, QWORD)**: **8个字节 (64位)**。在x86-64架构下，寄存器和数据通路扩展到64位，四字是其原生处理单位。
*   **十字节 (Ten Bytes)**: 这是一个特殊的数据类型，**10个字节 (80位)**。它不是通用整数类型，而是x87浮点协处理器（FPU）使用的**扩展精度浮点数格式**。这种设计是为了在进行一系列浮点运算时，保持内部计算的高精度，以减小最终结果的舍入误差。我们将在浮点运算章节详细讨论它。

### **3\. 整数的类别**

一个字节 `10000001` 到底代表什么数字？是 $129$ 吗？还是 $-127$？这取决于我们如何**解释**最高位。

#### **3.1 非符号数 (Unsigned Integers)**

最简单的解释方式：所有位都用来表示数值的大小。

*   对于一个 N 位的非符号数，其表示范围是 $\[0, 2^N - 1\]$。
*   **8位非符号数 (Byte)** : 范围是 $\[0, 2^8 - 1\] = \[0, 255\]$。
*   **16位非符号数 (Word)** : 范围是 $\[0, 2^{16} - 1\] = \[0, 65535\]$。
*   **32位非符号数 (DWORD)** : 范围是 $\[0, 2^{32} - 1\] \\approx \[0, 4 \\times 10^9\]$。

#### **3.2 符号数 (Signed Integers)**

**核心设计问题：** 如何在二进制中优雅地表示负数，并使得加减法运算尽可能简单？ 历史上有过几种方案（原码、反码），但最终胜出的是**补码（Two's Complement）**。

**为什么是补码？**

1.  **唯一的零**：原码和反码都有 `+0` 和 `-0` 两种表示，这既浪费编码空间，也给硬件判断是否为零带来麻烦。补码只有一个 `0` (`0000...0000`)。
2.  **统一加减法**：在补码体系中，减法可以转换为加法。即 $A - B$ 等价于 $A + (-B)$。这允许CPU使用同一套加法器电路来完成加法和减法，极大地简化了ALU的设计。这是一个无与伦比的工程优势。

**补码的规则：**

*   **最高位（Most Significant Bit, MSB）**为**符号位**：0表示正数，1表示负数。
    
*   **正数**：其补码、原码、反码相同。
    
*   **负数**：其补码的计算方法为，其绝对值的原码**按位取反，再加1**。
    
    *   例：求 -3 的8位补码。
        1.  `+3` 的原码: `00000011`
        2.  按位取反: `11111100`
        3.  加 1: `11111101` 所以，-3 的8位补码表示为 `11111101`。
*   对于一个 N 位的符号数，其补码表示范围是 $\[-2^{N-1}, 2^{N-1} - 1\]$。注意，负数比正数多一个。
    
*   **8位符号数 (Byte)** (2.3.2.1): 范围是 $\[-128, 127\]$。
    
*   **16位符号数 (Word)** (2.3.2.2): 范围是 $\[-32768, 32767\]$。
    
*   **32位符号数 (DWORD)** (2.3.2.3): 范围是 $\[-2^{31}, 2^{31}-1\] \\approx \[-2 \\times 10^9, 2 \\times 10^9\]$。
    

### **4\. 零扩充与符号扩充**

当我们将一个小尺寸的数据（如byte）放入一个大尺寸的容器（如dword）时，必须填充多出来的高位。如何填充，取决于原始数据的类型（符号还是非符号）。

*   **零扩充 (Zero Extension)**: 用于**非符号数**。
    
    *   规则：用 `0` 填充所有高位。
    *   这保证了数值大小不变。
    *   例：将8位非符号数 `10000001` (129) 扩充到16位：`00000000 10000001` (还是129)。
    *   x86指令：`MOVZX` (Move with Zero-Extend)
*   **符号扩充 (Sign Extension)**: 用于**符号数**。
    
    *   规则：用原始数据的**符号位**填充所有高位。
    *   这保证了补码表示的数值大小不变。
    *   例：将8位符号数 `10000001` (-127) 扩充到16位： 符号位是 `1`，所以用 `1` 填充：`11111111 10000001` (仍然是 -127)。
    *   例：将8位符号数 `00000111` (7) 扩充到16位： 符号位是 `0`，所以用 `0` 填充：`00000000 00000111` (仍然是 7)。
    *   x86指令：`MOVSX` (Move with Sign-Extend)

**设计哲学：** 处理器必须提供两种不同的指令来处理这两种情况，因为对于同一个二进制串 `10000001`，它有两种截然不同的解释。程序员有责任根据数据类型选择正确的指令。这是汇编语言精确性的体现。

### **5\. 字符的表示**

计算机只能处理数字，为了表示文本，必须建立一套**字符**到**数字**的映射关系，这就是**字符编码**。

#### **2.5.1 ASCII码 (American Standard Code for Information Interchange)**

这是最基础、最经典的字符编码。它使用7位二进制数（通常存储在一个字节中，最高位为0）来表示128个字符，包括大小写字母、数字、标点符号和控制字符。

#### **2.5.2 & 2.5.3 ASCII码的设计精髓**

ASCII码表的设计充满了智慧，使得很多常用操作变得异常简单高效：

1.  **数字字符与数值的转换**
    
    *   数字 '0' 到 '9' 的ASCII码是连续的 (`0x30` 到 `0x39`)。
    *   将一个数字字符（如 '5'）转换为其对应的数值（5），只需减去 '0' 的ASCII码即可。 `'5' - '0' = 0x35 - 0x30 = 5`
    *   反之，数值转字符则加上 '0' 的ASCII码。
2.  **大小写字母的转换**
    
    *   大写字母 'A' 到 'Z' 和小写字母 'a' 到 'z' 的ASCII码也是连续的。
    *   同一个字母的大小写形式，其ASCII码值正好相差32 (`0x20`)。 `'A' = 0x41 = 0100 0001` `'a' = 0x61 = 0110 0001`
    *   观察二进制，它们的区别仅在于第5位（从右数，第0位开始）。
    *   因此，**大写转小写，只需将第5位置为1** (逻辑或 `OR` `0x20`)。
    *   **小写转大写，只需将第5位清为0** (逻辑与 `AND` `0xDF`)。
    *   这种位操作比任何算术运算都快，体现了编码设计的效率。

### **6\. 二进制数据的运算：ALU的核心能力**

CPU的核心计算单元是**算术逻辑单元（ALU）**。它能执行的原子操作，构成了所有复杂计算的基础。

#### **6.1 算术运算**

*   `ADD` (加), `SUB` (减), `MUL` (乘), `DIV` (除), `INC` (加1), `DEC` (减1)。
*   关键点：对于 `ADD` 和 `SUB`，ALU执行的位级运算对符号数和非符号数是完全一样的。但是运算结果的**解释**依赖于**标志位（Flags）**。例如，\*\*进位标志(CF)**用于非符号数溢出判断，而**溢出标志(OF)\*\*用于符号数溢出判断。我们后面会专门用一节课讲授标志寄存器。

#### **6.2 逻辑运算和移位运算**

这些运算是按位独立进行的，是汇编中进行精细位操作的强大工具。

*   **逻辑运算 (Logical Operations)**
    
    *   `AND` (与): 常用于**清零**特定位（位掩码 MASK 中为0的位）。`Value AND 0` -> `0`
    *   `OR` (或): 常用于**置位**特定位（位掩码 MASK 中为1的位）。`Value OR 1` -> `1`
    *   `XOR` (异或): 常用于**翻转**特定位，或判断两数是否相等（`A XOR A = 0`）。
    *   `NOT` (非): 按位取反。
*   **移位运算 (Shift Operations)** 移位运算是一种非常高效的乘以或除以2的幂次方的方法。
    
    *   **逻辑移位**:
        *   `SHL` (Shift Left): 左移，低位补0。每左移一位相当于乘以2。
        *   `SHR` (Shift Right): 右移，高位补0。用于**非符号数**的除法。
    *   **算术移位**:
        *   `SAL` (Shift Arithmetic Left): 与 `SHL` 完全相同。
        *   `SAR` (Shift Arithmetic Right): 右移，高位用**原符号位**填充。用于**符号数**的除法，能保持数的正负。

```
// 示例：8位数字
                  Original:      1101 0010 (-46)
                  SHR 1 (逻辑):   0110 1001 (105, 符号改变!)
                  SAR 1 (算术):   1110 1001 (-23, 符号保持, -46/2 = -23)
                
```