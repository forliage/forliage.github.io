---
title: "x86汇编07:函数"
description: ""
pubDate: "2025-08-25"
heroImage: ""
---

# x86汇编07:函数

### **1 函数的定义 (Defining a Function)**

在汇编中，“定义”一个函数，本质上只是在代码段中标示出一段代码的起点和终点。汇编器提供了两种方式来做到这一点。

#### **1.1 用标号定义函数**

这是最简单、最纯粹的方式。一个函数就是一个以唯一标号开始，以`RET`指令结束的代码块。

```
my_function:            ; 函数入口点 (标号)
                    ; --- 函数体 ---
                    ...
                    RET                 ; 函数出口点 (返回指令)
                
```

*   **设计视角**: 这种方式简单直接，但缺乏结构性。汇编器除了知道`my_function`是一个地址外，对它作为“函数”的身份一无所知。

#### **1.2 用`proc`伪指令定义函数**

为了增强代码的可读性和结构性，汇编器（如MASM）提供了`PROC`和`ENDP`伪指令来显式地定义一个过程（Procedure）。

```
my_function PROC [NEAR|FAR] ; 定义过程开始
                    ; --- 函数体 ---
                    ...
                    RET
                my_function ENDP            ; 定义过程结束
                
```

*   **`NEAR`或`FAR`**: 指定了这个函数是被段内调用（`CALL NEAR`）还是段间调用（`CALL FAR`）。这有助于汇编器生成正确的`CALL`和`RET`指令（`RET` vs `RETF`）。
*   **设计视角**: `PROC`/`ENDP`对汇编器有更丰富的语义。它帮助汇编器进行类型检查，并清晰地界定了函数的范围。对于阅读代码的人来说，这种形式也远比裸标号要清晰。这体现了编程工具从“能用”到“好用”的演进。

### **2 函数的参数传递 (Parameter Passing)**

如何将数据从调用者（Caller）传递给被调用者（Callee）？这是函数设计中最核心的问题。主要有三种方法，各有优劣。

#### **2.1 用寄存器传递参数**

*   **方法**: 调用者在执行`CALL`指令前，将参数放入约定的通用寄存器中。被调用者直接从这些寄存器中读取参数。
*   **优点**: **速度极快**。寄存器是CPU中最快的存储单元，避免了内存访问的开销。
*   **缺点**:
    1.  **数量有限**: 通用寄存器的数量非常少，无法传递大量参数。
    2.  **破坏性**: 参数会覆盖寄存器原有的值。如果调用者后续还需要使用这些寄存器，必须提前`PUSH`保存，调用结束后`POP`恢复。
    3.  **缺乏规范**: 如果没有统一约定，程序员A可能用`AX`传参，程序员B可能用`DX`，导致代码无法互操作。
*   **系统层面**: 这种方式非常适合那些被频繁调用、性能要求极高、参数很少的内部辅助函数。现代的 **`fastcall`** 调用约定就是一种标准化的寄存器传参规范，它约定前几个参数通过`ECX`, `EDX`等传递，以提升性能。
*   **例子**: 一个计算`ax = bx + cx`的函数
    
    ```
    ; --- 调用者 ---
                    MOV BX, 10
                    MOV CX, 20
                    CALL add_func
                    ; 调用后 AX = 30
    
                    add_func PROC
                    ; --- 被调用者 ---
                    MOV AX, BX
                    ADD AX, CX
                    RET
                    add_func ENDP
                    
    ```
    

#### **2.2 用变量传递参数**

*   **方法**: 调用者将参数存放在约定的全局变量或内存地址中。被调用者从这些地址读取参数。
*   **优点**:
    1.  **参数数量和大小不受限**。
    2.  **非破坏性**: 不会占用宝贵的寄存器。
*   **缺点**:
    1.  **速度慢**: 每次参数传递都涉及内存读写，开销较大。
    2.  **非可重入 (Not Re-entrant)**: 如果这个函数可能被中断，而中断服务程序又调用了同一个函数，那么后一次调用会覆盖前一次调用的参数，导致程序崩溃。因此，**这种方法在多线程或中断驱动的环境下是极其危险的**。
*   **系统层面**: 适用于参数是大型数据结构（如一个大数组或结构体）的情况，此时通常传递的是这个数据结构的**地址**。

#### **2.3 用堆栈传递参数 (The Standard Way)**

这是最通用、最强大、也是C语言等高级语言默认采用的方式。

*   **方法**: 调用者在`CALL`指令前，将参数**压入堆栈**。被调用者通过访问堆栈来获取参数。
*   **优点**:
    1.  **参数数量和大小几乎不受限**（仅受限于堆栈大小）。
    2.  **支持可重入和递归**: 每次函数调用都在堆栈上创建自己独立的“工作区”，互不干扰。
*   **缺点**: 比寄存器传参慢，因为涉及内存操作。

**动态变量与栈帧 (Stack Frame)** 为了在堆栈上高效、可靠地访问参数和局部变量，几乎所有函数都会在开头建立一个称为**栈帧 (Stack Frame)** 的结构。

*   **建立栈帧 (Prologue):**
    
    ```
    PUSH EBP            ; 1. 保存调用者的栈帧基址
                    MOV  EBP, ESP       ; 2. 将当前栈顶设为新的栈帧基址
                    SUB  ESP, local_size; 3. 为局部变量(动态变量)分配空间
                    
    ```
    
*   **销毁栈帧 (Epilogue):**
    
    ```
    MOV  ESP, EBP       ; 1. 释放局部变量空间
                    POP  EBP            ; 2. 恢复调用者的栈帧基址
                    RET
                    
    ```
    
*   **栈帧结构图:** 当函数执行到`SUB ESP`之后，堆栈的布局如下：
    
    ```
        高地址  +-----------------+
                                |    参数 n       |
                                +-----------------+  <-- [EBP + 4 + 4*n]
                                |      ...        |
                                +-----------------+
                                |    参数 1       |  <-- [EBP + 8]
                                +-----------------+
                                |  返回地址       |  <-- [EBP + 4] (由CALL指令压入)
                        EBP ->  +-----------------+
                                |  旧的 EBP       |  <-- [EBP] (由 PUSH EBP 压入)
                                +-----------------+
                                |  局部变量 1     |  <-- [EBP - 4]
                                +-----------------+
                                |      ...        |
                                +-----------------+
                                |  局部变量 m     |
                        ESP ->  +-----------------+  <-- 栈顶
                        低地址
                    
    ```
    
*   **设计与CPU架构**: `EBP`寄存器的作用是提供一个在函数执行期间**稳定不变的基准点**。`ESP`作为栈顶指针，在`PUSH`/`POP`操作中会不断变化，如果直接用`[ESP + offset]`来访问参数，`offset`的值会非常难以计算。而有了`EBP`，无论`ESP`如何变化，`[EBP + 8]`永远指向第一个参数，`[EBP - 4]`永远指向第一个局部变量。这极大地简化了编译器的代码生成和程序员的手动编码。

#### **调用约定 (Calling Conventions)**

谁负责将参数`PUSH`入栈？谁负责在函数返回后清理堆栈？这些问题由**调用约定**来规范。

##### **2.3.1 `__cdecl`**

*   **C语言默认约定**。
*   **规则**:
    1.  参数**从右到左**依次压栈。
    2.  **调用者 (Caller)** 负责清理堆栈。
*   **优点**: 支持**可变参数函数**（如`printf`）。因为调用者知道自己压入了多少个参数，所以它可以正确地清理堆栈。被调用者（如`printf`）则从左到右读取参数，直到遇到格式化字符串的结尾。
*   **例子**: `my_func(1, 2, 3)`
    
    ```
    ; --- 调用者 ---
                    PUSH 3
                    PUSH 2
                    PUSH 1
                    CALL my_func
                    ADD ESP, 12   ; 调用者清理3个4字节参数
    
                    ; --- 被调用者 (my_func) ---
                    ...
                    RET           ; 直接返回
                    
    ```
    

##### **2.3.2 `__pascal`**

*   **Pascal语言约定**。
*   **规则**:
    1.  参数**从左到右**依次压栈。
    2.  **被调用者 (Callee)** 负责清理堆Stacks。
*   **缺点**: 不支持可变参数。因为被调用者在编译时必须知道参数的总大小，才能生成正确的`RET n`指令。
*   **优点**: 生成的代码比`cdecl`稍微紧凑一些，因为多条`CALL`指令可以共用一次堆栈清理，而不是每条`CALL`后都跟一条`ADD ESP, n`。

##### **2.3.3 `__stdcall`**

*   **Win32 API 标准约定**。
*   **规则**:
    1.  参数**从右到左**依次压栈（同`cdecl`）。
    2.  **被调用者 (Callee)** 负责清理堆栈（同`pascal`）。
*   **设计哲学**: 这是`cdecl`和`pascal`的折衷。它比`cdecl`代码尺寸小，同时“从右到左”的压栈顺序在某些架构上被认为更自然。这是Windows平台上最常见的调用约定。
*   **例子**: `my_func(1, 2, 3)`
    
    ```
    ; --- 调用者 ---
                    PUSH 3
                    PUSH 2
                    PUSH 1
                    CALL my_func
                    ; (调用者什么也不做)
    
                    ; --- 被调用者 (my_func) ---
                    ...
                    RET 12        ; 被调用者清理12字节堆栈
                    
    ```
    

### **3递归 (Recursion)**

递归函数就是一个会直接或间接调用自身的函数。在高级语言中，这是一个强大的抽象工具。那么，它在底层是如何实现的呢？

**递归的CPU架构层面合理性**: 递归之所以能够在x86架构上（以及几乎所有现代架构上）完美实现，完全得益于**基于堆栈的函数调用机制**。

1.  **独立的上下文**: 每一次递归调用，都会在堆栈上创建一个**全新的、独立的栈帧**。
2.  **状态隔离**: 这个新的栈帧包含了它自己的**返回地址、旧EBP、局部变量和参数**。它与上一次调用的栈帧在内存上是完全隔离的。
3.  **LIFO行为**: `CALL`和`RET`指令天生就是后进先出（LIFO）的。最后一次调用最先返回，正好符合递归“层层深入，再层层返回”的模式。

可以说，**CPU的堆栈架构就是为实现递归而生的**。没有堆栈，递归几乎无法实现。

*   **例子**: 计算阶乘 `factorial(n)`
    
    ```
    int factorial(int n) {
                        if (n <= 1)
                            return 1;
                        else
                            return n * factorial(n - 1);
                    }
                    
    ```
    
*   **汇编实现 (`cdecl`):**
    
    ```
    factorial PROC
                        ; --- 栈帧建立 ---
                        PUSH EBP
                        MOV EBP, ESP
                        
                        MOV EAX, [EBP+8]    ; 获取参数 n
    
                        ; --- 基本情况 (Base Case) ---
                        CMP EAX, 1
                        JLE return_one      ; if (n <= 1) goto return_one
    
                        ; --- 递归步骤 (Recursive Step) ---
                        DEC EAX             ; EAX = n - 1
                        PUSH EAX            ; 压入参数 (n - 1)
                        CALL factorial      ; 递归调用 factorial(n - 1)
                        ADD ESP, 4          ; 调用者清理堆栈
    
                        ; 此时 EAX 中是 factorial(n - 1) 的结果
                        MOV EBX, [EBP+8]    ; 重新获取参数 n 到 EBX
                        IMUL EAX, EBX       ; EAX = n * factorial(n - 1)
                        
                        JMP cleanup         ; 跳转到函数结尾
    
                    return_one:
                        MOV EAX, 1          ; 返回 1
    
                    cleanup:
                        ; --- 栈帧销毁 ---
                        MOV ESP, EBP
                        POP EBP
                        RET
                    factorial ENDP
                    
    ```
    
    当调用`factorial(3)`时，堆栈会像这样增长和收缩，每一层都有自己独立的`n`值和返回地址，互不干扰：
    1.  `CALL factorial(3)` -> 创建`n=3`的栈帧。
    2.  `CALL factorial(2)` -> 创建`n=2`的栈帧。
    3.  `CALL factorial(1)` -> 创建`n=1`的栈帧。
    4.  `factorial(1)`返回1。
    5.  `factorial(2)`的栈帧恢复，计算 `2 * 1`，返回2。
    6.  `factorial(3)`的栈帧恢复，计算 `3 * 2`，返回6。