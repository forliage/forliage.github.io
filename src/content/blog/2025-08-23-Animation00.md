---
title: "计算机动画00:数学基础、关键帧技术与速度控制"
description: ""
pubDate: "2025-08-23"
heroImage: ""
---

# 计算机动画00:数学基础、关键帧技术与速度控制

本次将分为两大核心部分：

1.  **变换和旋转表示**：我们将深入探讨描述物体运动（特别是旋转）的各种数学工具，并最终找到一个能完美解决动画中旋转插值难题的终极方案。
2.  **关键帧插值与速度控制**：我们将学习如何用数学曲线（样条）来定义物体运动的**路径**，并精确控制其运动的**节奏**。

### **第一部分：变换和旋转表示——驾驭物体的姿态**

我们知道如何定义一个点沿路径的运动了。但动画中的物体不仅仅是点，它们有大小、有形状、有朝向。我们需要一套数学工具来描述这些属性的变化，这就是**几何变换 (Geometric Transformations)**。

#### **1.1 基础变换与齐次坐标**

最基本的三维变换包括：

*   **平移 (Translate)**: $$\\mathbf{p}' = \\mathbf{p} + \\mathbf{T}$$
*   **缩放 (Scale)**: $$\\mathbf{p}' = \\mathbf{S} \\mathbf{p}$$
*   **旋转 (Rotate)**: $$\\mathbf{p}' = \\mathbf{R} \\mathbf{p}$$

这里，平移是加法，而缩放和旋转是乘法，形式不统一。为了将它们统一到矩阵乘法的框架下，我们引入**齐次坐标 (Homogeneous Coordinates)**。我们将一个三维点 $(x, y, z)$ 扩展为四维向量 $\[x, y, z, 1\]^T$。

这样，所有变换都可以用一个 $4 \\times 4$ 的矩阵来表示：

*   **平移矩阵**: $$\\begin{bmatrix} 1 & 0 & 0 & t\_x \\\\ 0 & 1 & 0 & t\_y \\\\ 0 & 0 & 1 & t\_z \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}$$
*   **缩放矩阵**: $$\\begin{bmatrix} s\_x & 0 & 0 & 0 \\\\ 0 & s\_y & 0 & 0 \\\\ 0 & 0 & s\_z & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}$$
*   **旋转矩阵** (绕Z轴): $$\\begin{bmatrix} \\cos\\theta & -\\sin\\theta & 0 & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}$$

**变换的串联 (Concatenation)** 使用齐次坐标的最大好处是，一系列复杂的变换（例如，先缩放，再旋转，最后平移）可以预先通过矩阵连乘，合并成**一个**单一的复合变换矩阵 $\\mathbf{M} = \\mathbf{M}\_{translate} \\mathbf{M}\_{rotate} \\mathbf{M}\_{scale}$。然后用这个 $\\mathbf{M}$ 去变换模型的所有顶点，极大地提高了效率。**注意：矩阵乘法不满足交换律，变换的顺序至关重要！**

#### **1.2 旋转表示的挑战**

平移和缩放的插值很简单，直接对平移向量和缩放因子进行线性插值即可。但**旋转的插值**是一个非常棘手的问题。

**1\. 旋转矩阵 (Rotation Matrix)** 旋转矩阵是一个 $3 \\times 3$ 的**正交矩阵**（行列向量都是单位向量且相互正交），行列式为1。

*   **优点**：数学上严谨，无奇异性。
    
*   **缺点**：
    
    *   **冗余**: 用9个数字表示只有3个自由度的旋转。
    *   **插值困难**: 直接对两个旋转矩阵的9个元素进行线性插值，得到的中间矩阵**不再是正交矩阵**，它会引入不希望的缩放和倾斜变形。
    
    **示例**：从绕Z轴旋转90°到-90°。 $$\\mathbf{R}(90^\\circ) = \\begin{bmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$$ $$\\mathbf{R}(-90^\\circ) = \\begin{bmatrix} 0 & 1 & 0 \\\\ -1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$$ 线性插值到一半（权重0.5）： $$\\mathbf{R}\_{half} = 0.5 \\mathbf{R}(90^\\circ) + 0.5 \\mathbf{R}(-90^\\circ) = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$$ 这是一个奇异矩阵，它会把物体压扁到Z轴上，完全不是我们想要的旋转0°（单位矩阵）！
    

**2\. 欧拉角/定角 (Euler Angles / Fixed Angles)** 这是最直观的表示方法。它将任意一个三维旋转分解为绕三个坐标轴（例如X, Y, Z）的连续三次旋转。

*   **定角 (Fixed Angle)**：每次旋转都绕**世界坐标系**的轴。
    
*   **欧拉角 (Euler Angle)**：第一次旋转绕世界坐标轴，后续旋转绕**物体自身（局部）坐标系**的轴。一个有趣的性质是：按(X, Y, Z)顺序的欧拉角旋转，等价于按(Z, Y, X)顺序的定角旋转。
    
*   **优点**：
    
    *   **紧凑**：只用3个数字 $(\\theta\_x, \\theta\_y, \\theta\_z)$。
    *   **直观**：容易被人类理解和编辑。
*   **缺点**：
    
    *   **万向节死锁 (Gimbal Lock)**：这是欧拉角的致命缺陷。当中间的旋转轴（例如Y轴）旋转90°时，第一个轴（X轴）和第三个轴（Z轴）会重合。此时，系统**丢失了一个旋转自由度**。无论我们改变X轴还是Z轴的角度，都只会产生绕同一个世界轴的旋转。这会导致动画中突然的、不自然的快速翻转。
    *   **插值路径不唯一/不均匀**：对三个角度进行线性插值，得到的旋转路径往往不是最短的，且角速度不均匀。

**3\. 轴-角表示 (Axis-Angle)** 根据欧拉旋转定理，任意三维旋转都可以表示为绕**一个**任意方向的轴 $\\mathbf{a}$ 旋转一个角度 $\\theta$。

*   **优点**：
    *   **插值直观**：可以在两个姿态间插值旋转轴和旋转角。
    *   **无万向节死锁**。
*   **缺点**：
    *   **难以串联**：两个轴-角表示的旋转，其复合旋转的轴和角没有简单的计算公式。
    *   表示不唯一：$(\\mathbf{a}, \\theta)$ 和 $(-\\mathbf{a}, -\\theta)$ 表示同一个旋转。

#### **1.3 终极解决方案：四元数 (Quaternions)**

1843年，数学家哈密顿在都柏林的一座桥上散步时，灵光乍现，将四元数的乘法法则刻在了桥上：$i^2 = j^2 = k^2 = ijk = -1$。他可能未曾想到，这个抽象的数学工具，将在140多年后成为解决计算机图形学中旋转问题的完美方案。

**什么是四元数？** 一个四元数 $q$ 是一个四维数，可以写成 $q = w + xi + yj + zk$，或更方便地表示为 $\[w, \\mathbf{v}\]$，其中 $w$ 是标量部分，$\\mathbf{v}=(x,y,z)$ 是矢量部分。

**四元数与旋转的联系** 一个单位四元数（即模长 $|q| = \\sqrt{w^2+x^2+y^2+z^2} = 1$）可以用来表示一个三维旋转。其与轴-角表示 $(\\mathbf{a}, \\theta)$ 的关系为： $$q = \\left\[ \\cos\\left(\\frac{\\theta}{2}\\right), \\sin\\left(\\frac{\\theta}{2}\\right) \\mathbf{a} \\right\]$$ 其中 $\\mathbf{a}$ 是单位旋转轴。

**为什么是 $\\theta/2$？** 这是四元数“双倍覆盖”性质的体现，也是它能避免许多欧拉角问题的根源之一。一个重要的推论是，四元数 $q$ 和 $-q$ 表示**同一个**三维旋转。

**四元数的运算**

*   **乘法**：$q\_1 q\_2 = \[w\_1, \\mathbf{v}\_1\]\[w\_2, \\mathbf{v}\_2\] = \[w\_1w\_2 - \\mathbf{v}\_1 \\cdot \\mathbf{v}\_2, w\_1\\mathbf{v}\_2 + w\_2\\mathbf{v}\_1 + \\mathbf{v}\_1 \\times \\mathbf{v}\_2\]$。四元数乘法**满足结合律，但不满足交换律**。
*   **逆**: 对于单位四元数 $q=\[w, \\mathbf{v}\]$，其逆 $q^{-1} = \[w, -\\mathbf{v}\]$，也叫共轭。

**用四元数进行旋转** 要用单位四元数 $q$ 来旋转一个三维向量 $\\mathbf{p}$，首先将 $\\mathbf{p}$ 提升为纯四元数 $p=\[0, \\mathbf{p}\]$，然后执行以下运算： $$\\mathbf{p}' = q p q^{-1}$$ 结果 $\\mathbf{p}'$ 的标量部分将为0，其矢量部分就是旋转后的向量。

**证明概要**: 这个乘法展开后非常复杂，但其核心思想是，这个运算保持了向量的模长，并且最终结果的标量部分为0，因此它是一个纯粹的旋转。

**复合旋转** 先用 $q\_1$ 旋转，再用 $q\_2$ 旋转，其效果等价于用复合四元数 $q\_{comp} = q\_2 q\_1$ 进行一次旋转。这比串联轴-角要简单得多！

**四元数插值：SLERP** 四元数的最大优势在于提供了平滑、无奇异性的插值方法。单位四元数可以看作是四维空间中的**单位超球面**上的点。两个姿态就对应超球面上的两个点。

*   **线性插值 (Lerp)**：直接对四元数的四个分量进行线性插值，然后归一化。这在几何上相当于在连接两个点的**弦**上插值，速度不均匀。
*   **球面线性插值 (Spherical Linear Interpolation, SLERP)**：这是正确的插值方法。它在连接两个点的**大圆弧**上进行匀速插值。

给定两个单位四元数 $q\_1, q\_2$ 和插值参数 $u \\in \[0,1\]$，SLERP公式为： $$\\text{slerp}(q\_1, q\_2, u) = \\frac{\\sin((1-u)\\Omega)}{\\sin\\Omega} q\_1 + \\frac{\\sin(u\\Omega)}{\\sin\\Omega} q\_2$$ 其中 $\\Omega = \\arccos(q\_1 \\cdot q\_2)$ 是两个四元数在四维空间中的夹角。

**实践技巧：“最短路径”** 由于 $q$ 和 $-q$ 表示同一个旋转，从 $q\_1$ 到 $q\_2$ 的插值有两条路径（短弧和长弧）。我们通常想要走最短路径。这可以通过检查点积 $q\_1 \\cdot q\_2$ 来判断。如果 $q\_1 \\cdot q\_2 < 0$，说明夹角大于90度，我们应该插值到 $-q\_2$ 而不是 $q\_2$，以保证走的是短的那条弧。

```cpp
// C++ Quaternion Slerp 伪代码
Quaternion Quaternion::slerp(const Quaternion& q1, const Quaternion& q2, float u) {
    Quaternion q2_temp = q2;
    float dot = q1.dot(q2);

    // 如果点积为负，使用q2的相反数以走最短路径
    if (dot < 0.0f) {
        q2_temp = -q2;
        dot = -dot;
    }

    // 防止点积因浮点误差略大于1
    if (dot > 0.9995f) {
        // 角度非常小，直接线性插值并归一化，以避免除以0
        return normalize(lerp(q1, q2_temp, u));
    }

    float theta_0 = acos(dot);        // 夹角
    float theta = theta_0 * u;        // 插值后的夹角
    float sin_theta = sin(theta);
    float sin_theta_0 = sin(theta_0);

    float s1 = cos(theta) - dot * sin_theta / sin_theta_0;
    float s2 = sin_theta / sin_theta_0;

    return (q1 * s1) + (q2_temp * s2);
}
```

#### **1.4 总结：旋转表示大比拼**

表示法

优点

缺点

**旋转矩阵**

无奇异性，应用变换快

冗余（9个数），插值错误

**欧拉角**

紧凑（3个数），直观

**万向节死锁**，插值路径不佳

**轴-角**

直观，插值好

复合旋转困难

**四元数**

**平滑插值(SLERP)**，**无死锁**，复合旋转高效，紧凑（4个数）

不直观，抽象

**结论**：在动画系统中，通常的做法是：**对外**，向动画师暴露直观的欧拉角进行编辑；**对内**，将欧拉角转换为四元数进行存储、插值和运算；**最终**，在需要应用到顶点时，再将四元数转换回旋转矩阵。四元数是**内部表示旋转**的黄金标准！

### **第二部分：关键帧插值与速度控制——描绘运动的轨迹与节奏**

#### **2.1 动画中的运动控制哲学**

计算机动画的核心任务可以归结为三个层面：

*   **运动的表示 (Representation)**：如何用数学语言（函数、参数）来描述一个物体的运动状态。
*   **运动的控制与编辑 (Control & Editing)**：如何为动画师提供方便、直观的工具，让他们能够随心所欲地表达创作意图。
*   **运动的生成 (Generation)**：如何根据动画师的设定，精确计算出动画序列中每一帧的运动参数。

这其中，**关键帧动画 (Keyframe Animation)** 是最基础、也是最重要的技术。动画师只需定义少数几个“关键”时刻的状态（如位置、方向、颜色、形状等），计算机则负责自动“填充”中间的过程。这个“填充”的过程，就是我们今天要讲的**插值 (Interpolation)**。

在现代动画软件如Maya或Blender中，动画师面对的不是枯燥的数字，而是一个直观的**曲线图编辑器 (Graph Editor)**。每一条曲线都代表一个参数（如X方向平移）随时间的变化。通过编辑这些曲线的形状，动画师就能精确控制运动的每一个细节。

#### **2.2 关键帧插值的核心问题**

假设我们有一个简单的任务：让一个物体在第22帧位于点 `(-5, 0, 0)`，在第67帧位于点 `(5, 0, 0)`。这看似简单，但要做出富有表现力的动画，我们必须回答几个关键问题：

1.  **使用何种插值函数？** 是简单的直线运动，还是平滑的曲线运动？
2.  **如何参数化函数？** 如何将“时间”映射到运动路径上？
3.  **如何控制运动节奏？** 比如，我们希望物体先静止，然后加速，中途达到最大速度，接着减速，最后在第67帧精确地停下来。

一个糟糕的插值可能会产生不自然的效果，比如一个弹跳的小球，如果插值不当，可能会在落地时“穿透”地面再弹起，而不是形成一个平滑的触地反弹。

我们的解决方案分为两步：

1.  **生成空间曲线 (Space Curve)**：首先，用一条平滑的数学曲线来定义物体运动的**几何路径**。
2.  **速度控制 (Speed Control)**：然后，定义一个函数来描述物体沿这条路径运动的**快慢**。

#### **2.3 数学工具：样条曲线 (Splines)**

为了生成平滑的运动路径，我们使用一种称为**样条 (Spline)** 的数学工具。样条本质上是**分段多项式 (Piecewise Polynomials)**，即用许多低阶的多项式曲线段拼接而成。

**为什么选择分段三次多项式 (Piecewise Cubic Polynomials)？**

*   **低于三次？** 二次多项式（抛物线）没有**拐点 (inflection point)**，形态单一，难以拟合复杂的形状。
*   **高于三次？** 高次多项式虽然更灵活，但容易产生不必要的波动和振荡（称为**龙格现象**），且计算成本更高。
*   **三次多项式**是完美的平衡点：它足够简单，计算高效；同时又足够灵活，拥有拐点，能够满足我们对位置和切线的约束，从而保证曲线段之间连接的平滑性。

**连续性 (Continuity) 的概念**

当我们将曲线段拼接在一起时，连接点的平滑程度至关重要。我们用不同阶的连续性来描述它：

*   **C⁰ 连续 (位置连续)**：曲线段在连接点处相接，没有断开。这是最基本的要求。
*   **C¹ 连续 (切向连续)**：在连接点处，两条曲线段不仅位置相同，它们的切线方向和大小也相同（即一阶导数相同）。这保证了运动方向的平滑过渡，不会有尖锐的转折。对于大多数动画应用，C¹连续已经足够。
*   **C² 连续 (曲率连续)**：在连接点处，曲线的曲率也相同（即二阶导数相同）。这保证了加速度的平滑变化，对于模拟高速运动（如过山车）的摄像机路径非常重要。

graph LR subgraph "连续性等级" A("**C⁰ 连续**  
位置连续  
_(尖角)_") --> B("**C¹ 连续**  
切向连续  
_(平滑过渡)_") --> C("**C² 连续**  
曲率连续  
_(更平滑的力感)_") end

接下来，我们将深入学习几种最重要、最经典的三次样条曲线。

##### **2.3.1 埃尔米特样条 (Hermite Spline)**

埃尔米特样条是一种非常基础和强大的插值样条。定义一条埃尔米特曲线段，我们需要四个几何约束：

*   起始点位置 $\\mathbf{P}\_0$
*   终点位置 $\\mathbf{P}\_1$
*   起始点切向量 $\\mathbf{P}'\_0$
*   终点切向量 $\\mathbf{P}'\_1$

**数学推导** 我们的目标是找到一个参数范围为 $u \\in \[0, 1\]$ 的三次多项式向量函数 $\\mathbf{P}(u) = \\mathbf{a}u^3 + \\mathbf{b}u^2 + \\mathbf{c}u + \\mathbf{d}$，使其满足上述四个条件。

这里的 $\\mathbf{P}(u)$ 是一个三维向量 $(P\_x(u), P\_y(u), P\_z(u))$，系数 $\\mathbf{a, b, c, d}$ 也是三维向量。我们可以对每个分量（x, y, z）独立进行推导。以 x 分量为例： $$P\_x(u) = a\_x u^3 + b\_x u^2 + c\_x u + d\_x$$ 其一阶导数（切向量的x分量）为： $$P'\_x(u) = 3a\_x u^2 + 2b\_x u + c\_x$$

我们将四个约束条件代入：

1.  $P\_x(0) = d\_x$
2.  $P\_x(1) = a\_x + b\_x + c\_x + d\_x$
3.  $P'\_x(0) = c\_x$
4.  $P'\_x(1) = 3a\_x + 2b\_x + c\_x$

我们得到了一个关于未知系数 $(a\_x, b\_x, c\_x, d\_x)$ 的四元线性方程组。解这个方程组，得到： $$d\_x = P\_x(0)$$ $$c\_x = P'\_x(0)$$ $$a\_x = 2(P\_x(0) - P\_x(1)) + P'\_x(0) + P'\_x(1)$$ $$b\_x = 3(P\_x(1) - P\_x(0)) - 2P'\_x(0) - P'\_x(1)$$

**矩阵形式** 将解得的系数代回原多项式，可以得到更优雅的矩阵形式： $$\\mathbf{P}(u) = \\begin{bmatrix} u^3 & u^2 & u & 1 \\end{bmatrix} \\begin{bmatrix} 2 & -2 & 1 & 1 \\\\ -3 & 3 & -2 & -1 \\\\ 0 & 0 & 1 & 0 \\\\ 1 & 0 & 0 & 0 \\end{bmatrix} \\begin{bmatrix} \\mathbf{P}\_0 \\\\ \\mathbf{P}\_1 \\\\ \\mathbf{P}'\_0 \\\\ \\mathbf{P}'\_1 \\end{bmatrix}$$ 这个公式可以简写为 $\\mathbf{P}(u) = \\mathbf{U}^T \\mathbf{M}\_H \\mathbf{B}\_H$，其中：

*   $\\mathbf{U}^T = \[u^3, u^2, u, 1\]$ 是参数向量。
*   $\\mathbf{M}\_H$ 是**埃尔米特基矩阵 (Hermite Basis Matrix)**。
*   $\\mathbf{B}\_H$ 是几何约束向量。

**混合函数 (Blending Functions)** 如果我们进一步展开矩阵，将 $\\mathbf{P}(u)$ 写成几何约束的线性组合，我们会得到： $$\\mathbf{P}(u) = (2u^3 - 3u^2 + 1)\\mathbf{P}\_0 + (-2u^3 + 3u^2)\\mathbf{P}\_1 + (u^3 - 2u^2 + u)\\mathbf{P}'\_0 + (u^3 - u^2)\\mathbf{P}'\_1$$ 这里的四个关于 $u$ 的多项式，就是**埃尔米特混合函数**。它们的作用就像“权重”，决定了在参数 $u$ 处，四个几何约束（两个点和两个切向量）分别对最终位置的贡献有多大。

**如何拼接？** 要创建一条长的、平滑的复合埃尔米特曲线，我们只需让前一段的终点 $\\mathbf{P}\_1$ 和终点切向量 $\\mathbf{P}'\_1$ 作为后一段的起点 $\\mathbf{P}\_0$ 和起点切向量 $\\mathbf{P}'\_0$ 即可。这样就自动保证了 C¹ 连续性。

##### **2.3.2 贝塞尔曲线 (Bézier Curve)**

直接指定切向量对于设计师来说可能不够直观。贝塞尔曲线提供了一种更符合直觉的控制方式。一条三次贝塞尔曲线由**四个控制点** $\\mathbf{P}\_0, \\mathbf{P}\_1, \\mathbf{P}\_2, \\mathbf{P}\_3$ 定义。

*   曲线**穿过**起始点 $\\mathbf{P}\_0$ 和终点 $\\mathbf{P}\_3$。
*   中间的两个点 $\\mathbf{P}\_1, \\mathbf{P}\_2$ 不在曲线上，而是像“磁铁”一样**吸引**曲线，定义了曲线的形状。
*   起始切向量由 $\\vec{\\mathbf{P}\_0 \\mathbf{P}\_1}$ 决定，终点切向量由 $\\vec{\\mathbf{P}\_2 \\mathbf{P}\_3}$ 决定。

**与埃尔米特的关系** 贝塞尔曲线可以看作是埃尔米特曲线的一种特殊形式，其几何约束为：

*   起始点：$\\mathbf{P}\_0$
*   终点：$\\mathbf{P}\_3$
*   起始切向量：$3(\\mathbf{P}\_1 - \\mathbf{P}\_0)$
*   终点切向量：$3(\\mathbf{P}\_3 - \\mathbf{P}\_2)$

将这些代入埃尔米特的矩阵形式，可以推导出贝塞尔曲线的基矩阵 $\\mathbf{M}\_B$： $$\\mathbf{P}(u) = \\begin{bmatrix} u^3 & u^2 & u & 1 \\end{bmatrix} \\begin{bmatrix} -1 & 3 & -3 & 1 \\\\ 3 & -6 & 3 & 0 \\\\ -3 & 3 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\end{bmatrix} \\begin{bmatrix} \\mathbf{P}\_0 \\\\ \\mathbf{P}\_1 \\\\ \\mathbf{P}\_2 \\\\ \\mathbf{P}\_3 \\end{bmatrix}$$

**伯恩斯坦多项式形式 (Bernstein Polynomials)** 贝塞尔曲线还有一种更经典、更具几何意义的定义方式，即使用伯恩斯坦多项式作为混合函数： $$\\mathbf{P}(u) = \\sum\_{k=0}^{n} B\_{k,n}(u) \\mathbf{P}\_k$$ 其中 $B\_{k,n}(u) = C(n,k) u^k (1-u)^{n-k}$ 是伯恩斯坦基函数，$C(n,k) = \\frac{n!}{k!(n-k)!}$ 是二项式系数。对于三次贝塞尔曲线（n=3），公式展开为： $$\\mathbf{P}(u) = (1-u)^3 \\mathbf{P}\_0 + 3u(1-u)^2 \\mathbf{P}\_1 + 3u^2(1-u) \\mathbf{P}\_2 + u^3 \\mathbf{P}\_3$$

**德卡斯特里奥算法 (De Casteljau's Algorithm)** 这是一个非常优美的、用于计算贝塞尔曲线上任意一点的几何构造方法。其核心是**递归线性插值**。 要计算参数 $u$ 对应的点 $\\mathbf{P}(u)$：

1.  在每条控制边 $\\mathbf{P}\_k \\mathbf{P}\_{k+1}$ 上，找到按比例 $u$ 内插的点。
2.  将这些新点连接起来，形成新的线段。
3.  在这些新线段上，再次按比例 $u$ 进行内插。
4.  重复此过程，直到只剩下一个点，这个点就是 $\\mathbf{P}(u)$。

**全局控制 (Global Control)** 贝塞尔曲线有一个特点：移动任何一个控制点，**整条曲线**的形状都会改变。这种性质称为全局控制。

##### **2.3.3 Catmull-Rom样条**

动画师通常希望曲线能**穿过**他们指定的所有关键点。埃尔米特需要指定切线，贝塞尔只穿过首尾点。Catmull-Rom样条解决了这个问题。 它是一种**插值样条**，能自动计算每个内部关键点的切向量，从而保证整条曲线 C¹ 连续。

*   给定一系列控制点 $\\mathbf{P}\_{i-1}, \\mathbf{P}\_i, \\mathbf{P}\_{i+1}, \\mathbf{P}\_{i+2}$。
*   介于 $\\mathbf{P}\_i$ 和 $\\mathbf{P}\_{i+1}$ 之间的曲线段，其形状由这四个点共同决定。
*   $\\mathbf{P}\_i$ 点的切向量被巧妙地定义为其相邻两点 $\\mathbf{P}\_{i-1}$ 和 $\\mathbf{P}\_{i+1}$ 连线方向的向量： $\\mathbf{P}'\_i = s(\\mathbf{P}\_{i+1} - \\mathbf{P}\_{i-1})$ 其中 $s$ 是一个“张力”参数，通常取 $1/2$。

这样，我们有了每个点的**位置**（来自输入）和**切向量**（自动计算），就可以直接使用埃尔米特样条的框架来构建每一段曲线了。这为动画师提供了极大的便利。

**局部控制 (Local Control)** 与贝塞尔曲线不同，Catmull-Rom样条具有局部控制性。移动一个控制点 $\\mathbf{P}\_i$，只会影响到其邻近的几个曲线段，远处的曲线则不受影响。

#### **2.4 速度控制：弧长参数化**

我们已经创建了平滑的运动路径 $\\mathbf{P}(u)$，但还有一个问题：当参数 $u$ **匀速**变化时（例如从0到1），物体在空间中运动的速度**不一定是匀速的**。在曲线弯曲剧烈的地方，物体的速度会变慢；在曲线平缓的地方，速度会变快。

要实现精确的速度控制，我们必须解耦几何路径和运动速度。这需要引入**弧长 (Arc Length)** 的概念。

**弧长函数 $s(u)$** 定义为从曲线起点到参数 $u$ 处所经过的路径长度： $$s(u) = \\int\_0^u | \\mathbf{P}'(t) | dt$$ 其中 $| \\mathbf{P}'(t) |$ 是参数 $t$ 处速度向量的大小，即速率。

**弧长参数化 (Arc-Length Reparameterization)** 的目标是，找到一个新的参数化函数 $\\mathbf{P}^\*(s)$，使得当新的参数 $s$（弧长）匀速增加时，物体在空间中也以匀速运动。 这个过程分为两步：

1.  计算弧长函数 $s = S(u)$。
2.  计算其反函数 $u = S^{-1}(s) = U(s)$。
3.  得到新的曲线方程 $\\mathbf{P}^\*(s) = \\mathbf{P}(U(s))$。

**实际操作：数值方法** 对于复杂的样条曲线，弧长积分通常没有解析解。因此，我们采用数值方法，最常用的是**向前差分 (Forward Differencing)**：

1.  **预计算**：在曲线的参数 $u$ 从0到1的范围内，进行密集采样（比如1000个点）。
2.  **构建查找表**：计算每个采样点到起点的累计弧长，并存入一个查找表 `[u, arc_length]`。

```cpp
struct ArcLengthTableEntry {
    float u;
    float arc_length;
};

std::vector<ArcLengthTableEntry> build_arc_length_table(const Spline& curve, int num_samples) {
    std::vector<ArcLengthTableEntry> table;
    table.push_back({0.0f, 0.0f});

    glm::vec3 prev_point = curve.get_point(0.0f);
    float accumulated_length = 0.0f;

    for (int i = 1; i <= num_samples; ++i) {
        float u = (float)i / num_samples;
        glm::vec3 current_point = curve.get_point(u);
        accumulated_length += glm::distance(current_point, prev_point);
        table.push_back({u, accumulated_length});
        prev_point = current_point;
    }
    return table;
}
```

有了这个表，我们就可以进行双向查询：

*   **给定 u，求 s**：直接在表中查找或插值。
*   **给定 s，求 u**：在表的 `arc_length` 列中进行二分查找或线性查找，找到对应的 $u$。

**速度控制曲线 (Speed Curve)** 现在，我们可以引入最终的控制工具——速度控制曲线。这是一个2D函数 $s = S\_{control}(t)$，它将归一化的**时间** $t \\in \[0,1\]$ 映射到归一化的**弧长** $s \\in \[0,1\]$。

*   **匀速运动**：$S\_{control}(t) = t$，这是一条直线。
*   **缓入缓出 (Ease-in/Ease-out)**：$S\_{control}(t)$ 是一条S形曲线。它在开始和结束时斜率很小（速度慢），在中间斜率大（速度快）。这能产生非常自然、平滑的加减速效果。

**最终动画生成流程** 对于任意给定的时间 $t\_{current}$（在总时间 $T\_{total}$ 内）：

1.  计算归一化时间 $t = t\_{current} / T\_{total}$。
2.  通过速度控制曲线，得到归一化的目标弧长 $s = S\_{control}(t)$。
3.  将 $s$ 乘以总弧长 $L\_{total}$，得到实际的目标弧长 $s\_{actual}$。
4.  在预计算的弧长表中，查出 $s\_{actual}$ 对应的曲线参数 $u$。
5.  用这个 $u$ 计算出物体在空间曲线上的最终位置 $\\mathbf{P}(u)$。