---
title: "x86汇编05-2:转换与算术运算指令"
description: ""
pubDate: "2025-08-25"
heroImage: ""
---

# x86汇编05-2:转换与算术运算指令

### **1 转换指令 (Conversion Instructions)**

在进行算术运算之前，我们常常需要确保数据的类型和长度是匹配的。例如，不能将一个8位的数和一个16位的数直接相加。转换指令就是为了解决这类问题而生的，它们是算术运算的“数据预处理器”。

#### **1.1 扩充指令 (Extension Instructions)**

这组指令用于将一个小尺寸的数据类型扩展为一个大尺寸的数据类型，我们在第二讲中已经介绍过其理论基础：零扩展（Zero Extension）和符号扩展（Sign Extension）。

##### **1.1.1 `cbw` (Convert Byte to Word)**

##### **1.1.2 `cwd` (Convert Word to Doubleword)**

##### **1.1.3 `cdq` (Convert Doubleword to Quadword)**

*   **高级描述**: 这一族指令专门用于**符号扩展**累加器（`AX`/`EAX`/`RAX`）。
    *   `CBW`: 将 `AL` 中的8位有符号数扩展到 `AX` 中。
    *   `CWD`: 将 `AX` 中的16位有符号数扩展到 `DX:AX` 组成的32位数中。
    *   `CDQ`: 将 `EAX` 中的32位有符号数扩展到 `EDX:EAX` 组成的64位数中。
*   **CPU/架构层面**: 这些是零操作数指令，其操作数是**隐式**的（implicit）。CPU看到`CBW`，就知道要读取`AL`的符号位（bit 7），然后用这个位（0或1）填满`AH`的所有8位。`CWD`和`CDQ`同理，分别用`AX`的bit 15填充`DX`，用`EAX`的bit 31填充`EDX`。这种隐式操作数的设计是早期CISC为了缩短指令长度和简化特定任务而采用的经典手法。
*   **系统层面/设计哲学**: 为什么需要`CWD`和`CDQ`将结果扩展到`DX`/`EDX`？这完全是为了给后续的**有符号除法 `IDIV`** 做准备。`IDIV`指令要求被除数是操作数的两倍大小，并且高位部分必须存放在`DX`/`EDX`中。因此，`CWD`和`CDQ`是`IDIV`指令不可或缺的“伴侣”。
*   **例子**:
    
    ```
    ; CBW 示例
                    MOV AL, -5      ; AL = 0FBh (11111011b)
                    CBW             ; AX = 0FFFBh (-5 in 16-bit)
    
                    MOV AL, 100     ; AL = 64h (01100100b)
                    CBW             ; AX = 0064h (100 in 16-bit)
    
                    ; CWD/CDQ for IDIV
                    MOV AX, -1000   ; AX = 0FC18h
                    CWD             ; 准备用16位IDIV。DX将被AX的符号位(1)填满，DX = 0FFFFh
                                    ; 现在 DX:AX = 0FFFFFC18h, 这就是-1000的32位表示
    
                    MOV EAX, -50000
                    CDQ             ; 准备用32位IDIV。EDX将被EAX的符号位填满，EDX = 0FFFFFFFFh
                                    ; 现在 EDX:EAX 代表-50000的64位表示
                    
    ```
    

##### **1.1.4 `movsx dest, src` (Move with Sign-Extend)**

##### **1.1.5 `movzx dest, src` (Move with Zero-Extend)**

*   **高级描述**: `CBW`家族的通用、灵活版本。它们可以将任意寄存器或内存中的小尺寸数据，经过符号扩展或零扩展后，复制到更大的目标寄存器。
    *   `MOVSX`: 用于**有符号数**。
    *   `MOVZX`: 用于**无符号数**。
*   **CPU/架构层面**: 这两条指令在80386处理器中引入，是x86向32位演进的标志之一。它们体现了从“专用指令”（如CBW）到“通用指令”的设计思想转变，更符合现代编译器的需求。CPU硬件会根据指令是`MOVSX`还是`MOVZX`，来决定用源操作数的符号位还是用0来填充目标寄存器的高位部分。
*   **系统层面**: 在高级语言中，当`char`或`short`类型向`int`类型转换时，编译器会根据变量是有符号还是无符号，自动生成`MOVSX`或`MOVZX`指令。
*   **例子**:
    
    ```
    .DATA
                        signedByte   DB -2     ; 0FEh
                        unsignedByte DB 254    ; 0FEh
                    .CODE
                        ; MOVSX 示例
                        MOV AL, [signedByte]    ; AL = 0FEh
                        MOVSX CX, AL            ; CX = 0FFFEh (-2 in 16-bit)
    
                        ; MOVZX 示例
                        MOV AL, [unsignedByte]  ; AL = 0FEh
                        MOVZX CX, AL            ; CX = 00FEh (254 in 16-bit)
                        
                        ; 对比，同一个二进制串0FEh，两种不同解释
                        MOVSX ECX, [signedByte]   ; ECX = 0FFFFFFFEh (-2)
                        MOVZX ECX, [unsignedByte] ; ECX = 000000FEh (254)
                    
    ```
    

#### **1.2 换码指令: `xlat` (Translate)**

*   **高级描述**: **查表指令**。它使用`AL`寄存器的值作为索引，在一个预先定义好的字节表中查找对应的元素，并将结果存回`AL`。
*   **CPU/架构层面**: 这是一条非常“CISC”的指令。它将一个完整的查表操作（计算地址 -> 读取内存）压缩到一条指令中。其隐式操作数是：**源表基地址在`DS:BX` (16位)或`DS:EBX` (32位)中，索引在`AL`中**。CPU执行`XLAT`时，内部微码会执行类似`MOV AL, [BX+AL]`的操作。
*   **系统层面**:
    1.  **字符集转换**: 比如从ASCII码转换为另一种编码（如EBCDIC）。
    2.  **数据加密**: 实现简单的替换密码（Substitution Cipher）。
    3.  **快速计算**: 对于某些复杂的函数，如果输入范围有限，可以预先计算好结果存成表格，用`XLAT`实现快速查询，以空间换时间。
*   **例子**: 将一个0-9的数字转换为其ASCII码
    
    ```
    .DATA
                        ascii_table DB '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
                    .CODE
                        LEA BX, [ascii_table] ; 将表的基地址放入BX
                        MOV AL, 7             ; 我们想转换数字7
                        XLAT                  ; AL = ascii_table[7] = '7'
                                              ; 执行后，AL = 37h (ASCII for '7')
                    
    ```
    

### **2 算术运算指令 (Arithmetic Instructions)**

这些指令是ALU的核心功能。它们几乎都会**根据运算结果修改标志寄存器**，这是实现条件判断和程序流控制的基础。

#### **2.1 加法指令**

##### **2.1.1 `add dest, src` (Add)**

*   **高级描述**: `dest = dest + src`
*   **CPU/架构层面**: ALU执行二进制加法。运算结果会影响所有算术标志位：
    *   **CF (进位标志)**: 无符号数加法溢出时置1。 `255 + 1` -> `CF=1`
    *   **OF (溢出标志)**: 有符号数加法溢出时置1。 `127 + 1` -> `OF=1`
    *   **ZF (零标志)**: 结果为0时置1。 `-5 + 5` -> `ZF=1`
    *   **SF (符号标志)**: 结果为负数时置1。 `5 + (-10)` -> `SF=1`
    *   **PF (奇偶标志)**, **AF (辅助进位标志)** 也会被相应设置。
*   **系统层面**: 实现高级语言中的 `+` 运算符。
*   **例子**: `MOV AX, 1000h; ADD AX, 2000h;` -> `AX=3000h`

##### **2.1.2 `inc op` (Increment)**

*   **高级描述**: `op = op + 1`
*   **CPU/架构层面**: 这是`ADD op, 1`的优化版本。它的机器码通常更短，执行速度也可能更快。**一个至关重要的区别是：`INC`指令会影响除CF之外的所有算术标志位，但它从不改变CF标志！**
*   **设计哲学**: 为什么不影响CF？这使得`INC`可以在多精度运算的循环中作为计数器使用，而不会干扰`ADC`指令所依赖的CF位。
*   **系统层面**: 实现 `i++` 操作。常用于循环计数。
*   **例子**: `MOV CX, 10; INC CX;` -> `CX=11`

##### **2.1.3 `adc dest, src` (Add with Carry)**

*   **高级描述**: `dest = dest + src + CF`
*   **CPU/架构层面**: ALU在执行加法时，会将`FLAGS`寄存器中的CF位也加入运算。
*   **系统层面/设计哲学**: 这是实现\*\*多精度算术（Multi-precision Arithmetic）\*\*的关键。当你要计算的数字超过了CPU的字长（如在32位CPU上计算64位数）时，你必须分块计算。低位相加产生的进位（存放在CF中），必须被传递到高位的加法中去。
*   **例子**: 在32位模式下，计算 `12345678h:87654321h + 0ABCDEF0h:FEDCBA98h`
    
    ```
    ; 假设两个64位数分别存在 (EDX:EAX) 和 (ECX:EBX)
                    MOV EAX, 87654321h
                    MOV EDX, 12345678h
                    MOV EBX, 0FEDCBA98h
                    MOV ECX, 0ABCDEF0h
    
                    ; 1. 先加低32位
                    ADD EAX, EBX    ; EAX = 87654321h + FEDCBA98h = 18641ECB9h
                                    ; EAX中只能存32位, 所以EAX = 8641ECB9h, 并且CF=1
    
                    ; 2. 再加高32位，并带上进位
                    ADC EDX, ECX    ; EDX = EDX + ECX + CF = 12345678h + 0ABCDEF0h + 1
                                    ; EDX = 0BD024569h
    
                    ; 最终结果在 EDX:EAX 中
                    
    ```
    

#### **2.2 减法指令**

##### **2.2.1 `sub dest, src` (Subtract)**

*   **高级描述**: `dest = dest - src`
*   **CPU/架构层面**: ALU执行二进制减法（通常是`dest + (-src)`的补码加法）。同样影响所有算术标志。CF在这里作为**借位标志**：当无符号减法需要借位时（如`5 - 10`），CF置1。

##### **2.2.2 `sbb dest, src` (Subtract with Borrow)**

*   **高级描述**: `dest = dest - src - CF`。`ADC`的减法版本，用于多精度减法。

##### **2.2.3 `dec op` (Decrement)**

*   **高级描述**: `op = op - 1`。`INC`的减法版本，同样**不影响CF标志**。

##### **2.2.4 `neg op` (Negate)**

*   **高级描述**: `op = -op`。求操作数的二进制补码。
*   **CPU/架构层面**: ALU执行`0 - op`的减法。其微操作等价于先按位取反（`NOT`），再加一（`INC`）。
*   **例子**: `MOV AL, 5; NEG AL;` -> `AL = -5` (0FBh)。

##### **2.2.5 `cmp op1, op2` (Compare)**

*   **高级描述**: 比较`op1`和`op2`，并根据比较结果设置标志位。
*   **CPU/架构层面**: 这是汇编语言中**最重要的指令之一**。它的本质是执行一次“隐藏”的减法：`op1 - op2`。CPU会计算出结果，用这个结果来**设置标志位**，然后**立即丢弃计算结果**。目标操作数`op1`的值不会被改变。
*   **系统层面**: 这是所有高级语言中`if (a > b)`, `while (x != y)`等条件判断语句的硬件基础。`CMP`指令之后，必然会跟一条**条件跳转指令**（如 `JE`, `JG`, `JL` 等），这些跳转指令会检查`CMP`设置的标志位，来决定是否跳转。
*   **例子**:
    
    ```
    MOV AX, 10
                    MOV BX, 5
                    CMP AX, BX      ; 计算 10 - 5。结果为5 (非零, 正数)
                                    ; ZF=0 (非零), SF=0 (正数), CF=0 (无借位), OF=0
    
                    ; 后面可以跟:
                    ; JG greater_label ; Jump if Greater (检查 SF==OF 且 ZF==0) -> 会跳转
                    ; JE equal_label   ; Jump if Equal (检查 ZF==1) -> 不会跳转
                    
    ```
    

#### **2.3 乘法指令**

##### **2.3.1 `mul src` (Unsigned Multiply)**

##### **2.3.2 `imul src` (Signed Multiply)**

*   **高级描述**: 执行乘法。`MUL`用于无符号数，`IMUL`用于有符号数。
*   **CPU/架构层面**:
    *   **隐式操作数**: 乘法的一个操作数是`src`，另一个操作数隐式地在累加器中。
    *   **结果大小**: 两个N位数相乘，结果最大可能是2N位。因此，结果会存放在一个两倍大小的寄存器对中。
        *   `mul r/m8`: `AX = AL * r/m8`
        *   `mul r/m16`: `DX:AX = AX * r/m16`
        *   `mul r/m32`: `EDX:EAX = EAX * r/m32`
    *   **标志位**: `CF`和`OF`用于指示结果是否“溢出”了低半部分。如果结果的高半部分（`AH`/`DX`/`EDX`）为0，则`CF`和`OF`清0；否则置1。
*   **`IMUL`的扩展**: `IMUL`后来被扩展，支持更灵活的二操作数和三操作数格式，如`imul reg, r/m`和`imul reg, r/m, imm`，这使得它可以直接计算 `dest = dest * src` 或 `dest = src * const`，更受编译器欢迎。
*   **例子**:
    
    ```
    ; MUL示例
                    MOV AL, 100
                    MOV BL, 3
                    MUL BL          ; AX = AL * BL = 100 * 3 = 300 (012Ch)。AH=01, AL=2C
                                    ; 结果的高位AH不为0，所以 CF=1, OF=1
    
                    ; IMUL示例
                    MOV AL, -2      ; AL = 0FEh
                    MOV BL, 50      ; BL = 32h
                    IMUL BL         ; AX = AL * BL = -2 * 50 = -100 (0FF9Ch)
                    
    ```
    

#### **2.4 除法指令**

##### **2.4.1 `div op` (Unsigned Divide)**

##### **2.4.2 `idiv op` (Signed Divide)**

*   **高级描述**: 执行除法。`DIV`用于无符号数，`IDIV`用于有符号数。
*   **CPU/架构层面**:
    *   **隐式被除数**: 除数是`op`，被除数是隐式的，并且大小是除数的两倍。
        *   `div r/m8`: `AX / r/m8` -> 商在`AL`，余数在`AH`
        *   `div r/m16`: `DX:AX / r/m16` -> 商在`AX`，余数在`DX`
        *   `div r/m32`: `EDX:EAX / r/m32` -> 商在`EAX`，余数在`EDX`
    *   **除法异常**: 如果除数为0，或者商太大无法容纳在目标寄存器中（如 `1000h / 2h`，商是`800h`，无法放入`AL`），CPU会触发一个**0号中断**，即“除法错误”异常，通常会导致程序崩溃。
*   **系统层面**: `IDIV`前必须确保被除数被正确地符号扩展，这就是`CBW`/`CWD`/`CDQ`的用武之地。
*   **例子**: 计算 -48 / 5
    
    ```
    MOV AX, -48     ; AX = 0FFD0h
                    CWD             ; 符号扩展AX到DX:AX。DX = 0FFFFh
                    MOV BX, 5
                    IDIV BX         ; DX:AX / BX = -48 / 5
                                    ; 商在AX: AX = -9 (0FFF7h)
                                    ; 余数在DX: DX = -3 (0FFFDh)
                    
    ```
    

#### **2.5 浮点运算指令 (A Brief Introduction)**

到目前为止，我们讨论的都是整数运算。对于小数和科学计算，x86架构提供了一个专门的部件——**浮点运算单元 (FPU)**，早期是作为x87协处理器存在的，后来被集成进CPU。

##### **2.5.1 浮点数的存储格式 (IEEE 754)**

浮点数在内存中以一种科学记数法的二进制形式存储，通常是32位（单精度）或64位（双精度）。它由三部分组成：

*   **符号位 (Sign)**: 1位，表示正负。
*   **指数位 (Exponent)**: 8位或11位，表示2的多少次方（有一个偏移量）。
*   **尾数位 (Mantissa/Significand)**: 23位或52位，表示小数部分的有效数字。 其值约等于: $(-1)^{Sign} \\times (1.Mantissa) \\times 2^{(Exponent - Bias)}$

##### **2.5.2 8个小数寄存器 (FPU Register Stack)**

FPU内部有8个80位的扩展精度浮点寄存器，它们被组织成一个**堆栈**结构，名为`ST(0)`到`ST(7)`。`ST(0)`永远是栈顶。

##### **2.5.3 浮点运算举例**

FPU指令通常以'F'开头。

*   **`FLD src` (Float Load)**: 将内存中的浮点数`src`压入FPU栈顶`ST(0)`。
    
*   **`FADD`, `FSUB`, `FMUL`, `FDIV`**: 执行浮点加减乘除。它们可以操作FPU栈顶的两个数，或栈顶与内存中的数。
    
*   **`FST dest` / `FSTP dest` (Float Store / Store and Pop)**: 将`ST(0)`的值存回内存。`FSTP`还会将`ST(0)`从栈中弹出。
    
*   **例子**: 计算 `3.14 * 2.0`
    
    ```
    .DATA
                        pi   DD 3.14   ; 汇编器会自动转换为IEEE 754格式
                        two  DD 2.0
                        result DD ?
                    .CODE
                        FINIT           ; 初始化FPU
                        FLD [pi]        ; FPU栈: ST(0)=3.14
                        FLD [two]       ; FPU栈: ST(0)=2.0, ST(1)=3.14
                        FMUL ST(0), ST(1); ST(0) = ST(0) * ST(1) = 2.0 * 3.14 = 6.28。ST(1)不变
                        FSTP [result]   ; 将结果6.28存入result，并弹出FPU栈
                                        ; FPU栈: ST(0)=3.14
                        FSTP [result]   ; 清理堆栈
                    
    ```