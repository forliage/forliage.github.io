---
title: "x86汇编10-1:保护模式基础"
description: ""
pubDate: "2025-08-25"
heroImage: ""
---

# x86汇编10-1:保护模式基础

### **引言**

*   **实模式 (Real Mode)**: CPU的“蛮荒时代”。
    
    *   **优点**: 简单、直接。`物理地址 = 段地址 * 16 + 偏移`，程序可以直接操控硬件。
    *   **致命缺点**:
        1.  **无保护**: 任何程序都可以覆写操作系统内核或其他程序的内存。病毒和恶意软件可以为所欲为。
        2.  **寻址限制**: 只能访问1MB内存。
        3.  **无特权级**: 所有代码都运行在最高权限，无法区分操作系统和应用程序。
    *   **比喻**: 一个没有法律、没有警察、没有产权划分的村庄。
*   **保护模式 (Protected Mode)**: CPU的“法治社会”。
    
    *   **核心设计目标**: 为**多任务抢占式操作系统**提供硬件级别的支持。
    *   **核心特征**: **保护 (Protection)** 和 **扩展寻址 (Extended Addressing)**。
    *   **比喻**: 一个拥有宪法（CPU硬件规则）、政府（OS内核）、警察（权限检查）、身份证（段选择子）和房产证（段描述符）的现代化城市。

### **1 保护模式与实模式的根本区别**

特性

实模式 (Real Mode)

保护模式 (Protected Mode)

设计目的的转变

**寻址能力**

1MB (20位地址线)

4GB (32位地址线)

突破内存限制，支持大型应用程序。

**内存寻址**

`物理地址 = 段*16 + 偏移`

**间接寻址**：`段选择子 -> 描述符表 -> 段描述符 -> 基地址 + 偏移`

**引入抽象层**。地址不再是简单的计算，而是受硬件规则约束的查表过程。

**内存保护**

**无**

**有**。硬件检查段限长和访问类型。

**核心特性**。防止程序越界访问，保证系统稳定。

**特权级别**

**无** (所有代码同级)

**4个特权级 (Rings 0-3)**。硬件强制执行权限规则。

区分OS内核与应用程序，防止恶意代码破坏系统。

**虚拟内存**

不支持

**支持** (通过分段和分页机制)

为每个任务提供独立的、巨大的虚拟地址空间。

### **2保护模式的段机制：从“地址计算”到“权限查验”**

在保护模式下，段寄存器（CS, DS等）里存放的不再是一个可以直接用于计算的段地址。它存放的是一个16位的**段选择子 (Segment Selector)**。

**段选择子**就像一张“身份证”，它不告诉你你家在哪，而是告诉你你的档案号。你需要拿着这个档案号，去“户籍管理处”查找你的详细档案。

这个“户籍管理处”，就是**描述符表 (Descriptor Table)**。主要有两种：

*   **全局描述符表 (GDT - Global Descriptor Table)**: 系统级的，只有一个，存放OS内核、所有任务共享的段信息。
*   **局部描述符表 (LDT - Local Descriptor Table)**: 每个任务可以有自己的一个，存放该任务私有的段信息。

CPU中有两个特殊的寄存器来定位这些表：`GDTR`和`LDTR`。

#### **2.1 段描述符 (Segment Descriptor)——段的“房产证”**

描述符表中的每一个表项，就是一个8字节的**段描述符**。这才是段的真正定义，它详细说明了一个段的一切属性。

**一个8字节（64位）段描述符的结构:**

位

63-56

55

54

53

52

51-48

47

46-45

44

43-40

39-16

15-0

**字段**

Base 31:24

G

D/B

L

AVL

Limit 19:16

P

DPL

S

Type

Base 23:0

Limit 15:0

**含义**

基地址

粒度

默认大小

64位标志

系统可用

段限长

存在位

权限级

描述符类型

段类型

基地址

段限长

**核心字段解析 (设计哲学):**

*   **Base Address (32位)**: 段的**起始物理地址**。它被分成了三段（历史遗留原因），但组合起来是一个完整的32位地址。这意味着段可以从4GB物理内存的任何地方开始。
*   **Limit (20位)**: 段的**大小**。这是内存保护的关键。任何访问 `Base + Offset` 如果 `Offset > Limit`，CPU会立即触发**通用保护异常 (#GP)**。
*   **G (Granularity) 位**: **粒度位**。这是个聪明的工程设计。
    *   `G = 0`: Limit的单位是**字节**。段最大为 $2^{20}-1 = 1MB$。
    *   `G = 1`: Limit的单位是**4KB**。段最大为 $(2^{20}-1) \\times 4KB \\approx 4GB$。这使得用20位就能描述一个巨大的段。
*   **P (Present) 位**: **存在位**。`P=1`表示该段在物理内存中。`P=0`表示不在。如果程序访问一个P=0的段，CPU会触发**缺段异常 (#NP)**。这是操作系统实现**虚拟内存**（将内存换出到硬盘）的硬件基础。
*   **DPL (Descriptor Privilege Level)**: **描述符特权级 (0-3)**。规定了**访问这个段所需要的最低权限**。Ring 0 (OS内核) 最高，Ring 3 (应用程序) 最低。
*   **S (System/Code-Data) 位**: `S=1`表示是普通的**代码段或数据段**。`S=0`表示是**系统段**（如LDT描述符、任务状态段TSS、门描述符等）。
*   **Type 字段**: 进一步定义段的类型，如：只读数据段、可读写数据段、只执行代码段、可读可执行代码段等。

#### **2.2 如何访问保护模式下的段**

*   **加载段选择子**: `MOV DS, AX` 这条指令在保护模式下意义大变。它不再是简单的数值传送。CPU执行这条指令时，会：
    1.  用`AX`中的选择子去GDT或LDT中查找对应的描述符。
    2.  进行一系列权限和有效性检查。
    3.  如果一切合法，CPU会将这个8字节的描述符加载到一个**不可见的、与段寄存器关联的高速缓存**中。
    4.  此后，所有使用`DS`的内存访问，都直接使用这个高速缓存中的基地址和限长，而**无需每次都去查GDT**。这极大地提升了性能。
*   **访问数据段**:
    
    ```
    ; 假设GDT中第2个描述符(index=1, 8字节一个)定义了一个数据段
                    MOV AX, 1 * 8       ; Selector for GDT index 1. RPL=0, TI=0
                    MOV DS, AX          ; 加载选择子, 触发描述符加载和缓存
                    MOV EAX, [100h]     ; 访问 DS:[100h]。CPU会检查 100h 是否小于该段的Limit
                    
    ```
    
*   **访问代码段**: 代码段的切换是受严格控制的。你**不能**用`MOV CS, AX`来改变代码段。只能通过特定的控制转移指令，如**远跳转 (`JMP FAR`)** 或 **远调用 (`CALL FAR`)**。 `JMP FAR new_cs_selector:new_offset` CPU在执行这条指令时，会用`new_cs_selector`去加载和检查新的代码段描述符，同时进行严格的权限检查。

### **3 保护模式的段访问权限检查**

这是保护模式的灵魂。每一次内存访问，CPU硬件都会自动执行一系列检查。

**核心参与者:**

*   **CPL (Current Privilege Level)**: 当前程序的特权级。存放在`CS`寄存器选择子的低2位。
*   **RPL (Requestor's Privilege Level)**: 请求者的特权级。存放在你用来访问数据的那个段选择子（如`MOV DS, AX`中`AX`的低2位）的低2位。
*   **DPL (Descriptor Privilege Level)**: 描述符定义的特权级。存放在段描述符中。

#### **3.1 数据段访问权限规则**

*   **规则**: `数值上 max(CPL, RPL) <= DPL`
    *   **翻译成人话**: 你自己的权限，以及你伪装成的权限，都必须**高于或等于**你要访问的数据段所要求的权限。（数值越小，权限越高）。
*   **设计哲学**:
    *   **`CPL <= DPL`**: 这是基本规则。Ring 3的应用程序（CPL=3）不能直接访问Ring 0的内核数据（DPL=0）。这是为了防止应用程序破坏操作系统。
    *   **`RPL`的作用**: `RPL`用于防止“特权木马”问题。一个Ring 0的内核程序，可以被一个Ring 3的程序调用（通过调用门）。如果这个Ring 3程序传递了一个指向它自己内存的指针，让内核程序去写。内核程序（CPL=0）在访问这个指针时，如果不加检查，就会用Ring 0的权限去写Ring 3的内存。`RPL`机制要求内核在访问应用程序提供的指针时，必须将选择子的`RPL`设置为应用程序的CPL（即3）。这样，访问规则变成 `max(0, 3) <= DPL`，即`3 <= DPL`，从而确保内核程序只能以Ring 3的权限去访问应用程序的内存，防止了权限滥用。

#### **3.2 代码段访问权限规则 (一致性代码段 vs. 非一致性代码段)**

*   **非一致性代码段 (Non-conforming Code Segment)**:
    
    *   **规则**: **严格匹配**。`CPL == DPL`。
    *   **设计哲学**: 这是默认行为。Ring 3的程序只能跳转到Ring 3的代码段。内核（Ring 0）只能跳转到内核代码段。不允许低权限代码直接跳转到高权限代码中执行。
*   **一致性代码段 (Conforming Code Segment)**:
    
    *   **规则**: **只允许从低权限跳转到高权限**。`CPL >= DPL`。跳转后，**CPL不会改变**。
    *   **设计哲学**: 用于存放一些共享的、特权不敏感的库函数。例如，一个数学库。Ring 3的程序可以调用它，Ring 0的内核也可以调用它。当Ring 3调用时，CPL保持为3，该数学库也只能以Ring 3的权限运行，无法访问内核数据。
*   **通过“门(Gate)”提权**: 低权限代码要执行高权限代码（如系统调用），唯一合法途径是通过**调用门(Call Gate)**。门是一种特殊的描述符，它提供了一个受控的、唯一的入口点，允许CPL从3变为0，同时跳转到内核代码的指定位置。
    

### **4 如何从保护模式返回实模式**

这是一个主要用于**操作系统引导加载程序 (Bootloader)** 的高级操作。例如，一个加载程序可能需要进入保护模式来访问全部内存以加载内核，然后再返回实模式来调用旧的BIOS中断。

**步骤 (必须严格按序):**

1.  **加载实模式段寄存器**: 将`DS`, `ES`, `SS`等加载为符合`段*16`计算的实模式段值。
2.  **创建GDT中实模式风格的描述符**: 创建一个基地址为0，限长为64KB的段描述符，并用`JMP FAR`跳转到这个段，使得`CS`指向一个类似实模式的段。
3.  **关闭分页 (Paging)**: 如果分页机制已开启（CR0寄存器的PG位置1），必须先将其关闭。
4.  **关闭保护模式**: 这是最关键的一步。通过`MOV`指令修改**控制寄存器CR0**，将其最低位**PE (Protection Enable)** 清零。
    
    ```
    MOV EAX, CR0
                    AND AL, 0FEh  ; Clear PE bit (bit 0)
                    MOV CR0, EAX
                    
    ```
    
5.  **刷新指令流水线**: 在清零PE位后，必须立即跟一个`JMP`指令，以清空CPU内部已经被预取和译码的保护模式指令。
6.  此时，CPU已完全返回实模式。

### **5 如何调试保护模式程序**

*   **挑战**: 在实模式下，程序崩溃了，通常只是死机。但在保护模式下，一个微小的错误（如GDT设置错误，一个错误的Limit）都会触发CPU的硬件异常。如果异常处理程序本身也有问题，就会导致**双重故障 (Double Fault)**，甚至**三重故障 (Triple Fault)**。三重故障是CPU无法处理的终极错误，硬件会直接**复位**，导致计算机重启。
*   **解决方案**:
    *   **模拟器/虚拟机 (Bochs, QEMU, VMware)**: 这是**唯一可靠**的调试方法。模拟器可以完全模拟CPU的行为，即使发生三重故障，它也可以“暂停”下来，让你检查发生重启前一瞬间所有寄存器、内存和GDT的状态。Bochs尤其以其精确的CPU模拟和强大的调试日志而闻名。
    *   **硬件调试器 (JTAG)**: 专业开发人员使用，通过物理接口直接连接到CPU的调试端口，可以在硬件层面控制和观察CPU。