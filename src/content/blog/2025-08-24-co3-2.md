---
title: "计算机组成3-2:数字运算"
description: ""
pubDate: "2025-08-24"
heroImage: ""
---

# 计算机组成3-2:数字运算

#### **第三部分：整数乘法 (Integer Multiplication)**

我们在小学就学过多位数乘法，通常称之为“竖式乘法”。计算机实现乘法的基本思想与此非常相似，只是过程是在二进制下进行的。

##### **3.1 “笔算”乘法回顾**

让我们回顾一下二进制的“竖式乘法”过程。例如，计算 $1000\_2 \\times 1001\_2$ (即 $8 \\times 9$)：

```
      1000   (Multiplicand - 被乘数)
                x 1001   (Multiplier - 乘数)
                -------
                  1000   (LSB of Multiplier is 1, copy Multiplicand)
                 0000    (Next bit is 0, place 0s)
                0000     (Next bit is 0, place 0s)
            + 1000      (MSB is 1, copy Multiplicand, shifted left)
            ----------------
              10010000   (Product - 积)
                
```

观察这个过程，我们可以总结出硬件需要执行的核心操作：

1.  **检查：** 逐位检查乘数的每一位。
2.  **判断与加法：** 如果乘数当前位是1，将被乘数（做适当的移位后）加到部分积上；如果是0，则加0。
3.  **移位：** 被乘数相对于部分积每次向左移动一位（或者说，部分积每次向右移动一位）。

这个简单的算法构成了我们设计乘法器硬件的基础。注意一个关键点：**两个n位数相乘，结果最多需要2n位来存储。**

##### **3.2 乘法器硬件设计：一个演进的故事**

我们将通过三个版本的迭代，来设计一个高效的32位乘法器。

**版本一：最直观的设计**

根据“笔算”算法，我们马上可以构思出第一版硬件：

*   **被乘数寄存器 (Multiplicand):** 64位，初始时，被乘数放在右侧32位。
*   **乘数寄存器 (Multiplier):** 32位。
*   **积寄存器 (Product):** 64位，初始为0。
*   **ALU:** 64位，用于执行加法。
*   **控制单元:** 协调整个流程。

**算法流程：**

1.  检查乘数寄存器的最低位 (Multiplier0)。
2.  如果 Multiplier0 = 1，则将“被乘数寄存器”的值加到“积寄存器”。
3.  将被乘数寄存器 **左移** 1位。
4.  将乘数寄存器 **右移** 1位。
5.  重复以上步骤32次。

**评价：** 这个设计能工作，但非常**浪费**。64位的被乘数寄存器有一半空间是0，64位的ALU也只在处理逐渐增大的数字，效率低下。

**版本二：首次优化**

**核心洞察：** 与其每次将被乘数左移，不如保持被乘数不变，而将**积向右移**。这在数学上是等价的。

**优化后的硬件：**

*   **被乘数寄存器 (Multiplicand):** 32位，保持不变。
*   **乘数寄存器 (Multiplier):** 32位。
*   **积寄存器 (Product):** 64位，初始为0。
*   **ALU:** **32位**！它只负责将被乘数加到积的高32位。

**算法流程：**

1.  检查乘数寄存器的最低位 (Multiplier0)。
2.  如果 Multiplier0 = 1，则将“被乘数寄存器”的值加到“积寄存器”的**高32位**。
3.  将**积寄存器**整体 **右移** 1位。
4.  将乘数寄存器 **右移** 1位。
5.  重复32次。

**评价：** 这是一个巨大的进步！我们成功地将ALU的尺寸减半，大大节省了硬件成本。但我们还能做得更好。

**版本三：最终的精炼设计**

**核心洞察：** 观察版本二，我们有一个专门的乘数寄存器在不断右移，它的位被一个个“消费”掉。与此同时，积寄存器的低32位一开始是0，随着每次右移，逐渐被填入有意义的位。这两个操作是互补的。

**最终优化：** **将乘数寄存器与积寄存器的低32位合并！**

**最终的硬件：**

*   **被乘数寄存器 (Multiplicand):** 32位。
*   **积寄存器 (Product):** 64位。**初始化时，低32位存放乘数，高32位清零。**
*   **ALU:** 32位。

**算法流程：**

1.  检查**积寄存器**的最低位 (Product0)。
2.  如果 Product0 = 1，则将“被乘数寄存器”的值加到“积寄存器”的**高32位**。
3.  将**积寄存器**整体 **右移** 1位。
4.  重复32次。

**评价：** 这个设计非常优雅和高效。它用最少的硬件资源完成了任务，是现代处理器中基本乘法器设计的原型。

##### **3.3 有符号乘法：布斯算法 (Booth's Algorithm)**

前面的设计只适用于无符号数。对于补码表示的有符号数，直接套用会出错。 一种简单粗暴的方法是：先记录操作数的符号，将它们转为正数相乘，最后根据原始符号决定积的符号。但这需要额外的逻辑。

一个更强大、直接处理补码的算法是**布斯算法**。 **核心思想：** 识别乘数中的连续的'1'串。 例如，一个数乘以 `001110` ($14\_{10}$)。

*   传统方法需要加法3次 (`2^1+2^2+2^3`)。
*   布斯算法发现 `001110 = 010000 - 000010` ($16-2$)。
*   于是，乘法可以转换为：**(被乘数 << 4) - (被乘数 << 1)**。只需要一次加法和一次减法，如果移位比加法快，整体速度就可能提升。

**算法规则：** 布斯算法不再只看乘数的当前位，而是**同时观察当前位 (i) 和前一位 (i-1)**（初始时，想象第-1位是0）。

当前位 (i)

前一位 (i-1)

含义

操作

0

0

连续的0

仅移位

0

1

'1'串的结束

加被乘数，再移位

1

0

'1'串的开始

减被乘数，再移位

1

1

'1'串的中间

仅移位

**重要：** 这里的移位是**算术右移 (Arithmetic Shift Right)**，即右移时，用符号位填充最高位，以保持部分积的符号正确性。

**示例：计算 $2 \\times (-3)$，即 $0010 \\times 1101$ (4位)**

*   被乘数M = `0010`，-M = `1110`
*   积寄存器初始化为 `0000 1101 0` (高4位为0，中4位为乘数，最低位为想象中的前一位)

步骤

积寄存器内容

最后两位

操作

0

`0000 1101 0`

`10`

减 M (加 -M) -> `1110 1101 0`

算术右移

`1111 0110 1`

1

`1111 0110 1`

`01`

加 M -> `0001 0110 1`

算术右移

`0000 1011 0`

2

`0000 1011 0`

`10`

减 M (加 -M) -> `1110 1011 0`

算术右移

`1111 0101 1`

3

`1111 0101 1`

`11`

仅移位

算术右移

`1111 1010 1`

最终结果在高8位：`11111010`，这是-6的8位补码，结果正确。

#### **第四部分：整数除法 (Integer Division)**

除法比乘法更复杂，因为它涉及到试探性的操作（试商）。

##### **4.1 “笔算”除法回顾**

同样从“竖式除法”开始。例如，计算 $1001010\_2 \\div 1000\_2$ (即 $74 \\div 8$):

```
        1001    (Quotient - 商)
                      -------
                1000 | 1001010  (Dividend - 被除数)
                     - 1000     (Remainder -= Divisor)
                     -------
                         0010   (Remainder is positive)
                          0101  (Bring down next bits)
                        - 1000  (Remainder -= Divisor) -> Negative! Restore.
                     -------
                         1010
                       - 1000
                     -------
                          0010  (Remainder - 余数)
                
```

**核心操作：**

1.  **比较与减法：** 将除数与被除数（或当前余数）的相应部分比较。如果够减，就执行减法，商上1。
2.  **恢复：** 如果不够减（减后为负），说明商错了，商上0，并且**必须把除数加回去**，恢复原来的余数。
3.  **移位：** 除数右移一位（或被除数/余数左移一位），进行下一轮操作。

##### **4.2 除法器硬件设计**

**版本一：恢复余数法 (Restoring Division)**

这个设计直接模拟了笔算过程，特别是“恢复”这一步。

**硬件：**

*   **除数寄存器 (Divisor):** 64位，除数放在左半部分。
*   **商寄存器 (Quotient):** 32位。
*   **余数寄存器 (Remainder):** 64位，初始放入被除数。
*   **ALU:** 64位。

**算法流程：**

1.  **减法：** 从余数寄存器中减去除数寄存器的值。
2.  **检查余数：**
    *   如果余数 $\\ge 0$（结果非负），说明商的这一位是1。将商寄存器左移一位，并将最低位置1。
    *   如果余数 $< 0$（结果为负），说明商的这一位是0。**将除数加回到余数寄存器中（恢复操作）**，然后将商寄存器左移一位，最低位补0。
3.  **移位：** 将除数寄存器右移一位。
4.  重复33次（需要额外一步来修正最后可能的错误）。

**评价：** 这个算法逻辑清晰，但效率很低。无论商是0还是1，都需要做一次减法。如果商是0，还需要做一次额外的加法来恢复余数，一个周期内可能要做两次 ALU 运算。

**优化：改进的除法器硬件 (类似于乘法器V3)**

**核心洞察：**

1.  和乘法器一样，我们可以固定除数，而移动余数和商。
2.  ALU只需要32位。
3.  商寄存器可以和余数寄存器的右半部分合并。

**改进后的硬件：**

*   **除数寄存器 (Divisor):** 32位。
*   **余数寄存器 (Remainder):** 64位。**初始化时，被除数放入右半部分**。
*   **ALU:** 32位。

**算法流程 (32位除法)：**

1.  **初始化：** 余数寄存器高32位为0，低32位为被除数。
2.  **循环32次：** a. **左移：** 将整个余数寄存器**左移**1位。 b. **减法：** 用余数寄存器的**高32位**减去除数。 c. **检查：** \* 如果结果 $\\ge 0$，将减法结果写回余数寄存器的高32位，并将余数寄存器的**最低位置1**。 \* 如果结果 $< 0$，**恢复**余数寄存器的高32位（即放弃减法结果），并将余数寄存器的**最低位置0**。
3.  **结束：** 循环结束后，余数寄存器的高32位是最终**余数**，低32位是最终**商**。

这个设计是现代处理器中整数除法器的基础模型。

##### **4.3 有符号除法**

有符号除法更复杂。最简单的方法是：

1.  记录被除数和除数的符号，将它们的绝对值用于无符号除法，得到商和余数的绝对值。
2.  **确定符号：**
    *   **商的符号：** 如果被除数和除数同号，商为正；异号则为负。
    *   **余数的符号：** 通常约定余数的符号与**被除数**的符号相同。
    *   必须满足基本等式：**被除数 = 商 $\\times$ 除数 + 余数**。

**除以零：** 这是一个异常情况，硬件必须能检测到。当检测到除数为0时，会触发一个**异常**，交由操作系统处理。

#### **第五部分：浮点数 (Floating-Point Numbers)**

整数的世界是有限的。我们无法用它表示分数（如 $0.5$），也无法表示非常大或非常小的数（如宇宙的质量或一个电子的质量）。为此，计算机科学借鉴了科学记数法，发明了**浮点数**表示法。

##### **5.1 IEEE 754 标准**

为了保证不同计算机之间浮点数运算的一致性，电气和电子工程师协会（IEEE）制定了IEEE 754标准，这已成为全球公认的浮点数表示和运算标准。

**基本格式：** 一个浮点数被表示为：$N = (-1)^S \\times M \\times 2^E$

*   **S (Sign):** 符号位。0代表正数，1代表负数。
*   **E (Exponent):** 指数。决定了数的大小范围。
*   **M (Mantissa/Significand):** 尾数（或称有效数）。决定了数的精度。

**两种主要精度：**

*   **单精度 (Single Precision):** 32位。
    *   1位符号位 (S) | 8位指数 (E) | 23位尾数 (Fraction)
*   **双精度 (Double Precision):** 64位。
    *   1位符号位 (S) | 11位指数 (E) | 52位尾数 (Fraction)

**两个关键约定：**

1.  **规格化表示 (Normalization):** 为了使表示唯一，规定尾数M必须是 `1.xxxx...` 的形式（其中 `xxxx...` 是存储在尾数部分的二进制小数）。因为最高位的1是固定的，所以**这个1是隐含的，不需要存储**。这相当于免费获得了1位的精度！
    
2.  **偏置指数 (Biased Exponent):** 指数E可以是正数也可以是负数（例如 $2^{10}$ 或 $2^{-5}$）。为了方便硬件直接比较两个浮点数的大小（只需按无符号整数比较即可），指数部分采用**偏置表示法**存储。
    
    *   **实际指数 = 存储的指数 - 偏置值 (Bias)**
    *   单精度偏置值 (Bias) = 127 ($2^{8-1}-1$)
    *   双精度偏置值 (Bias) = 1023 ($2^{11-1}-1$)

**示例：用单精度表示 -0.75**

1.  **转二进制：** $-0.75\_{10} = -0.11\_2$。
2.  **规格化：** 将小数点移动到第一个1的后面，得到 $-1.1\_2 \\times 2^{-1}$。
3.  **确定各部分：**
    *   **符号 (S):** 因为是负数，S = 1。
    *   **尾数 (Fraction):** 规格化后的小数部分是 `.1`。补全23位，为 `10000000000000000000000`。
    *   **指数 (E):** 实际指数是 -1。存储的指数 = 实际指数 + 偏置值 = $-1 + 127 = 126\_{10}$。
    *   $126\_{10}$ 的8位二进制是 `01111110`。
4.  **组合：** `S | Exponent | Fraction` `1 | 01111110 | 10000000000000000000000`

##### **5.2 特殊值：0, 无穷大, NaN**

IEEE 754标准还用保留的指数值来表示一些特殊情况：

*   **指数全为0：**
    *   如果尾数也全为0，表示**零**（有+0和-0）。
    *   如果尾数不为0，表示**非规格化数 (Denormalized Number)**。这是一种非常接近于0的数，牺牲了隐含的1，以实现“平滑下溢”。
*   **指数全为1：**
    *   如果尾数全为0，表示**无穷大 (Infinity)**（有$+\\infty$和$-\\infty$），例如 $1.0 \\div 0.0$ 的结果。
    *   如果尾数不为0，表示\*\*“不是一个数” (Not a Number, NaN)\*\*，例如 $0.0 \\div 0.0$ 或 $\\sqrt{-1}$ 的结果。

##### **5.3 浮点数运算**

浮点数运算比整数运算复杂得多，因为它需要分别处理符号、指数和尾数。

**浮点加法/减法** $A \\pm B = (M\_A \\times 2^{E\_A}) \\pm (M\_B \\times 2^{E\_B})$

**算法流程：**

1.  **对阶 (Alignment):** 比较两个数的指数。将指数较小的那个数的尾数**右移**，同时其指数**增加**，直到两个数的指数相同。**这一步可能会导致精度损失**。
2.  **尾数相加/减：** 对对阶后的两个尾数执行加法或减法。
3.  **规格化 (Normalization):** 运算结果可能不再是`1.xxxx...`的形式。需要将其左移或右移，并相应地调整指数，直到满足规格化要求。
4.  **舍入 (Rounding):** 在对阶和规格化过程中，可能会产生无法存储的额外位。需要按照一定的规则（如向偶数舍入）进行舍入，以保证结果的精确性。
5.  **检查溢出：** 检查最终的指数是否超出了表示范围。

**浮点乘法** $(M\_A \\times 2^{E\_A}) \\times (M\_B \\times 2^{E\_B}) = (M\_A \\times M\_B) \\times 2^{(E\_A + E\_B)}$

**算法流程：**

1.  **指数相加：** 将两个偏置指数相加，然后**减去一个偏置值**，得到新的偏置指数。
    *   $(E\_{storeA} - Bias) + (E\_{storeB} - Bias) = (E\_{storeA} + E\_{storeB}) - 2 \\times Bias$
    *   所以新的存储指数是 $E\_{storeA} + E\_{storeB} - Bias$。
2.  **尾数相乘：** 将两个尾数（包括隐含的1）相乘。
3.  **规格化：** 乘积的整数部分可能不是1，需要进行规格化。
4.  **舍入：** 对结果进行舍入。
5.  **确定符号：** 两个操作数的符号位进行**异或 (XOR)** 运算。

浮点除法的流程与乘法类似，只是将指数相减、尾数相除。这些复杂的步骤都由专门的**浮点运算单元 (FPU)** 硬线逻辑来完成。

**本讲总结**

1.  **乘法**是通过一系列的“判断-加法-移位”操作完成的，其硬件设计经过了多次迭代优化，最终实现了高效紧凑的结构。布斯算法则为处理有符号数提供了优雅的解决方案。
2.  **除法**在概念上更具挑战性，因为它包含“试商”和可能的“恢复”步骤。其硬件结构与乘法器有相似之处，但控制逻辑更为复杂。
3.  **浮点数**通过遵循**IEEE 754**标准，使计算机能够以有限的位数表示范围极大、精度较高的实数。我们理解了其核心的规格化、偏置指数等概念，并了解了浮点加法和乘法的基本流程，这些流程的复杂性远超整数运算。