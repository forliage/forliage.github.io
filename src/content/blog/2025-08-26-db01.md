---
title: "数据库系统01:关系模型(The Relational Model)"
description: ""
pubDate: "2025-08-26"
heroImage: ""
---

# 数据库系统01:关系模型(The Relational Model)

### **引言**

在关系模型诞生之前，数据库世界是怎样的？是**网状模型**和**层次模型**的天下。想象一下，数据就像一个复杂的迷宫，应用程序员需要像探险家一样，手持“指针”或“路径”，小心翼翼地在数据记录之间穿梭。

*   **层次模型 (Hierarchical Model):** 数据被组织成树形结构。优点是对于一对多关系描述清晰，查询效率高。但缺点是致命的：如果两个实体是多对多关系（例如，一个学生可以选多门课，一门课可以被多个学生选），就必须通过冗余数据来模拟，极其笨拙。
*   **网状模型 (Network Model):** 允许多个父节点，解决了多对多问题。但它引入了复杂的“指针链表”来维护记录间的关系。这导致了什么问题？
    *   **导航式访问 (Navigational Access):** 程序员必须在代码中明确指出如何从一条记录“导航”到下一条。查询逻辑与数据的物理存储路径紧密耦合。
    *   **数据独立性差:** 一旦底层数据存储结构发生变化（比如为了优化，增加了一个新的索引或路径），所有访问这些数据的应用程序代码都可能需要重写。这是一场维护的噩梦。

**设计哲学之问：** 我们能否创建一个模型，让用户只关心“**要什么数据 (What)**”，而不用关心“**如何获取数据 (How)**”？

这就是埃德加·科德（Edgar F. Codd）在1970年那篇划时代的论文《A Relational Model of Data for Large Shared Data Banks》中要解决的核心问题。他的答案是：**关系模型**。其核心思想是，用一种简单、直观、且具有坚实数学基础的结构来组织数据，并将数据的复杂关系交由数据库管理系统（DBMS）处理，从而将程序员从迷宫中解放出来。

### **第一部分：何为“关系”？**

关系模型只用了极少的几个概念就构建了整个大厦。我们来逐一解构其设计思想。

#### **1.1 核心结构：从数学到表格**

*   **域 (Domain):** 一个**原子**值的集合。例如，`所有整数的集合`，`所有长度小于20的字符串集合`。
    
    *   **设计哲学：原子的重要性 (Atomicity - 第一范式 1NF)**
        *   **为什么要求原子性？** 如果一个字段可以再分（比如一个“地址”字段包含“国家-省份-城市”），那么你就无法对“城市”进行独立的查询、排序或建立索引。原子性确保了数据表中每个单元格的值都是不可再分的最小信息单元，这极大地简化了数据处理的逻辑。这是关系模型为简单性做出的第一个重要设计决策。
        *   **拓展思考：** 现代数据库（如PostgreSQL）支持JSON或数组类型，这是否违背了原子性？是的，在某种程度上是的。这是为了应对半结构化数据存储需求而做出的权衡，牺牲了一部分模型的纯粹性，换取了灵活性。
*   **关系 (Relation):**
    
    *   **形式化定义:** 给定一组域 $D\_1, D\_2, \\ldots, D\_n$，一个**关系** $r$ 是笛卡尔积 $D\_1 \\times D\_2 \\times \\ldots \\times D\_n$ 的一个**子集**。
    *   **直观理解:** 一个关系就是一个**二维表格**。
*   **元组 (Tuple):** 关系（表格）中的**一行**。代表一个现实世界中的实体或实体间的联系。
    
*   **属性 (Attribute):** 关系（表格）中的**一列**。每个属性都有一个名称和对应的域。
    

#### **1.2 关系模式 (Schema) vs. 关系实例 (Instance)**

*   **关系模式 (Schema):** 这是关系的“蓝图”或“骨架”，定义了关系的名称、属性及其域。例如：`学生(学号: CHAR(10), 姓名: VARCHAR(20), 专业: VARCHAR(30))`。我们通常用 $R(A\_1, A\_2, \\ldots, A\_n)$ 表示。
*   **关系实例 (Instance):** 这是在某一时刻，关系中元组的**具体集合**，即表格中的实际数据。实例是随时间变化的（增删改），而模式通常是稳定的。

**设计哲学：蓝图与建筑的分离** 这种分离是数据独立性的核心体现。应用程序是针对稳定的“蓝图”（Schema）编写的，而DBMS则负责管理不断变化的“建筑”（Instance）。无论数据如何增删，只要不改变蓝图，应用程序就无需修改。

#### **1.3 关系的内在属性：无序与唯一**

Codd的关系模型直接继承自数学上的“集合”理论，这赋予了它两个至关重要的特性：

1.  **元组无序性:** 作为一个集合，关系中的元组没有先后顺序。第一行和第五行没有任何本质区别。
2.  **元组唯一性:** 集合论的基本定义，集合中没有重复的元素。因此，关系中不允许存在两条完全相同的元组。

**设计哲学：为何坚持“集合”？**

*   **逻辑数据独立性：** “无序性”意味着你可以按任何顺序存储或检索元组，查询结果的正确性不受影响。DBMS可以自由地根据物理存储（如索引）来优化访问路径，而用户无需关心。
*   **实体完整性：** “唯一性”保证了表中的每一行都唯一地标识一个现实世界的实体。如果存在重复行，那么“学生张三”这条记录到底是指哪个张三？数据将产生歧义。这个特性通过**键 (Key)** 来强制实现。

### **第二部分：完整性约束**

如果关系模型仅仅是提供了一个表格结构，那它还不够强大。其真正的威力在于能够定义和强制执行数据世界的“法律”——完整性约束。

#### **2.1 键 (Keys)：实体的唯一标识**

如何确保元组的唯一性？通过“键”。

*   **超键 (Superkey):** 一个或多个属性的集合，其值能**唯一**确定一个元组。例如，在`学生`表中，`{学号}`是一个超键，`{学号, 姓名}`也是一个超键。
*   **候选键 (Candidate Key):** **最小**的超键。即，从该属性集合中移除任何一个属性，它就不再是超键。例如，`{学号}`是候选键，而`{学号, 姓名}`不是，因为移除了`姓名`后，`{学号}`依然是超键。如果`{身份证号}`也能唯一标识学生，那它也是一个候选键。
*   **主键 (Primary Key):** 被数据库设计者从一个或多个候选键中**选定**的一个，用作该关系中元组的主要标识。
    *   **设计哲学：为何要指定主键？**
        1.  **明确性：** 为表中的每一行提供一个明确、无歧义的“官方”ID。
        2.  **性能：** DBMS通常会为主键自动创建索引，以极大地加速基于主键的查找和连接操作。
        3.  **引用：** 主键是其他表引用本表记录的“锚点”（通过外键）。
    *   **最佳实践：** 通常选择“人造”的、无业务含义的键（如自增ID、UUID）作主键，而不是有业务含义的键（如身份证号），因为业务需求可能会变（比如身份证号可能升位）。

#### **2.2 外键 (Foreign Key)：关系间的桥梁**

如果数据库只有一个表，那将毫无意义。外键是建立表与表之间联系的机制，是维护**参照完整性 (Referential Integrity)** 的核心。

*   **定义：** 关系 $r\_1$ 中的一个属性集合 $FK$，它引用了关系 $r\_2$ 的主键 $PK$。这意味着，$r\_1$ 中 $FK$ 的每一个值，要么必须等于 $r\_2$ 中某个元组的 $PK$ 值，要么必须为 `NULL`。
    *   $r\_1$ 称为**参照关系 (Referencing Relation)**。
    *   $r\_2$ 称为**被参照关系 (Referenced Relation)**。

**设计哲学：杜绝“悬空指针”** 外键机制从根本上解决了网状/层次模型中的“悬空指针”问题。它保证了：

*   你不能在一个`选课表`中插入一条记录，其`学号`在一个不存在的`学生表`中。
*   你不能从`学生表`中删除一个学生，如果这个学生的`学号`还在`选课表`中被引用（除非定义了级联删除等策略）。

这确保了数据的一致性和有效性，将数据校验的责任从成千上万的应用程序代码中解放出来，统一由DBMS保证。

### **第三部分：关系代数**

关系代数是一套对关系进行运算的语言，它是查询语言（如SQL）的理论基础。每个操作的输入是一个或多个关系，输出是一个**新的关系**。这个“**闭包**”特性（运算结果仍然是同类对象）使得操作可以被任意嵌套和组合，构建出复杂的查询。

#### **3.1 六种基本运算 (Fundamental Operations)**

这六种运算构成了关系代数的完备集，理论上可以表达所有的关系查询。

1.  **选择 (Select) - $\\sigma$**
    
    *   **作用：** 过滤元组（行）。
    *   **语法：** $\\sigma\_p(r)$，其中 $p$ 是选择谓词（条件）。
    *   **与SQL的联系：** `WHERE` 子句。
    *   **示例：** 查询A="β"且D>5的元组。 $\\sigma\_{A='β' \\land D>5}(r)$
    
    $$ r=\\begin{array}{|c|c|c|c|} \\hline A & B & C & D \\\\ \\hline \\alpha & \\alpha & 1 & 7 \\\\ \\hline \\alpha & \\beta & 5 & 7 \\\\ \\hline \\beta & \\beta & 12 & 3\\\\ \\hline \\beta & \\beta & 23 & 10 \\\\ \\hline \\end{array} $$
    
    $$ \\sigma\_{A=\\beta \\land D\_{>5}}(r)=\\begin{array}{|c|c|c|c|} \\hline A & B & C & D\\\\ \\hline \\beta &\\beta & 23 & 10\\\\ \\hline \\end{array} $$
    
2.  **投影 (Project) - $\\Pi$**
    
    *   **作用：** 选择属性（列）。
    *   **语法：** $\\Pi\_{A\_1, A\_2, \\ldots, A\_k}(r)$
    *   **与SQL的联系：** `SELECT` 后的列名列表。
    *   **设计哲学：结果仍是集合。** 投影操作后，如果出现重复的元组，会自动被**消除**，因为输出必须是一个合法的关系（集合）。这是关系代数与典型SQL `SELECT` 的一个重要区别（SQL默认不消除重复，需要使用`DISTINCT`）。
    *   **示例：** 从关系r中投影出A和C两列。 $\\Pi\_{A, C}(r)$ $$ r=\\begin{array}{|c|c|c|} \\hline A & B & C\\\\ \\hline \\alpha & 10 & 1\\\\ \\hline \\alpha & 20 & 1 \\\\ \\hline \\beta & 30 & 1\\\\ \\hline \\beta & 40 & 2\\\\ \\hline \\end{array} $$
    
    $$ \\Pi\_{A,C}(r)=\\begin{array}{|c|c|} \\hline A & C \\\\ \\hline \\alpha & 1\\\\ \\hline \\alpha & 1\\\\ \\hline \\beta & 1\\\\ \\hline \\beta & 2\\\\ \\hline \\end{array} \\Longrightarrow \\begin{array}{|c|c|} \\hline A & C \\\\ \\hline \\alpha & 1\\\\ \\hline \\beta & 1\\\\ \\hline \\beta & 2\\\\ \\hline \\end{array} $$
    
3.  **并 (Union) - $\\cup$**
    
    *   **作用：** 合并两个关系的元组。
    *   **语法：** $r \\cup s$
    *   **要求：** $r$ 和 $s$ 必须是**并兼容 (Union-compatible)** 的，即：
        1.  它们具有相同的属性数量（元数相同）。
        2.  对应属性的域相同（或兼容）。
    *   **与SQL的联系：** `UNION`。
    *   **示例：** $$ r = \\begin{array}{|c|c|} \\hline A & B \\\\ \\hline \\alpha & 1 \\\\ \\hline \\alpha & 2\\\\ \\hline \\beta & 1 \\\\ \\hline \\end{array}\\quad s=\\begin{array}{|c|c|} \\hline A & B \\\\ \\hline \\alpha & 2 \\\\ \\hline \\beta & 3\\\\ \\hline \\end{array} $$
    
    $$ r \\cup s=\\begin{array}{|c|c|} \\hline A & B \\\\ \\hline \\alpha & 1 \\\\ \\hline \\alpha & 2 \\\\ \\hline \\beta & 1 \\\\ \\hline \\beta & 3 \\\\ \\hline \\end{array} $$
    
4.  **差 (Set Difference) - $-$**
    
    *   **作用：** 从一个关系中减去另一个关系中存在的元组。
    *   **语法：** $r - s$
    *   **要求：** 同样需要并兼容。
    *   **与SQL的联系：** `EXCEPT` (在某些SQL方言中是 `MINUS`)。
    *   **示例：** $$ r = \\begin{array}{|c|c|} \\hline A & B \\\\ \\hline \\alpha & 1 \\\\ \\hline \\alpha & 2\\\\ \\hline \\beta & 1 \\\\ \\hline \\end{array}\\quad s=\\begin{array}{|c|c|} \\hline A & B \\\\ \\hline \\alpha & 2 \\\\ \\hline \\beta & 3\\\\ \\hline \\end{array} $$
    
    $$ r-s=\\begin{array}{|c|c|} \\hline A & B \\\\ \\hline \\alpha & 1 \\\\ \\hline \\beta & 1 \\\\ \\hline \\end{array} $$
    
5.  **笛卡尔积 (Cartesian Product) - $\\times$**
    
    *   **作用：** 将两个关系的所有元组进行所有可能的配对，生成一个更“宽”的关系。
    *   **语法：** $r \\times s$
    *   **设计哲学：所有连接的基础。** 笛卡尔积本身很少直接使用，因为它会产生大量无意义的组合。但它是所有**连接 (Join)** 操作的理论基础。一个连接操作可以被看作是一个**笛卡尔积**紧跟着一个**选择**操作。
    *   **示例：** $$ r = \\begin{array}{|c|c|} \\hline A & B \\\\ \\hline \\alpha & 1 \\\\ \\hline \\beta & 2\\\\ \\hline \\end{array}\\quad s=\\begin{array}{|c|c|c|} \\hline C & D & E\\\\ \\hline \\alpha & 10 & a \\\\ \\hline \\beta & 10 & a \\\\ \\hline \\beta & 20 & b \\\\ \\hline \\gamma & 10 & b \\\\ \\hline \\end{array} $$
    
    $$ r \\times s = \\begin{array}{|c|c|c|c|c|} \\hline A & B & C & D & E\\\\ \\hline \\alpha & 1 & \\alpha & 10 & a \\\\ \\hline \\alpha & 1 & \\beta & 10 & a \\\\ \\hline \\alpha & 1 & \\beta & 20 & b \\\\ \\hline \\alpha & 1 & \\gamma & 10 & b \\\\ \\hline \\beta & 2 & \\alpha & 10 & a \\\\ \\hline \\beta & 2 & \\beta & 10 & a \\\\ \\hline \\beta & 2 & \\beta & 20 & b \\\\ \\hline \\beta & 2 & \\gamma & 10 & b \\\\ \\hline \\end{array} $$
    
    *   **注意：** 如果 $r$ 和 $s$ 有同名属性，需要先用重命名操作解决冲突。
6.  **重命名 (Rename) - $\\rho$**
    
    *   **作用：** 为关系或其属性赋予新的名称。
    *   **语法：** $\\rho\_x(E)$ 将表达式E的结果命名为x；$\\rho\_{x(A\_1, \\ldots, A\_n)}(E)$ 在命名的同时重命名属性。
    *   **设计哲学：解决歧义与提高可读性。** 这是关系代数中的一个实用性操作。在进行自连接（一个表与自身连接）或处理有同名属性的笛卡尔积时，重命名是必不可少的。

#### **3.2 附加运算 (Additional Operations)**

这些运算虽然可以用基本运算组合表达，但因为使用频率极高，被定义为独立的操作符。这不仅方便了用户，更重要的是，它为查询优化器提供了重要的**意图信息**。

1.  **交 (Intersection) - $\\cap$**
    
    *   **作用：** 取两个关系的共同元组。
    *   **语法：** $r \\cap s$
    *   **等价表达：** $r - (r - s)$ 或 $s - (s - r)$。
    *   **与SQL的联系：** `INTERSECT`。
2.  **连接 (Join)**
    
    *   **设计哲学：为何需要专门的Join？** 虽然 `Join` 可以用 `笛卡尔积 + 选择` 模拟，但 `Join` 明确地告诉了DBMS：“我想要基于特定条件的匹配”。DBMS看到 `Join`，会立即启用高效的连接算法（如Hash Join, Merge Join），而不是真的去计算庞大的笛卡尔积。这是从“数学理论”到“工程实现”的关键一步。
    *   **$\\theta$-连接 (Theta Join):** $r \\bowtie\_\\theta s \\equiv \\sigma\_\\theta(r \\times s)$
        *   最通用的连接，$\\theta$ 可以是任何比较条件（如`>`、`<=`）。
    *   **自然连接 (Natural Join):** $r \\bowtie s$
        *   这是一个非常重要的特例。它的执行步骤是：
            1.  找出 $r$ 和 $s$ 中所有**同名**的属性。
            2.  计算 $r \\times s$。
            3.  选择那些在所有同名属性上**值相等**的元组。
            4.  对结果进行投影，**去掉重复**的同名属性列。
        *   **优点：** 简洁。
        *   **缺点与风险：** 它是一种“隐式”连接，连接条件由列名决定。如果表结构意外改变（例如，有人给两个本不相关的表添加了同名列），查询结果可能会在不被察觉的情况下出错。因此，在现代SQL中，更推荐使用`ON`子句显式指定连接条件。
3.  **除 (Division) - $\\div$**
    
    *   **作用：** 处理“所有(for all)”类型的查询。
    *   **场景：** “查询选修了**所有**计算机学院开设课程的学生的学号”。
    *   **直观理解：** $r(R) \\div s(S)$，其中属性集 $S \\subset R$。结果的属性是 $R-S$。一个元组 $t$ 出现在结果中，当且仅当对于 $s$ 中的**每一个**元组 $u$，拼接后的元组 $tu$ 都存在于 $r$ 中。
    *   **等价表达：** $r \\div s = \\Pi\_{R-S}(r) - \\Pi\_{R-S}((\\Pi\_{R-S}(r) \\times s) - r)$
        *   这个复杂的表达恰恰说明了为“除”法定义一个独立操作符的必要性。
4.  **赋值 (Assignment) - $\\leftarrow$**
    
    *   **作用：** 将一个查询的结果保存到一个临时的关系变量中，以便在后续查询中使用。
    *   **与SQL的联系：** `WITH` 子句 (Common Table Expressions, CTE) 或创建临时视图 (View)。
    *   **设计哲学：** 实现了查询的**过程化**，使得可以将一个极其复杂的查询分解为一系列逻辑清晰的步骤，极大地增强了可读性和可维护性。

### **第四部分：聚合与计算**

基本关系代数只能进行数据的筛选和组合。但实际应用中，我们还需要进行统计和计算。

#### **4.1 广义投影 (Generalized Projection)**

允许在投影列表 $\\Pi$ 中使用算术表达式。

*   **语法：** $\\Pi\_{F\_1, F\_2, \\ldots, F\_n}(E)$
*   **示例：** 计算每个员工的年薪。假设`employee`表有`monthly_salary`列。
    *   $\\Pi\_{\\text{name}, \\text{monthly\_salary} \* 12 \\rightarrow \\text{annual\_salary}}(\\text{employee})$
*   **与SQL的联系：** `SELECT` 列表中可以直接进行计算，如 `SELECT name, monthly_salary * 12 AS annual_salary FROM employee`。

#### **4.2 聚合函数与分组 (Aggregation & Grouping)**

*   **聚合函数：** 将一组值作为输入，返回一个单一值。常见的有：
    *   `AVG` (平均值), `MIN` (最小值), `MAX` (最大值), `SUM` (求和), `COUNT` (计数)。
*   **分组操作符 ($\\mathcal{G}$):**
    *   **语法：** $_{G\_1, G\_2, \\ldots, G\_n} \\mathcal{G}_{F\_1(A\_1), F\_2(A\_2), \\ldots, F\_m(A\_m)}(E)$
        *   $G\_1, \\ldots, G\_n$ 是分组属性。
        *   $F\_i(A\_i)$ 是聚合函数及其作用的属性。
    *   **与SQL的联系：**
        *   分组属性列表对应 `GROUP BY` 子句。
        *   聚合函数列表对应 `SELECT` 子句中的聚合表达式。
    *   **示例：** 查询每个专业的学生人数和平均年龄。
        *   $_{\\text{专业}} \\mathcal{G}_{\\text{COUNT(学号)}, \\text{AVG(年龄)}}(\\text{学生})$

### **第五部分：数据库的修改**

关系代数不仅可以查询，也可以用来精确地描述数据库的修改操作。所有修改都可以看作是对关系变量的重新赋值。

1.  **删除 (Deletion):**
    
    *   **逻辑：** 从关系中减去满足特定条件的元组集合。
    *   **代数表示：** $r \\leftarrow r - E$，其中 $E$ 是一个关系代数表达式，其结果是要删除的元组集合。
    *   **示例：** 删除所有计算机专业的学生。
        *   `学生` $\\leftarrow$ `学生` - $\\sigma\_{\\text{专业}='计算机'}(\\text{学生})$
    *   **与SQL的联系：** `DELETE FROM 学生 WHERE 专业 = '计算机'`
2.  **插入 (Insertion):**
    
    *   **逻辑：** 向关系中并入一个新的元组集合。
    *   **代数表示：** $r \\leftarrow r \\cup E$，其中 $E$ 的结果是要插入的元组集合。
    *   **示例：** 插入一个新学生。
        *   `学生` $\\leftarrow$ `学生` $\\cup {('2025001', '陈明', '物理')}$
    *   **与SQL的联系：** `INSERT INTO ...`
3.  **更新 (Update):**
    
    *   **逻辑：** 这是最复杂的。更新可以看作是“有条件地用新值替换旧值”。在关系代数中，通常用**广义投影**来模拟。
    *   **代数表示：** $r \\leftarrow \\Pi\_{F\_1, F\_2, \\ldots, F\_n}(r)$
        *   对于不需要更新的属性 $A\_i$, $F\_i$ 就是 $A\_i$ 本身。
        *   对于需要更新的属性 $A\_j$, $F\_j$ 就是一个计算新值的表达式，该表达式可以使用 `CASE` 类的条件逻辑。
    *   **示例：** 将所有计算机专业学生的专业改为“人工智能”。
        *   这是一个更复杂的表达，可以想象成：
            1.  选出需要更新的元组：$T\_1 = \\sigma\_{\\text{专业}='计算机'}(\\text{学生})$
            2.  选出不需更新的元组：$T\_2 = \\sigma\_{\\text{专业}<>'计算机'}(\\text{学生})$
            3.  对需要更新的元组计算新值：$T'_1 = \\Pi_{\\text{学号}, \\text{姓名}, '人工智能' \\rightarrow \\text{专业}}(T\_1)$
            4.  合并结果：`学生` $\\leftarrow T\_2 \\cup T'\_1$
    *   **与SQL的联系：** `UPDATE 学生 SET 专业 = '人工智能' WHERE 专业 = '计算机'`。SQL语法在这里显然要简洁得多，但底层逻辑是一致的：定位元组，计算新值，替换旧元组。