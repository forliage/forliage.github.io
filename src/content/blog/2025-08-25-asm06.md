---
title: "x86汇编06:分支与循环"
description: ""
pubDate: "2025-08-25"
heroImage: ""
---

# x86汇编06:分支与循环

### **引言：从顺序执行到智能决策**

冯·诺依曼计算机体系结构的一个基本特征是**顺序执行**：CPU默认情况下会按照指令在内存中的存储顺序，一条接一条地执行。`IP`（指令指针）寄存器就像一个自动递增的计数器。

然而，程序的智能体现在它能够**打破**这种顺序性。**分支**允许程序在多个执行路径中选择一条，而**循环**则允许程序重复执行某段代码。这两种结构，都是通过**有条件或无条件地修改`IP`寄存器**来实现的。其核心工具，就是我们上一讲学过的`CMP`, `TEST`, `Jcc`和`JMP`指令。

### **1 分支结构 (Branching Structures)**

分支的本质是：**比较 -> 设置标志 -> 条件跳转**。

#### **1.1 用`Jcc`指令实现分支**

这是实现分支最直接、最基本的方法。

##### **1.1.1 实现二分支结构 (if-else)**

这是最常见的分支结构。

*   **高级语言伪代码:**
    
    ```
    if (condition) {
                        // if_block
                    } else {
                        // else_block
                    }
                    // after_if
                    
    ```
    
*   **汇编实现思路 (逻辑转换):** 汇编中没有`{}`代码块的概念，只有线性的指令流。我们的目标是根据条件**跳过**不想执行的代码块。
    
    1.  评估 `condition`。
    2.  如果 `condition` **不成立**，则**跳转**到 `else_block`。
    3.  如果 `condition` 成立（即没有发生跳转），则顺序执行 `if_block`。
    4.  在 `if_block` 执行完毕后，必须用一个**无条件跳转** `JMP` **跳过** `else_block`，到达 `after_if`。
*   **例子**: 实现 `if (eax > ebx) { eax = 1; } else { ebx = 1; }`
    
    ```
    ; 1. 评估条件
                    CMP EAX, EBX
                    ; 2. 条件不成立 (eax <= ebx) 则跳转到else部分
                    JLE else_block      ; JLE = Jump if Less or Equal
    
                    ; 3. if_block: eax > ebx 的情况
                    MOV EAX, 1
                    ; 4. 无条件跳过else部分
                    JMP after_if
    
                    else_block:
                    ; else_block: eax <= ebx 的情况
                    MOV EBX, 1
    
                    after_if:
                    ; 继续执行后续代码
                    NOP
                    
    ```
    
*   **设计与CPU架构**: 为什么汇编的逻辑看起来是“反”的（条件不成立才跳）？这是由CPU的分支预测（Branch Prediction）机制决定的。现代CPU为了提高流水线效率，会猜测条件跳转是否会发生。对于`if`语句，通常`if`块被执行的概率更高，因此CPU可能会预测`JLE`**不跳转**，并提前开始执行`if_block`中的指令。如果预测正确，就没有性能损失；如果预测错误，才需要清空流水线，造成一点性能开销。编译器在生成代码时，会根据启发式规则（如将更可能执行的代码块放在不跳转的路径上）来优化性能。
    

##### **1.1.2 实现三分支结构 (if-elseif-else)**

*   **高级语言伪代码:**
    
    ```
    if (condition1) {
                        // block_1
                    } else if (condition2) {
                        // block_2
                    } else {
                        // block_3
                    }
                    // after_if
                    
    ```
    
*   **汇编实现思路**: 这是一个串联的二分支结构。
    
    1.  评估 `condition1`。如果不成立，跳到 `elseif` 部分。
    2.  执行 `block_1`，然后无条件跳到 `after_if`。
    3.  `elseif` 部分：评估 `condition2`。如果不成立，跳到 `else` 部分。
    4.  执行 `block_2`，然后无条件跳到 `after_if`。
    5.  `else` 部分：执行 `block_3`。
    6.  `after_if`。
*   **例子**: 实现 `if (al == 'A') { ... } else if (al == 'B') { ... } else { ... }`
    
    ```
    CMP AL, 'A'
                    JNE elseif_1        ; if (al != 'A') goto elseif_1
    
                    ; --- block_1 ---
                    ; al == 'A' 的代码
                    JMP after_if
    
                    elseif_1:
                    CMP AL, 'B'
                    JNE else_block      ; if (al != 'B') goto else_block
    
                    ; --- block_2 ---
                    ; al == 'B' 的代码
                    JMP after_if
    
                    else_block:
                    ; --- block_3 ---
                    ; 其他情况的代码
    
                    after_if:
                    NOP
                    
    ```
    

##### **1.1.3 实现多分支结构 (switch-case)**

当分支数量很多时，使用一长串的`if-elseif`在性能上是低效的，因为最坏情况下需要进行N次比较。`switch-case`结构在汇编层面通常有两种更高效的实现方式。

#### **1.1.4 用数据指针表实现多分支结构 (Jump Table with Address)**

*   **设计哲学**: **将运行时的条件判断，转化为编译时的地址计算**。这是一种典型的以空间换时间的优化策略。
    
*   **适用场景**: `case` 的值是连续的、从0开始的小整数（如 `case 0, case 1, case 2, ...`）。
    
*   **实现思路**:
    
    1.  创建一个**指针数组（表）**，数组的每个元素是对应`case`代码块的地址。
    2.  在运行时，获取`switch`变量的值（作为索引）。
    3.  进行边界检查，确保索引在合法范围内。
    4.  用索引从表中取出对应的代码地址。
    5.  `JMP`到这个地址。
*   **例子**: 实现 `switch(eax)`，其中 `eax` 的值为 0, 1, 或 2。
    
    ```
    .DATA
                        ; --- 跳转表 (Jump Table) ---
                        jump_table DD case0_handler, case1_handler, case2_handler
    
                    .CODE
                    start:
                        ; 假设 EAX 中是要判断的值 (0, 1, or 2)
                        
                        ; --- 边界检查 ---
                        CMP EAX, 2
                        JA default_case     ; JA = Jump if Above (无符号比较)
                        
                        ; --- 查表并跳转 ---
                        ; EAX * 4 是因为每个地址占4个字节(DD)
                        JMP [jump_table + EAX * 4]
    
                    case0_handler:
                        ; EAX == 0 的代码
                        JMP end_switch
                    case1_handler:
                        ; EAX == 1 的代码
                        JMP end_switch
                    case2_handler:
                        ; EAX == 2 的代码
                        JMP end_switch
                    default_case:
                        ; 默认情况的代码
                    end_switch:
                        NOP
                    
    ```
    
*   **CPU/架构层面**: `JMP [jump_table + EAX * 4]` 这条指令是关键。它使用了x86强大的内存寻址模式（`[base + index * scale]`）。CPU的地址生成单元（AGU）可以在一个时钟周期内完成 `EAX * 4 + jump_table_address` 的计算，然后从计算出的内存地址中加载目标跳转地址，最后更新`IP`。这比多次`CMP`/`Jcc`序列要快得多。
    

#### **1.1.5 用跳转表实现多分支结构 (Jump Table with Code)**

*   **设计哲学**: 这是另一种跳转表，但它不是存储地址，而是直接将跳转指令本身排列在一起。
    
*   **适用场景**: `case`值连续，且每个`case`的代码块都很短，可以直接放在跳转逻辑之后。
    
*   **实现思路**:
    
    1.  将一系列的 `JMP case_handler` 指令紧密排列，形成一个指令表。
    2.  通过计算偏移量，直接跳转到这个表中的某一条`JMP`指令上，由该指令再跳转到真正的处理代码。
*   **例子**: 同上
    
    ```
    .CODE
                    start:
                        ; 假设 EAX 中是要判断的值 (0, 1, or 2)
                        
                        ; --- 边界检查 ---
                        CMP EAX, 2
                        JA default_case
                        
                        ; --- 计算偏移并跳转 ---
                        ; 假设每条JMP指令占2字节 (JMP short)
                        SHL EAX, 1      ; EAX = EAX * 2
                        JMP [jump_table_code + EAX]
    
                    jump_table_code:
                        JMP short case0_handler
                        JMP short case1_handler
                        JMP short case2_handler
                        
                    ; ... case handlers 和 default case 同上 ...
                    
    ```
    

### **2 循环结构 (Looping Structures)**

循环的本质是：**在代码块的末尾，有一个条件或无条件的跳转，跳回到代码块的开头**。

#### **2.1 单重循环**

高级语言中的 `for`, `while`, `do-while` 循环，在汇编层面都可以用 `CMP`/`Jcc`/`JMP` 的组合来实现。

*   **`while` 循环模板:**
    
    ```
    while (condition) {
                        // loop_body
                    }
                    
    ```
    
    **汇编实现:**
    
    ```
    loop_start:
                        ; 1. 评估条件
                        CMP ...
                        ; 2. 条件不成立则跳出循环
                        Jcc loop_end  
    
                        ; --- loop_body ---
                        ...
    
                        ; 3. 无条件跳回循环开始处，进行下一次判断
                        JMP loop_start
                    loop_end:
                        NOP
                    
    ```
    
*   **`do-while` 循环模板:**
    
    ```
    do {
                        // loop_body
                    } while (condition);
                    
    ```
    
    **汇编实现:** (do-while至少执行一次，所以判断在尾部)
    
    ```
    loop_start:
                        ; --- loop_body ---
                        ...
    
                        ; 1. 评估条件
                        CMP ...
                        ; 2. 条件成立则跳回循环开始处
                        Jcc loop_start
                    loop_end:
                        NOP
                    
    ```
    
*   **`for` 循环模板:**
    
    ```
    for (init; condition; update) {
                        // loop_body
                    }
                    
    ```
    
    **汇编实现:** (for循环是while循环的语法糖)
    
    ```
    ; 1. init 部分
                    ...
    
                    loop_start:
                        ; 2. 评估 condition
                        CMP ...
                        Jcc loop_end
    
                        ; --- loop_body ---
                        ...
                        
                        ; 3. update 部分
                        ...
    
                        ; 4. 无条件跳回循环开始处
                        JMP loop_start
                    loop_end:
                        NOP
                    
    ```
    
*   **例子**: 计算1到100的累加和 `sum = 0; for(i=1; i<=100; i++) { sum += i; }`
    
    ```
    XOR EAX, EAX        ; EAX 作为 sum, 初始化为 0
                    MOV ECX, 1          ; ECX 作为 i, 初始化为 1
    
                    loop_start:
                    CMP ECX, 100        ; 比较 i 和 100 (condition)
                    JG loop_end         ; 如果 i > 100, 跳出循环
    
                    ; --- loop_body ---
                    ADD EAX, ECX        ; sum += i
    
                    ; --- update ---
                    INC ECX             ; i++
    
                    JMP loop_start      ; 跳回循环开始
                    loop_end:
                    ; 此时 EAX 中存放着结果 5050
                    NOP
                    
    ```
    

#### **2.2 双重循环 (Nested Loops)**

*   **高级语言伪代码:**
    
    ```
    for (i = 0; i < 10; i++) {
                        for (j = 0; j < 5; j++) {
                            // inner_loop_body
                        }
                    }
                    
    ```
    
*   **汇编实现思路**: 将一个循环结构完整地嵌套在另一个循环的`loop_body`中。关键在于**保存和恢复外层循环的状态**，尤其是计数器。通常使用**堆栈**来完成。
*   **例子**: 打印一个5x10的星号矩阵
    
    ```
    MOV ECX, 10         ; 外层循环计数器 i = 10
    
                    outer_loop:
                    PUSH ECX            ; **关键: 保存外层循环的计数器**
                    MOV ECX, 5          ; 内层循环计数器 j = 5
    
                    inner_loop:
                    ; --- inner_loop_body ---
                    ; (此处调用打印'*'的函数)
                    ...
    
                    LOOP inner_loop     ; 内层循环使用LOOP指令简化
    
                    ; (此处调用打印换行的函数)
                    ...
    
                    POP ECX             ; **关键: 恢复外层循环的计数器**
                    LOOP outer_loop     ; 外层循环
    
                    end_loops:
                    NOP
                    
    ```
    
*   **设计与CPU架构**: 在这个例子中，`PUSH ECX` 和 `POP ECX` 是至关重要的。因为内外层循环都想使用`ECX`作为计数器（`LOOP`指令强制使用`ECX`）。如果不进行保存和恢复，内层循环结束后`ECX`会变为0，外层循环将直接终止。堆栈提供了一种完美、高效的机制来保存和恢复寄存器上下文，这使得实现嵌套结构和递归成为可能。这是CPU堆栈机制在程序结构化中的核心应用。