---
title: "数据库系统设计05:查询处理(下)"
description: ""
pubDate: "2025-08-26"
heroImage: ""
---

# 数据库系统设计05:查询处理(下)

想象一下，你是一位城市的交通总规划师，你的任务是为市民规划从A点到B点的最佳路线。你可以选择步行、骑车、坐公交、乘地铁，还可以组合使用它们。不同的路线有不同的时间成本、金钱成本和换乘复杂度。你的大脑会做什么？你会基于地图、实时路况、票价等信息，快速地在大脑中模拟几条看似合理的路线，然后选择一条综合最优的。

数据库的**查询优化器**，做的就是完全一样的事情。当它收到一条SQL，它看到的不是一条简单的指令，而是一个巨大的“可能路径”的搜索空间。比如一个三张表的连接查询 `R JOIN S JOIN T`，它至少需要考虑：

*   **连接顺序 (Join Order):** 是 `(R JOIN S) JOIN T` 还是 `R JOIN (S JOIN T)`？两种顺序的中间结果集大小可能天差地别，导致后续成本的巨大差异。
*   **连接算法 (Join Algorithm):** 对于每一次连接，是使用哈希连接、排序归并连接还是索引嵌套循环连接？
*   **访问路径 (Access Path):** 对于每个表的访问，是使用全表扫描还是某个可用的索引？

对于一个包含 $N$ 个表的连接查询，可能的连接顺序就有 $(2(N-1))! / (N-1)!$ 种（卡特兰数相关），这是一个随着 $N$ 爆炸性增长的数字。查询优化器的使命，就是**在不花费太多时间的前提下，从这个浩瀚的搜索空间中，找到一个足够好（不一定是绝对最优）的执行计划**。

### **第一部分：逻辑优化与关系代数等价变换**

查询优化的第一步，不是立即去计算成本，而是对输入的查询进行**逻辑上的“整容”**。这个阶段的目标是：**利用关系代数的等价变换规则，将初始的、可能很低效的查询逻辑，转化为一个执行上更优的、但逻辑上完全等价的新形式。**

这个过程也被称为**启发式优化 (Heuristic Optimization)** 或**基于规则的优化 (Rule-Based Optimization, RBO)**。

#### **1.1 查询的内部表示：从SQL到逻辑查询计划**

1.  **解析 (Parsing):** SQL语句被解析成一棵**解析树 (Parse Tree)**，检查语法正确性。
2.  **验证 (Validation):** 检查解析树中的表名、列名是否存在，进行类型检查等。
3.  **转化为逻辑查询计划:** 将解析树转化为一个内部的、与具体算法无关的**逻辑查询计划 (Logical Query Plan)**。这通常是一棵由关系代数算子（$\\sigma$, $\\pi$, $\\bowtie$, $\\times$, ...）组成的树。

**\[示例\]** SQL:

```
SELECT T.name FROM Reserves R, Sailors S, Boats B WHERE R.sid = S.sid AND R.bid = B.bid AND B.color = 'red' AND S.rating > 7;
```

**初始逻辑计划 (可能由解析器直接生成):**

graph TD A\[π T.name\] --> B(σ R.sid=S.sid AND R.bid=B.bid AND B.color='red' AND S.rating>7) B --> C(×) C --> D\[Reserves R\] C --> E\[Sailors S\] C --> F\[Boats B\]

这个计划极其糟糕：它先对三张表做**笛卡尔积**，生成一个无比巨大的中间结果，然后再在这个结果上做选择。我们的目标就是避免这种情况。

#### **1.2 核心优化法则：将选择和投影“下推” (Push Down)**

这是逻辑优化中**最重要、最有效**的法则。其核心思想是：**尽可能早地执行选择 ($\\sigma$) 和投影 ($\\pi$) 操作，以减小后续操作（尤其是昂贵的连接）处理的中间结果集的大小。**

##### **法则1：选择下推 (Pushing Selections)**

*   $\\sigma\_{P1 \\land P2}(R) \\equiv \\sigma\_{P1}(\\sigma\_{P2}(R))$ (分解选择条件)
*   $\\sigma\_P(R \\times S) \\equiv \\sigma\_P(R) \\times S$ (如果P只涉及R的属性)
*   $\\sigma\_P(R \\bowtie S) \\equiv \\sigma\_P(R) \\bowtie S$ (如果P只涉及R的属性)
*   $\\sigma\_{P\_R \\land P\_S}(R \\bowtie S) \\equiv \\sigma\_{P\_R}(R) \\bowtie \\sigma\_{P\_S}(S)$ (最重要的规则)

**\[应用示例\]** 对上面的初始计划应用选择下推：

1.  将四个`AND`条件分解。
2.  将 `B.color = 'red'` 下推到 `Boats` 表之上。
3.  将 `S.rating > 7` 下推到 `Sailors` 表之上。
4.  连接条件 `R.sid = S.sid` 和 `R.bid = B.bid` 不能再下推，它们定义了连接本身。

**优化后的逻辑计划:**

graph TD A\[π S.name\] --> B(⋈ R.bid=B.bid) B --> C(⋈ R.sid=S.sid) C --> D\[Reserves R\] C --> E\[σ S.rating > 7\] E --> F\[Sailors S\] B --> G\[σ B.color = 'red'\] G --> H\[Boats B\]

这个计划的效率天差地别：它先对`Boats`和`Sailors`进行过滤，用**小得多的结果集**去和`Reserves`表进行连接。

##### **法则2：投影下推 (Pushing Projections)**

*   **核心思想:** 尽早地丢弃掉那些在后续计算和最终结果中都用不到的列。
*   $\\pi\_A(R \\bowtie S) \\equiv \\pi\_A(\\pi\_{A \\cup J}(R) \\bowtie \\pi\_{B \\cup J}(S))$ (其中J是连接属性，A和B是R和S中最终需要的属性)

**\[应用示例\]** 在上一个优化计划的基础上，我们发现最终只需要`S.name`。

*   对于`Sailors`表，在`σ`之后，我们只需要保留`sid`（用于连接）和`name`（最终输出）。
*   对于`Boats`表，在`σ`之后，我们只需要保留`bid`（用于连接）。
*   对于`Reserves`表，我们只需要`sid`和`bid`（用于连接）。

**最终的逻辑计划:**

graph TD subgraph "最终逻辑查询计划 (左深树结构)" A\[π S.name\] --> B\[⋈ R.bid = B.bid\] B --> C\[⋈ R.sid = S.sid\] C --> D\["π sid, bid  
(Reserves R)"\] C --> E\["π sid, name  
(σ S.rating > 7  
(Sailors S))"\] B --> F\["π bid  
(σ B.color = 'red'  
(Boats B))"\] end

#### **1.3 其他重要的等价变换规则**

*   **连接的交换律与结合律:**
    *   $R \\bowtie S \\equiv S \\bowtie R$
    *   $(R \\bowtie S) \\bowtie T \\equiv R \\bowtie (S \\bowtie T)$
    *   **重要性:** 这两条规则是**连接顺序优化 (Join Order Optimization)** 的理论基础。优化器可以自由地探索不同的连接树形状。
*   **将笛卡尔积与选择合并为连接:**
    *   $\\sigma\_{R.a=S.b}(R \\times S) \\equiv R \\bowtie\_{R.a=S.b} S$
    *   这是最开始那个糟糕计划的核心优化点。优化器会自动识别出这种模式，并将其转化为更高效的连接操作。

### **第二部分：物理优化与基于成本的选择**

逻辑优化给我们提供了一个或多个结构上更优的逻辑计划。现在，进入**物理优化 (Physical Optimization)** 阶段，也称为**基于成本的优化 (Cost-Based Optimization, CBO)**。

这个阶段的目标是：**为逻辑计划中的每一个算子，选择一个具体的物理实现算法，并确定最佳的连接顺序，使得总成本最小。**

#### **2.1 成本估算的核心：选择率与结果基数**

为了估算一个操作的成本，我们必须先估算它**输出结果的大小 (Cardinality Estimation)**。

*   **选择操作的基数估算 ($\\sigma\_{attr=value}(R)$):**
    *   **假设:** 值在属性域内均匀分布。
    *   **估算公式:** $T(\\sigma\_{attr=value}(R)) = T(R) / V(attr, R)$
        *   $T(R)$: 关系R的总元组数。
        *   $V(attr, R)$: 属性`attr`的不同值的个数（基数）。
    *   **选择率 (Selectivity Factor, SF):** $1 / V(attr, R)$。
*   **范围选择的基数估算 ($\\sigma\_{attr > value}(R)$):**
    *   **均匀分布假设:** $T(\\sigma\_{attr > value}(R)) = T(R) \\times (\\text{MaxValue} - value) / (\\text{MaxValue} - \\text{MinValue})$。
    *   **直方图 (Histograms):** 现实世界数据分布极不均匀。现代优化器使用直方图来更精确地描述数据分布。
        *   **等宽直方图 (Equi-width):** 将值域划分为等宽的桶，记录每个桶内的元组数。
        *   **等高直方图 (Equi-depth):** 将值域划分为桶，使得每个桶内的元组数大致相等。等高直方图能更好地处理数据倾斜。
*   **连接操作的基数估算 ($R \\bowtie\_{R.a=S.b} S$):**
    *   **简化假设:**
        *   $a$ 是 $R$ 的外键，引用 $S$ 的主键 $b$：结果大小为 $T(R)$。
        *   $b$ 是 $S$ 的外键，引用 $R$ 的主键 $a$：结果大小为 $T(S)$。
    *   **通用公式 (基于值域重叠):**
        *   $T(R \\bowtie S) = T(R) \\times T(S) / \\max(V(a,R), V(b,S))$

#### **2.2 搜索最佳计划：动态规划的智慧**

面对连接顺序的组合爆炸问题，穷举搜索是不可行的。现代优化器（如System R风格的优化器）通常采用**动态规划 (Dynamic Programming)** 算法。

**算法思想（以自底向上为例）：**

1.  **Pass 1 (单个关系的最佳访问路径):**
    
    *   对于每个单表 `R`，找出访问它的最佳计划。
    *   例如，对于 $\\sigma\_{P}(R)$，计算：
        *   成本(全表扫描)
        *   成本(使用`P`上的索引A)
        *   成本(使用`P`上的索引B)
        *   ...
    *   选择成本最低的那个，记录下来（例如 `BestPlan({R})`）。
2.  **Pass 2 (两个关系的连接):**
    
    *   对于所有可能的两表连接组合（如 `{R, S}`），找出连接它们的最佳计划。
    *   要计算 `BestPlan({R, S})`，考虑两种可能：
        *   **路径1:** `BestPlan({R}) JOIN S`
            *   对这个连接，再评估所有可能的连接算法（Hash Join, Merge Join, Index Join...）和访问S的路径（Scan, Index...），取成本最低者。
        *   **路径2:** `BestPlan({S}) JOIN R`
            *   同理，评估所有可能。
    *   比较路径1和路径2的总成本，选择更优的，记录为 `BestPlan({R, S})`。
    *   **剪枝 (Pruning):** 在这个过程中，优化器会利用一个重要的\*\*“有趣顺序” (Interesting Order)\*\* 概念。如果一个计划的输出结果是排好序的，而这个顺序可能对后续的`JOIN`（如Sort-Merge Join）或`ORDER BY`有利，那么即使这个计划的成本稍高，它也可能被保留下来作为候选。
3.  **Pass $k$ ($k$个关系的连接):**
    
    *   对于所有大小为 $k$ 的关系子集 `{R1, ..., Rk}`，找出连接它们的最佳计划。
    *   要计算 `BestPlan({R1, ..., Rk})`，可以将其分解为连接一个大小为 $k-1$ 的子集和一个单表。例如：
        *   `BestPlan({R1, ..., Rk-1}) JOIN Rk`
    *   遍历所有可能的分解方式，计算每种方式的最低成本，最终找到 `BestPlan({R1, ..., Rk})`。
4.  **最终结果:** `BestPlan({R1, ..., RN})` 就是我们想要的最终执行计划。
    

**\[拓展\] 左深树 vs. 浓密树 (Left-Deep vs. Bushy Trees):**

*   **左深连接树:** `((R1 JOIN R2) JOIN R3) JOIN R4`。所有连接的内层关系都是一个单表。
    *   **优点:** 搜索空间大大减小，易于优化，并且中间结果可以很好地被**流水线化 (Pipelining)** 执行。
    *   **缺点:** 可能错过某些更优的浓密树计划。
*   **浓密连接树:** `(R1 JOIN R2) JOIN (R3 JOIN R4)`。
    *   **优点:** 搜索空间更大，可能找到绝对最优解。
    *   **缺点:** 优化过程更复杂，中间结果 `(R3 JOIN R4)` 可能需要**物化 (Materialize)** 到磁盘，打断流水线。

大多数优化器（如PostgreSQL）默认只搜索左深树，但提供选项来探索更复杂的浓密树。

### **第三部分： 从生成到执行**

#### **3.1 执行计划的真面目**

优化器最终输出的物理执行计划，是一棵由**物理算子 (Physical Operators)** 组成的树。每个算子都实现了`open()`, `next()`, `close()`这三个接口（**迭代器模型 / Volcano模型**）。

*   `open()`: 初始化算子，分配内存，打开子算子的迭代器。
*   `next()`: 从子算子获取一个或多个元组，进行处理，然后返回一个结果元组。如果处理完毕，返回`NULL`。
*   `close()`: 清理资源。

**\[示例物理计划\]**

graph TD subgraph "物理执行计划 (迭代器模型)" direction TB Root\[Client\] -- next() --> HJ1\[Hash Join  
on R.bid = B.bid\] subgraph "探测端 (Probe Input)" HJ1 -- next() --> HJ2\[Hash Join  
on R.sid = S.sid\] subgraph "探测端 (Probe Input)" HJ2 -- next() --> FSCAN\_R\[Table Scan  
Reserves R\] end subgraph "构建端 (Build Input)" HJ2 -- next() --> IXSCAN\_S\[Index Scan  
Sailors S  
where rating > 7\] end end subgraph "构建端 (Build Input)" HJ1 -- next() --> IXSCAN\_B\[Index Scan  
Boats B  
where color = 'red'\] end end

*   **执行流程:** 根节点调用`next()`，这个调用会级联地向下传递，直到叶子节点（扫描算子）。叶子节点从磁盘读取元组返回，上层算子处理后，再向上返回，数据就像被“拉” (Pull) 上来一样。

#### **3.2 流水线 vs. 物化 (Pipelining vs. Materialization)**

*   **流水线执行 (Pipelining):**
    *   一个算子的输出，**直接作为**另一个算子的输入，中间结果不写入磁盘。
    *   例如，`σ(R)`的结果可以直接流入`JOIN`算子。
    *   **优点:** 极大地节省I/O，降低延迟。
*   **物化执行 (Materialization):**
    *   一个算子的全部输出结果，先**完整地写入**一个临时文件，然后再由下一个算子读取。
    *   **何时需要物化？**
        *   **阻塞算子 (Blocking Operators):** 像`SORT`这样的算子，必须看到所有输入后才能产生第一个输出。
        *   **浓密树的右子树:** `(R1 JOIN R2)`的结果可以流水线给下一个JOIN，但`(R3 JOIN R4)`必须先计算完毕并物化。
        *   **内存不足:** 哈希连接的构建阶段，如果哈希表太大，就需要将分区物化到磁盘。

#### **3.3 现代优化器的演进**

*   **随机化算法 (Randomized Algorithms):** 当连接表数量非常多时（>15-20），动态规划的开销也无法承受。优化器会退化为随机化算法，如**模拟退火 (Simulated Annealing)** 或**遗传算法 (Genetic Algorithms)**，来在巨大的搜索空间中进行随机“跳跃”，以期找到一个足够好的局部最优解。
*   **自适应查询处理 (Adaptive Query Processing):** 传统的优化器在查询开始前就制定了一个**静态的、固定不变**的计划。但它的基数估算可能出错。自适应查询处理允许执行引擎在**运行时**监测实际的中间结果大小，如果发现与估算偏差巨大，可以动态地**修改或重新优化**后续的执行计划。