---
title: "计算机网络05：传输层"
description: ""
pubDate: "2026-01-01"
heroImage: ""
---

# 计算机网络05：传输层

## 本节重点

1.  传输层提供的服务
2.  UDP
3.  TCP

## 1\. 传输层的服务

​ 传输层位于应用层和网络层之间，基于网络层提供的服务，向分布式应用程序提供通信服务。

### 1.1 进程之间的通信

​ 每个进程需要一个标识，以便其它进程能够找到它。进程标识包括：

*   主机地址
*   主机上与该进程关联的端口号（端口号被用来区分同一个主机上的不同进程）

### 1.2 套接字编程

​ **套接字（socket）**：应用层和传输层的接口，也是应用程序和网络之间的API。

![](//images//ComputerNetwork//socket.png)

​ 套接字编程（Socket Programming）是网络应用程序之间进行通信的基础方式，它为应用进程提供了一个在网络中收发数据的接口。套接字相当于通信端点，客户端和服务器分别创建套接字，通过 IP 地址 + 端口号建立连接并传输数据。

​ 常见流程是：

*   服务器创建套接字、绑定端口、监听连接
*   客户端创建套接字并发起连接
*   连接建立后双方读写数据，最后关闭套接字

​ Socket 编程支持 TCP（面向连接、可靠传输）和 UDP（无连接、简单快速）两种方式，是网络应用开发的核心机制。

### 1.3 复用和分用

*   复用（发送方）：传输层从多个套接字收集数据，交给网络层发送
*   分用（接收方）：传输层将从网络层收到的数据，交付给正确的套接字

## 2\. UDP

​ UDP是一种**无连接传输**服务，它仅在IP层的数据报服务之上增加了复用、分用和差错检测的功能。UDP无建立连接的延迟且不限制发送速率（不进行拥塞控制和流量控制）。

​ UDP主要提供下面两种服务：

*   进程到进程之间的报文交付
*   报文完整性检查（可选）：检测并丢弃出错的报文

### 2.1 UDP的报文段

​ UDP报文由**报头**和**载荷（payload）**组成：报头携带协议处理必需的信息，载荷承载上层数据。用于复用与分用**的字段包括源端口号和目的端口号；用于**差错检测的字段包括报文总长度和校验和，以发现传输中的错误。

​ UDP报文：

*   报头：携带协议处理需要的信息
*   载荷（payload）：携带上层数据

​ 用于复用和分用的字段：

*   源端口号
*   目的端口号

​ 用于检测报文错误的字段：

*   报文总长度
*   校验和（checksum）

![](//images//ComputerNetwork//UDP报文格式.png)

### 2.2 校验和（checksum）

​ UDP校验和用于检测数据在传输过程中是否发生错误，是一种**差错检测机制**。计算时，UDP会将**伪首部、UDP报头和数据部分**一起参与校验，通过对这些内容按16位求和取反得到校验值。最后，接收方对UDP报文（包括校验和）及伪头求和，若结果为**0xFFFF**，则认为没有错误。

![](//images//ComputerNetwork//checksum.png)

## 3\. TCP

​ TCP是在不可靠的IP层之上实现的可靠数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。它的主要特点如下：

*   **面向连接**：通信前需通过三次握手建立连接，结束时四次挥手释放连接。
*   **可靠传输**：依靠确认应答、超时重传、序号与确认号机制确保数据不丢失、不重复、顺序到达。
*   **有序传输**：按序号排列数据，保证接收端按发送顺序重组数据。
*   **流量控制**：通过滑动窗口调节发送速率，防止接收端处理不过来。
*   **拥塞控制**：拥塞避免、慢开始、拥塞避免、快速重传/恢复等机制减缓网络拥塞。
*   **面向字节流**：数据以字节流方式传输，不保留报文边界。

### 3.1 TCP的报文段

![](//images//ComputerNetwork//TCP报文段.png)

*   源端口号、目的端口号：标识了连接的本地端点，用于复用与分用
*   序号、确认号：保证数据可靠、有序传输
*   标志位（SYN/ACK/FIN等）：用于连接建立、维护与释放
*   窗口大小：实现流量控制
*   校验和：进行差错检测
*   选项字段：扩展协议能力

### 3.2 可靠传输

​ TCP在不可靠的IP之上实现可靠传输。发送端采用流水线发送、等待确认并在超时后重传；接收端进行差错检测并使用累积确认。对于乱序报文，协议未强制规定处理方式：不缓存时实现简单但效率低，缓存乱序段效率更高但处理更复杂。

#### 3.2.1 发送端

​ 发送方收到应用数据后创建并发送TCP报文段，若无定时器运行则启动定时器；超时则重传未确认中序号最小的报文段并重启定时器。收到ACK且确认序号大于基序号时，推进发送窗口并更新基序号；若仍有未确认报文则继续定时器，否则停止定时器。

![](//images//ComputerNetwork//TCP发送端.png)

#### 3.2.2 TCP的接收端

​ 接收端理论上只需区分两种情况：收到期望的报文段则发送更新后的确认序号，其余情况发送重复确认。为减少开销，TCP允许推迟确认，即接收端在收到多个报文段后再发送一次累积确认，以降低通信量。

#### 3.2.3 超时重传

​ TCP可能出现下面几种重传情况：

![](//images//ComputerNetwork//TCP重传.png)

​ TCP的差错恢复机制可视为GBN和SR的混合体：在定时器方面类似GBN，只为最早未确认的报文段设置一个定时器；在超时重传方面又类似SR，只重传丢失的数据段而非全部未确认内容，从而兼顾效率与可靠性。

​ TCP确认存在二义性：重传报文段与原报文使用相同序号，发送端收到ACK后无法判断确认的是原始段还是重传段，导致测量的SampleRTT可能不准确。为解决此问题，TCP只对一次发送成功的报文段测量SampleRTT并更新EstimatedRTT（SRTT）；发生重传时停止RTT测量，从而避免二义性影响。

> $SRTT=\\alpha \\times SRTT+(1-\\alpha)\\times SRTT,\\alpha=\\frac{7}{8}$

​ Karn算法解决重传导致的超时设置偏小问题：重传时不更新RTT估计，而是将超时值加倍（连续重传则指数增加）；只有未重传就被确认的报文段才用于更新EstimatedRTT。这样通过“忽略重传RTT + 定时器补偿”来避免确认二义性并合理调整超时。

#### 3.2.4 快速重传

​ 仅靠超时重发丢失的报文段，恢复太慢，因此研究者提出了快速重传机制。所谓快速重传，就是在**定时器到期前重发丢失的报文段**。如果收到**3**次重复确认，重发报文段。

![](//images//ComputerNetwork//快速重传.png)

### 3.3 流量控制

​ TCP接收端通过**显式窗口通告**告诉发送方可用缓存空间，在窗口较小时可推迟确认，仅在窗口明显增大时才更新通告；发送端使用**Nagle算法**控制发送时机，并以接收端窗口为上限，保证未确认数据量不超过对方可用空间，从而避免缓存溢出并协调传输速率。

#### 3.3.1 显式窗口通告

​ TCP接收端通过在报文的“窗口大小”字段中明确告知发送端当前可用的缓存空间大小。发送端根据这个窗口值控制发送量，保证“已发送但未确认的数据”不会超过接收端的承载能力，从而防止接收缓存溢出。

![](//images//ComputerNetwork//显式窗口通告.png)

#### 3.3.2 **Nagle算法**

​ Nagle算法用于减少小数据包频繁发送造成的网络开销。规则是：当发送端还有未确认的数据时，暂缓发送新的小包，等待前一个包被确认或积累到足够大的数据再一次性发送，从而降低网络负载、提高传输效率。适用于存在大量细碎小数据的应用场景（如交互式程序）。

### 3.4 连接管理

​ 建立一条TCP连接需要确定两件事：

*   双方都同意建立连接（知晓另一方想建立连接）
*   初始化连接参数（序号，MSS等）

#### 3.4.1 三次握手

​ TCP使用“三次握手”在通信双方之间可靠地建立连接，确保双方的发送与接收能力都已正常就绪，过程如下：

1.  **客户端 → 服务器（SYN）**：客户端发送带有 **SYN 标志位**的报文段，请求建立连接，进入 _SYN-SENT_ 状态。
2.  **服务器 → 客户端（SYN+ACK）**：服务器收到请求后应答一个同时带 **SYN 和 ACK** 的报文段，表示同意建立连接并确认客户端的请求，进入 _SYN-RECEIVED_ 状态。
3.  **客户端 → 服务器（ACK）**：客户端收到确认后，再发送一个 **ACK 报文段**作为回应，双方进入 _ESTABLISHED_ 状态，连接正式建立。

![](//images//ComputerNetwork//三次握手.png)

#### 3.4.2 四次挥手

TCP使用“四次挥手”断开连接，确保双方数据都已发送完毕并安全关闭，过程如下：

1.  **主动方 → 被动方（FIN）**：主动关闭的一方发送 FIN，表示不再发送数据，进入 _FIN-WAIT-1_ 状态。
2.  **被动方 → 主动方（ACK）**：被动方确认收到 FIN，回复 ACK，进入 _CLOSE-WAIT_；此时仍可继续向主动方发送数据。
3.  **被动方 → 主动方（FIN）**：被动方发送自己的 FIN，表示数据发送完毕并准备关闭，进入 _LAST-ACK_。
4.  **主动方 → 被动方（ACK）**：主动方回 ACK，确认后进入 _TIME-WAIT_ 等待一段时间防止报文丢失，然后最终关闭连接。

![](//images//ComputerNetwork//四次挥手.png)

#### 3.4.3 客户/服务器经历的TCP状态序列

![](//images//ComputerNetwork//TCP状态序列.png)

### 3.5 拥塞控制

​ TCP使用**端到端**拥塞控制机制，即发送方根据自己感知的网络拥塞程度，限制其发送速率。

​ 发送方通过**丢包事件**来感知网络拥塞：当网络拥塞导致分组丢失或延迟过大时，发送端会触发重传定时器超时或收到三个重复ACK，这两种情况都被视为丢包，从而判断出现拥塞。为限制发送速率，发送方使用**拥塞窗口cwnd**控制已发送但未确认的数据量（满足 LastByteSent − LastByteAcked ≤ cwnd），并根据拥塞状况动态调整 cwnd 大小。

#### 3.5.1 AIMD

​ AIMD（加性增大、乘性减小）是TCP拥塞控制的核心策略：在网络无拥塞时，发送方每个往返时间对拥塞窗口 **加性增加**（逐步线性增大发送速率）；一旦出现丢包等拥塞信号，则对拥塞窗口 **乘性减小**（通常减半），快速降低发送速率。AIMD在提高吞吐量和避免拥塞之间取得平衡，实现稳定且公平的网络资源共享。

![](//images//ComputerNetwork//AIMD.png)

#### 3.5.2 慢启动

​ **TCP慢启动（Slow Start）**是拥塞控制初始阶段的机制，用于在连接开始或超时重传后逐步提升发送速率，避免一开始就向网络注入过多数据造成拥塞。慢启动从较小的拥塞窗口（cwnd，通常为1个MSS）起步，每收到一个ACK就增加1个MSS，使得每个RTT内 cwnd 近似**指数增长**（1、2、4、8、16 …）。当 cwnd 增长到阈值 ssthresh 时，算法切换到拥塞避免阶段，以更平缓的方式继续增长，从而在效率与安全之间取得平衡。

![](//images//ComputerNetwork//TCP慢启动.png)

​ 发送方维护ssthresh，其一般设置为$\\frac{cwnd}{2}$。