---
title: "图像信息处理1:二值图像与形态学操作"
description: ""
pubDate: "2025-08-23"
heroImage: ""
---

# 图像信息处理1:二值图像与形态学操作

### **1\. 二值图像 (Binary Image)**

#### **1.1 定义与表示**

在数字图像处理中，**二值图像（Binary Image）** 是一种最简单的图像形式。其特殊之处在于，图像中的每个像素点只有两种可能的取值，通常是 `0` 和 `1`，分别代表**背景（Background）**和**前景（Foreground）**。

*   **理论表示**：在理论层面，像素值被限制为 ${0, 1}$。这使得每个像素仅需 1 比特（bit）即可存储，是最高效的图像存储方式。
*   **编程实践**：在实际编程中，为了便于显示和兼容常见的图像库（如OpenCV），我们通常使用8位无符号整数（`unsigned char`）来存储二值图像。此时，我们会用 `0` 代表黑色（背景），用 `255`（即 $2^8-1$）代表白色（前景）。这种约定俗成的表示法并不改变其二值属性的本质。

#### **1.2 优点与局限性**

**优点 (Advantages):**

*   **内存占用极低 (Less memory):** 每个像素理论上仅需1 bit，存储开销远小于灰度图像（8 bits）或彩色图像（24 bits）。
*   **计算效率高 (More efficient):** 针对二值图像的算法通常只涉及逻辑运算（与、或、非）和简单的整数运算，处理速度极快。
*   **对象特征突出:** 二值化过程将图像中的目标与背景清晰分离，简化了后续的特征提取、对象识别和形态分析任务。
*   **计算成本低廉 (More cheap):** 由于算法简单，对硬件要求较低。

**局限性 (Disadvantages):**

*   **信息损失严重 (Less expressive force):** 二值化是一个有损过程，完全舍弃了原始图像的灰度或色彩层次信息，无法传达视觉细节（FAIL to convey visual details）。
*   **应用领域受限 (Application field is limited):** 主要适用于目标与背景对比度高、需要进行形状分析的场景。对于需要纹理、颜色分析的任务则不适用。
*   **无法直接应用于三维数据 (CANNOT be applied on 3-D data):** 虽然形态学思想可以推广到三维，但二值图像本身是二维概念。
*   **对比度不可控 (CANNOT control the contrast):** 图像的对比度信息在二值化过程中完全丢失。

### **2\. 图像二值化 (Image Binarization)**

图像二值化是将灰度图像转换为二值图像的过程。其核心是选取一个合适的**阈值（Threshold）** `T`，然后根据像素的灰度值与 `T` 的关系来决定其输出值。

#### **2.1 基本概念：全局阈值分割**

对于一幅灰度图像 $I(x, y)$，其二值化后的图像 $I\_{bw}(x, y)$ 可以通过以下方式获得：

$$ I\_{bw}(x, y) = \\begin{cases} 255 & \\text{if } I(x, y) \\ge T \\\\ 0 & \\text{if } I(x, y) < T \\end{cases} $$

这里的关键问题是：**如何自动地找到一个“好”的阈值？** 一个好的阈值应该能最大程度地将前景和背景区分开。Otsu算法（大津法）是解决这一问题的最经典和最有效的方法之一。

#### **2.2 全局阈值法：Otsu算法 (大津法)**

Otsu算法的核心思想是：寻找一个阈值 `T`，使得被这个阈值分开的前景和背景两组像素的**类间方差（Between-class variance）** 最大。类间方差越大，说明前景和背景的灰度分布差异越明显，分割效果就越好。

**数学推导 (Mathematical Proof):**

假设图像共有 $N$ 个像素，灰度级为 $\[0, L-1\]$（通常是 $\[0, 255\]$）。设 $n\_i$ 为灰度级为 $i$ 的像素数量，则 $N = \\sum\\limits\_{i=0}^{L-1} n\_i$。灰度级 $i$ 出现的概率为 $p\_i = \\frac{n\_i}{N}$。

1.  **类概率和类均值:** 当阈值为 $T$ 时，图像被分为两类：
    
    *   **背景类 $C\_0$**: 灰度级在 $\[0, T\]$ 范围内的像素。
    *   **前景类 $C\_1$**: 灰度级在 $\[T+1, L-1\]$ 范围内的像素。
    
    背景类的概率（像素占比） $\\omega\_0(T) = \\sum\\limits\_{i=0}^{T} p\_i$ 前景类的概率（像素占比） $\\omega\_1(T) = \\sum\\limits\_{i=T+1}^{L-1} p\_i = 1 - \\omega\_0(T)$
    
    背景类的平均灰度 $\\mu\_0(T) = \\frac{\\sum\\limits\_{i=0}^{T} i \\cdot p\_i}{\\omega\_0(T)}$ 前景类的平均灰度 $\\mu\_1(T) = \\frac{\\sum\\limits\_{i=T+1}^{L-1} i \\cdot p\_i}{\\omega\_1(T)}$
    
2.  **方差定义:** 图像的总平均灰度 $\\mu\_{total} = \\sum\\limits\_{i=0}^{L-1} i \\cdot p\_i = \\omega\_0(T)\\mu\_0(T) + \\omega\_1(T)\\mu\_1(T)$。 图像的总方差 $\\sigma^2\_{total} = \\sum\\limits\_{i=0}^{L-1} (i - \\mu\_{total})^2 p\_i$。
    
    **类内方差 (Within-class variance)** $\\sigma^2\_{within}(T)$ 是两个类方差的加权和，表示每个类内部的灰度离散程度： $$\\sigma^2\_0(T) = \\frac{\\sum\\limits\_{i=0}^{T} (i - \\mu\_0(T))^2 p\_i}{\\omega\_0(T)}$$ $$\\sigma^2\_1(T) = \\frac{\\sum\\limits\_{i=T+1}^{L-1} (i - \\mu\_1(T))^2 p\_i}{\\omega\_1(T)}$$ $$\\sigma^2\_{within}(T) = \\omega\_0(T)\\sigma^2\_0(T) + \\omega\_1(T)\\sigma^2\_1(T)$$
    
    **类间方差 (Between-class variance)** $\\sigma^2\_{between}(T)$ 表示两个类均值之间的差异程度： $$\\sigma^2\_{between}(T) = \\omega\_0(T)(\\mu\_0(T) - \\mu\_{total})^2 + \\omega\_1(T)(\\mu\_1(T) - \\mu\_{total})^2$$ 将 $\\mu\_{total}$ 代入，可以推导出更简洁的形式： $$\\sigma^2\_{between}(T) = \\omega\_0(T)\\omega\_1(T)(\\mu\_0(T) - \\mu\_1(T))^2$$
    
3.  **方差关系与优化目标:** 可以证明，总方差是类内方差与类间方差之和：$\\sigma^2\_{total} = \\sigma^2\_{within}(T) + \\sigma^2\_{between}(T)$。 由于总方差 $\\sigma^2\_{total}$ 是一个与阈值 $T$ 无关的定值，因此**最大化类间方差**等价于**最小化类内方差**。
    
    Otsu算法的目标就是找到使 $\\sigma^2\_{between}(T)$ 最大的阈值 $T^_$： $$ T^_ = \\arg\\max\_{0 \\le T < L} \\left{ \\sigma^2\_{between}(T) \\right} = \\arg\\max\_{0 \\le T < L} \\left{ \\omega\_0(T)\\omega\_1(T)(\\mu\_0(T) - \\mu\_1(T))^2 \\right} $$
    

**算法步骤:**

1.  计算图像的灰度直方图，得到每个灰度级的像素数 $n\_i$。
2.  将 $n\_i$ 归一化，得到概率 $p\_i = n\_i / N$。
3.  遍历所有可能的阈值 $T$ 从 $0$ 到 $L-1$（通常是255）。
4.  对于每个 $T$，使用高效的递推方式计算 $\\omega\_0(T)$, $\\omega\_1(T)$, $\\mu\_0(T)$, $\\mu\_1(T)$。
5.  计算类间方差 $\\sigma^2\_{between}(T)$。
6.  记录下使 $\\sigma^2\_{between}(T)$ 最大的 $T$ 值，即为最佳阈值 $T^\*$。

**C++ 代码示例 (使用OpenCV):**

```
#include <opencv2/opencv.hpp>
                #include <iostream>

                // 手动实现Otsu算法
                int otsuThreshold(const cv::Mat& gray_image) {
                    if (gray_image.channels() != 1) {
                        std::cerr << "Error: Input image must be grayscale." << std::endl;
                        return -1;
                    }

                    // 1. 计算灰度直方图
                    const int gray_levels = 256;
                    int histogram[gray_levels] = {0};
                    int total_pixels = gray_image.rows * gray_image.cols;

                    for (int y = 0; y < gray_image.rows; ++y) {
                        const uchar* row_ptr = gray_image.ptr<uchar>(y);
                        for (int x = 0; x < gray_image.cols; ++x) {
                            histogram[row_ptr[x]]++;
                        }
                    }

                    // 2. 归一化直方图 & 计算总均值
                    double normalized_hist[gray_levels] = {0.0};
                    double total_mean = 0.0;
                    for (int i = 0; i < gray_levels; ++i) {
                        normalized_hist[i] = static_cast<double>(histogram[i]) / total_pixels;
                        total_mean += i * normalized_hist[i];
                    }

                    double max_variance = 0.0;
                    int best_threshold = 0;

                    double w0 = 0.0; // 背景类概率
                    double sum0 = 0.0; // 背景类灰度和

                    // 3. 遍历阈值
                    for (int t = 0; t < gray_levels; ++t) {
                        w0 += normalized_hist[t];
                        if (w0 == 0) continue;

                        double w1 = 1.0 - w0;
                        if (w1 == 0) break;

                        sum0 += t * normalized_hist[t];
                        
                        double u0 = sum0 / w0;
                        double u1 = (total_mean - sum0) / w1;

                        // 4. 计算类间方差
                        double variance = w0 * w1 * (u0 - u1) * (u0 - u1);

                        // 5. 寻找最大方差
                        if (variance > max_variance) {
                            max_variance = variance;
                            best_threshold = t;
                        }
                    }

                    return best_threshold;
                }

                int main() {
                    cv::Mat image = cv::imread("your_image.jpg", cv::IMREAD_GRAYSCALE);
                    if (image.empty()) {
                        std::cout << "Could not open or find the image" << std::endl;
                        return -1;
                    }

                    // 使用我们自己实现的Otsu
                    int threshold_val_manual = otsuThreshold(image);
                    cv::Mat binary_image_manual;
                    cv::threshold(image, binary_image_manual, threshold_val_manual, 255, cv::THRESH_BINARY);

                    // 使用OpenCV内置的Otsu
                    cv::Mat binary_image_opencv;
                    double threshold_val_opencv = cv::threshold(image, binary_image_opencv, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);

                    std::cout << "Manual Otsu Threshold: " << threshold_val_manual << std::endl;
                    std::cout << "OpenCV Otsu Threshold: " << threshold_val_opencv << std::endl;

                    cv::imshow("Original", image);
                    cv::imshow("Binary Manual Otsu", binary_image_manual);
                    cv::imshow("Binary OpenCV Otsu", binary_image_opencv);
                    cv::waitKey(0);

                    return 0;
                }
                
```

#### **2.3 局部自适应阈值法 (Local Adaptive Thresholding)**

当图像光照不均匀时，全局阈值效果会很差。**局部自适应阈值法**为每个像素点计算其局部邻域内的一个阈值。

*   **思想：** 在像素 $(x, y)$ 周围设定一个窗口（例如 $11 \\times 11$），计算该窗口内的统计量（如均值或高斯加权均值）作为阈值。
*   **方法：**
    *   **均值法 (Mean-C):** $T(x,y) = \\text{mean}(W\_{xy}) - C$，其中 $W\_{xy}$ 是以 $(x,y)$ 为中心的窗口，`C` 是一个常数。
    *   **高斯法 (Gaussian-C):** $T(x,y) = \\text{gaussian\_mean}(W\_{xy}) - C$，使用高斯核对窗口内像素进行加权平均。

### **3\. 数学形态学 (Mathematical Morphology)**

数学形态学起源于1960年代，最初用于研究生物形态结构。在图像处理中，它是一套基于**集合论**的非线性分析理论，其核心思想是用一个预定义的、小的形状——**结构元素 (Structuring Element, SE)**——来探测和改变图像的形状。

#### **3.1 基础理论**

*   **图像与集合：** 在二值图像中，所有前景像素的坐标集合可以看作是二维整数空间 $\\mathbb{Z}^2$ 的一个子集 $A$。
*   **结构元素 (SE)：** 结构元素 $B$ 也是 $\\mathbb{Z}^2$ 的一个小子集，它有自己的**原点（origin）**。常见的SE有方形、圆形、十字形等。

**基本集合运算:**

1.  **平移 (Translation):** 将集合 $A$ 按向量 $z=(z\_1, z\_2)$ 平移，记为 $(A)\_z$。 $$ (A)\_z = { c \\in \\mathbb{Z}^2 \\mid c = a + z, \\text{ for some } a \\in A } $$
2.  **反射 (Reflection):** 将集合 $B$ 关于其原点做反射，记为 $\\hat{B}$。 $$ \\hat{B} = { w \\in \\mathbb{Z}^2 \\mid w = -b, \\text{ for some } b \\in B } $$

#### **3.2 四个基本操作**

**1\. 膨胀 (Dilation)**

*   **定义：** 集合 $A$ 被集合 $B$ 膨胀，记为 $A \\oplus B$。其结果是所有 $z$ 点的集合，这些 $z$ 满足 $\\hat{B}$ 平移到 $z$ 后与 $A$ 的交集不为空。 $$ A \\oplus B = { z \\mid (\\hat{B})\_z \\cap A \\neq \\emptyset } $$
*   **直观解释：** 膨胀会使图像中的前景区域“变胖”或“扩大”。可以想象将结构元素 $B$ 的原点滑过图像中的每一个像素。如果 $B$ 接触到了前景，则 $B$ 的原点对应的位置在输出图像中被标记为前景。它能填充前景区域内的小孔洞和断裂。
*   **物理意义：** 将与前景物体相连的背景像素并入前景，从而扩展物体边界，填补空洞。

**2\. 腐蚀 (Erosion)**

*   **定义：** 集合 $A$ 被集合 $B$ 腐蚀，记为 $A \\ominus B$。其结果是所有 $z$ 点的集合，这些 $z$ 满足 $B$ 平移到 $z$ 后完全被包含在 $A$ 中。 $$ A \\ominus B = { z \\mid (B)\_z \\subseteq A } $$
*   **直观解释：** 腐蚀会使图像中的前景区域“变瘦”或“缩小”。可以想象将结构元素 $B$ 的原点滑过图像中的每一个像素。只有当 $B$ 完全位于前景区域内部时， $B$ 的原点对应的位置在输出图像中才被标记为前景。它能消除细小的噪点和断开细微的连接。
*   **物理意义：** 移除物体边界，消除微小的、无意义的前景物体。

**3\. 开运算 (Opening)**

*   **定义：** 先腐蚀后膨胀。$A \\circ B = (A \\ominus B) \\oplus B$。
*   **直观解释：** “打开”了图像。它可以平滑物体的轮廓，断开狭窄的连接，并消除细小的突出物（毛刺）。**重要的是，它基本不改变主要物体的大小**。可以想象一个比物体内部缝隙大的结构元素滚过物体的外边界，所有滚不进去的细节都会被“磨平”。

**4\. 闭运算 (Closing)**

*   **定义：** 先膨胀后腐蚀。$A \\bullet B = (A \\oplus B) \\ominus B$。
*   **直观解释：** “闭合”了图像。它可以填充物体内部的小孔洞，连接邻近的物体，并平滑轮廓的内部。**同样，它也基本不改变主要物体的大小**。可以想象一个结构元素在物体内部的孔洞中滚动，所有它滚不进去的孔洞都会被“填满”。

#### **3.3 对偶性 (Duality)**

腐蚀和膨胀、开运算和闭运算之间存在着重要的对偶关系。令 $A^c$ 为 $A$ 的补集（前景变背景，背景变前景）。

*   **腐蚀与膨胀的对偶性：** 对前景 $A$ 进行膨胀，等价于对背景 $A^c$ 用反射的结构元素 $\\hat{B}$ 进行腐蚀。 $$ (A \\oplus B)^c = A^c \\ominus \\hat{B} $$ 反之亦然： $$ (A \\ominus B)^c = A^c \\oplus \\hat{B} $$
    
*   **开运算与闭运算的对偶性：** 对前景 $A$ 进行开运算，等价于对背景 $A^c$ 进行闭运算。 $$ (A \\circ B)^c = A^c \\bullet \\hat{B} $$
    

**C++ 代码示例 (使用OpenCV):**

```
#include <opencv2/opencv.hpp>

                int main() {
                    cv::Mat image = cv::imread("binary_image.png", cv::IMREAD_GRAYSCALE);
                    if (image.empty()) return -1;

                    // 定义一个3x3的矩形结构元素
                    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

                    cv::Mat dilated_img, eroded_img, opened_img, closed_img;

                    // 膨胀
                    cv::dilate(image, dilated_img, kernel);
                    // 腐蚀
                    cv::erode(image, eroded_img, kernel);
                    
                    // 开运算
                    cv::morphologyEx(image, opened_img, cv::MORPH_OPEN, kernel);
                    // 闭运算
                    cv::morphologyEx(image, closed_img, cv::MORPH_CLOSE, kernel);

                    cv::imshow("Original", image);
                    cv::imshow("Dilation", dilated_img);
                    cv::imshow("Erosion", eroded_img);
                    cv::imshow("Opening", opened_img);
                    cv::imshow("Closing", closed_img);
                    cv::waitKey(0);
                    return 0;
                }
                
```

### **4\. 形态学应用 (Morphological Applications)**

#### **4.1 边界提取 (Boundary Extraction)**

*   **原理：** 一个物体的边界，是其本身集合与被腐蚀后的集合之差。
*   **公式：** $\\beta(A) = A - (A \\ominus B)$
*   **步骤：**
    1.  对原始二值图像 $A$ 进行腐蚀操作，得到 $A \\ominus B$。
    2.  用 $A$ 减去腐蚀后的结果（逻辑异或或算术减法）。

#### **4.2 孔洞填充 (Hole Filling)**

*   **原理：** 这是一个迭代算法。从孔洞内部的一个种子点开始，在背景区域内进行条件性膨胀，直到填满整个孔洞。
*   **公式：**
    1.  选择一个孔洞内的起始点 $p$，初始化 $X\_0 = p$。
    2.  迭代执行：$X\_k = (X\_{k-1} \\oplus B) \\cap A^c$，$k=1, 2, 3, \\dots$
        *   $X\_{k-1} \\oplus B$：对当前填充区域进行膨胀。
        *   $\\cap A^c$：膨胀的结果不能超出原图的背景区域（即不能“漫”到另一个前景物体上）。
    3.  当 $X\_k = X\_{k-1}$ 时，迭代停止。
    4.  最终结果是 $X\_k \\cup A$。

#### **4.3 骨架提取 (Skeletonization)**

*   **原理：** 寻找物体的中轴线，即“骨架”。可以通过不断腐蚀物体，同时保留其拓扑结构（连通性）来实现。
*   **公式：** 骨架 $S(A)$ 可以表示为： $$ S(A) = \\bigcup\_{k=0}^{K} S\_k(A) = \\bigcup\_{k=0}^{K} \[ (A \\ominus kB) - ((A \\ominus kB) \\circ B) \] $$ 其中 $(A \\ominus kB)$ 表示 $A$ 被 $B$ 连续腐蚀 $k$ 次。$K$ 是使 $A$ 被完全腐蚀的迭代次数。该公式的本质是每次腐蚀后，将被开运算“吃掉”的部分保留下来，这些部分就是骨架点。

#### **4.4 噪声滤除 (Noise Removal)**

*   **去除“椒盐”噪声：**
    *   **椒噪声（Pepper noise，黑点）：** 可以通过**闭运算**有效去除，因为它能填充前景中的小孔洞。
    *   **盐噪声（Salt noise，白点）：** 可以通过**开运算**有效去除，因为它能消除孤立的小前景物体。
*   **组合使用：** 先进行开运算去除盐噪声，再进行闭运算去除椒噪声，是一种常用的去噪策略。

### **5\. 前沿拓展 (Advanced Topics & Frontiers)**

#### **5.1 灰度形态学 (Grayscale Morphology)**

形态学操作可以扩展到灰度图像。此时，集合运算被替换为 `min` 和 `max` 运算。

*   **灰度膨胀：** 输出像素的值是结构元素覆盖区域内输入像素的**最大值**。 $$ (I \\oplus B)(x,y) = \\max\_{(s,t) \\in B} { I(x-s, y-t) } $$
*   **灰度腐蚀：** 输出像素的值是结构元素覆盖区域内输入像素的**最小值**。 $$ (I \\ominus B)(x,y) = \\min\_{(s,t) \\in B} { I(x+s, y-t) } $$

灰度开运算和闭运算定义不变，它们可以用来平滑图像、去除亮/暗噪声，同时比线性滤波器（如均值滤波）更能保持边缘。

#### **5.2 形态学梯度 (Morphological Gradient)**

*   **定义：** 图像膨胀的结果减去腐蚀的结果。 $$ G(I) = (I \\oplus B) - (I \\ominus B) $$
*   **用途：** 可以有效提取物体的边缘轮廓。对于二值图像，它产生的是物体的边界线；对于灰度图像，它能突出灰度变化剧烈的区域，效果类似一阶导数。

#### **5.3 顶帽变换 (Top-hat) 和 黑帽变换 (Black-hat)**

*   **顶帽变换 (Top-hat):** 原始图像减去其开运算结果。 $$ T\_{hat}(I) = I - (I \\circ B) $$ **用途：** 提取比周围环境**更亮**的微小细节和斑点，因为开运算会移除这些亮点。
    
*   **黑帽变换 (Black-hat):** 图像的闭运算结果减去原始图像。 $$ B\_{hat}(I) = (I \\bullet B) - I $$ **用途：** 提取比周围环境**更暗**的微小细节和孔洞，因为闭运算会填充这些暗点。
    

#### **5.4 测地线形态学与形态学重建 (Geodesic Morphology and Reconstruction)**

这是形态学中一个非常强大的分支。它引入一个“掩膜（mask）”图像来约束形态学操作的范围。

*   **测地膨胀：** 对标记图像 $F$ 进行一次基本膨胀，然后与掩膜图像 $G$ 取逐像素最小值。
*   **形态学重建：** 从一个标记图像 $F$ 开始，在掩膜图像 $G$ 的约束下，反复进行测地膨胀，直到图像不再变化。
*   **应用：**
    *   **高效孔洞填充：** 无需手动指定种子点。
    *   **清除边界物体：** 去除所有与图像边界相连的物体。
    *   **峰值检测：** 提取图像中的局部极大值点。