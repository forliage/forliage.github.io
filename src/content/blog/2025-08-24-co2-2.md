---
title: "计算机组成2-2：数字的表示与指令的编码"
description: ""
pubDate: "2025-08-24"
heroImage: ""
---

# 计算机组成2-2：数字的表示与指令的编码

### **第二部分：数字的表示与指令的编码**

**本讲提纲：**

4.  **计算机世界的正与负——有符号数与无符号数**：我们将学习计算机如何用二进制位串来表示正数和负数，重点掌握业界标准的**补码表示法**。
5.  **将指令翻译成数字——计算机中的指令表示**：我们将揭开指令的神秘面纱，学习RISC-V指令是如何被编码成32位数字的，并详细解析几种核心的**指令格式**。

### **4\. 有符号数与无符号数**

#### **4.1 位串的意义：约定即是真理**

我们必须牢记一个基本事实：在计算机硬件层面，一切都是二进制位（bit）。一串0和1，比如 `10110101`，其本身没有任何内在含义。它究竟是一个数字、一个字符、一条指令，还是屏幕上某个像素的颜色？这完全取决于我们如何去**解释**它。

**核心思想：** 二进制位本身没有意义，是**约定（Conventions）** 定义了位串与数字（或其他信息）之间的关系。

#### **4.2 无符号整数 (Unsigned Integers)**

这是最简单、最直接的约定。我们把一个n位的二进制数看作一个普通的二进制正整数。其值的计算遵循我们熟悉的二进制转十进制的规则：

对于一个n位的二进制数 $x = x\_{n-1}x\_{n-2}...x\_1x\_0$，其表示的无符号整数值为： $$ \\text{Value}(x) = \\sum\_{i=0}^{n-1} x\_i \\cdot 2^i $$

*   **范围**：一个n位的无符号整数可以表示的范围是 $\[0, 2^n - 1\]$。
*   **示例**：一个8位的二进制数 `00001011` 表示的值是： $1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 8 + 0 + 2 + 1 = 11$。
*   **对于64位系统**：RISC-V的寄存器是64位的，它可以表示的无符号整数范围是 $\[0, 2^{64}-1\]$，这是一个巨大的数字（大约是 $1.84 \\times 10^{19}$）。

#### **4.3 有符号整数：补码 (2's Complement)**

现实世界中不仅有正数，还有负数。计算机如何表示负数呢？历史上出现过多种方案（如原码、反码），但现代计算机几乎无一例外地使用**补码 (2's Complement)** 表示法。

补码的设计非常精妙，它将减法运算统一为了加法运算，极大地简化了硬件设计。其核心思想是：

**将最高有效位 (Most Significant Bit, MSB) 视为“符号位”，但它的权重是负的。**

对于一个n位的二进制数 $x = x\_{n-1}x\_{n-2}...x\_1x\_0$，其表示的补码有符号整数值为： $$ \\text{Value}(x) = -x\_{n-1} \\cdot 2^{n-1} + \\sum\_{i=0}^{n-2} x\_i \\cdot 2^{i} $$

*   **符号位**：
    *   当最高位 $x\_{n-1}$ 为 **0** 时，第一项为0，该数表示一个**非负数**。此时，其值与无符号数的计算方式完全相同。
    *   当最高位 $x\_{n-1}$ 为 **1** 时，第一项为一个大的负数，该数表示一个**负数**。
*   **范围**：一个n位的补码数可以表示的范围是 $\[-2^{n-1}, 2^{n-1} - 1\]$。
*   **示例** (以32位为例)：二进制数 `1111 1111 1111 1111 1111 1111 1111 1100` 表示的值是：
    *   最高位是1，所以这是一个负数。
    *   Value = $-1 \\cdot 2^{31} + (1 \\cdot 2^{30} + ... + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0)$
    *   Value = $-2,147,483,648 + 2,147,483,644 = -4$
*   **对于64位系统**：可以表示的范围是 $\[-2^{63}, 2^{63}-1\]$ (大约是 $-9 \\times 10^{18}$ 到 $+9 \\times 10^{18}$)。

**补码的一些重要特性：**

数字

32位二进制表示

说明

**0**

`0000...0000`

全0

**\-1**

`1111...1111`

全1

**最大正数**

`0111...1111` ($2^{31}-1$)

符号位为0，其余全1

**最小负数**

`1000...0000` ($-2^{31}$)

符号位为1，其余全0。注意，它的相反数无法表示。

#### **4.4 补码求负运算：取反加一**

如何快速得到一个数 `X` 的相反数 `-X` 的补码表示？有一个非常简单的技巧：**将其所有位取反，然后加一。**

*   **示例**：求 `+2` 的相反数 `-2` 的32位补码表示。
    
    1.  `+2` 的二进制表示为：`0000 0000 ... 0000 0010`
    2.  **按位取反** (Complement)：`1111 1111 ... 1111 1101`
    3.  **加一** (Add 1)：`1111 1111 ... 1111 1110` 这个结果就是 `-2` 的补码表示。
*   **数学原理**：对于任意n位二进制数 $x$，我们有 $x + \\bar{x} = 11...1\_2 = -1$。 因此，$\\bar{x} + 1 = -x$。这个简单的代数关系正是“取反加一”的数学基础。
    

### **5\. 将指令翻译成数字——计算机中的指令表示**

现在我们知道了如何在计算机中表示数据（数字），接下来我们来解决另一个核心问题：如何表示**指令**？这正是“存储程序概念”的精髓所在。

#### **5.1 指令编码：从汇编到机器码**

计算机指令，如 `add x9, x20, x21`，最终必须被翻译（或称为**编码**）成一个32位的二进制数，这个过程由汇编器完成。这个二进制数被称为**机器码**或**机器指令**。

编码的过程就像一个填空游戏。一条指令会被拆分成多个**字段 (Fields)**，每个字段代表指令的一部分信息，如操作类型、源寄存器、目标寄存器等。

**示例：编码 `add x9, x20, x21`**

1.  **汇编指令**：`add x9, x20, x21`
2.  **信息分解**：
    *   操作：`add`
    *   目标寄存器 `rd`：`x9` (编号为9)
    *   源寄存器1 `rs1`：`x20` (编号为20)
    *   源寄存器2 `rs2`：`x21` (编号为21)
3.  **映射到指令字段（R-Type格式）**： `add` 指令属于R-Type格式，其字段和对应的十进制值为：
    
    funct7
    
    rs2
    
    rs1
    
    funct3
    
    rd
    
    opcode
    
    0
    
    21
    
    20
    
    0
    
    9
    
    51
    
4.  **转换为二进制机器码**： | 0000000 | 10101 | 10100 | 000 | 01001 | 0110011 | | 7 bits | 5 bits | 5 bits | 3 bits | 5 bits | 7 bits |

将这些二进制位串连接起来，就得到了最终的32位机器码：`00000001010110100000010010110011`。CPU的控制单元在取到这条指令后，就会按照这个格式解码，识别出这是一条 `add` 指令，并控制相应的数据通路完成 `x20` 和 `x21` 的相加，将结果写入 `x9`。

#### **5.2 便捷表示：十六进制 (Hexadecimal)**

写一长串0和1既繁琐又容易出错。因此，工程师们通常使用**十六进制 (Base 16)** 作为二进制数的紧凑表示。

*   **规则**：每4个二进制位对应1个十六进制数。
*   **符号**：用 0-9 和 A-F 来表示。

十六进制

二进制

十六进制

二进制

0

0000

8

1000

1

0001

9

1001

2

0010

A

1010

3

0011

B

1011

4

0100

C

1100

5

0101

D

1101

6

0110

E

1110

7

0111

F

1111

*   **示例**：将上面的机器码转换为十六进制： `0000 0001 0101 1010 0000 0100 1011 0011` `0 1 5 A 0 4 B 3` 所以，这条指令的十六进制表示为 `0x015A04B3` (前缀 `0x` 表示十六进制)。

#### **5.3 RISC-V 指令格式 (Instruction Formats)**

RISC-V 的所有指令长度都是固定的32位，这遵循了“大道至简，规整统一”的设计原则。然而，不同类型的指令（如算术指令、访存指令、立即数指令）需要的信息是不同的。为了在固定的32位空间内容纳这些不同的信息，同时又要尽量保持规整性，RISC-V定义了少数几种指令格式。

**设计原则3的应用：好的设计需要好的折中 (Good Design Demands Good Compromises)** 保持所有指令长度相同，简化了取指和解码的硬件。但为了功能完备，又必须允许不同指令的内部字段有所不同。指令格式的设计正是在这两者之间寻求平衡。

我们来学习最核心的三种格式：

**1\. R-Type (Register-Type)** 用于寄存器-寄存器之间的算术/逻辑运算，如 `add`, `sub`。

*   **`opcode` (7位)**：主操作码，定义指令的基本类型。
*   **`rd` (5位)**：目标寄存器编号。
*   **`rs1`, `rs2` (各5位)**：两个源寄存器编号。
*   **`funct3`, `funct7` (3位和7位)**：功能码。当多条指令共享同一个 `opcode` 时（例如 `add` 和 `sub` 的 `opcode` 相同），用这两个字段来进一步区分具体的操作。

**2\. I-Type (Immediate-Type)** 用于包含立即数的算术/逻辑运算（如 `addi`）和**加载**操作（如 `ld`）。

*   相对于R-Type，`rs2` 和 `funct7` 字段被合并成了一个**12位的 `immediate` 字段**。
*   **示例 `ld x9, 64(x22)`**:
    *   `ld` 操作的 `opcode` 和 `funct3` 是固定的。
    *   `rd` 字段为 9 (对应 `x9`)。
    *   `rs1` 字段为 22 (对应基址寄存器 `x22`)。
    *   `immediate` 字段为 64。

**3\. S-Type (Store-Type)** 用于**存储**操作（如 `sd`）。存储操作需要两个源寄存器（一个存基地址，一个存要写入的数据）和一个立即数偏移量。

*   **特殊之处**：`immediate` 字段被**拆分**成了两部分（7位和5位）。
*   **为什么拆分？** 这是一个绝佳的“好的折中”的例子！通过这种看似奇怪的拆分，S-Type格式中的 `rs1` 和 `rs2` 字段能够与R-Type和I-Type格式中的 `rs1` 和 `rs2` 字段**保持在完全相同的位置**。这大大简化了CPU的指令解码硬件，因为无论来的是哪种指令，解码器总能在固定的位置找到源寄存器编号。
*   **示例 `sd x9, 64(x22)`**:
    *   `sd` 操作的 `opcode` 和 `funct3` 是固定的。
    *   `rs1` (基址) 字段为 22。
    *   `rs2` (源数据) 字段为 9。
    *   `immediate` 64 会被拆分填入 `imm[11:5]` 和 `imm[4:0]` 两个部分。

#### **5.4 完整翻译示例回顾**

让我们看一个稍复杂的例子，将C代码 `A[30] = h + A[30] + 1;` 翻译成机器码。

*   假设 `h` 在 `x21`，`A` 的基地址在 `x10`。
*   汇编代码序列为：
    
    ```
    // A[30]的地址偏移量是 30 * 8 = 240
                    ld   x9, 240(x10)     // 临时寄存器 x9 = A[30]
                    add  x9, x21, x9      // x9 = h + A[30]
                    addi x9, x9, 1        // x9 = h + A[30] + 1
                    sd   x9, 240(x10)     // A[30] = x9
                    
    ```
    
*   **我们来编码第一条指令 `ld x9, 240(x10)`**：
    *   这是一条 I-Type 指令。
    *   `opcode` (ld): `0000011`
    *   `rd` (x9): `01001`
    *   `funct3` (ld, doubleword): `011`
    *   `rs1` (x10): `01010`
    *   `immediate` (240): `000111100000`
    *   **组合成32位机器码**：`000111100000 01010 011 01001 0000011`

**本讲小结**

在这一部分，我们解决了两个基本但至关重要的问题。

1.  **数字表示**：我们学习了无符号数和有符号数的二进制表示法，并重点掌握了现代计算机通用的**补码**系统，以及其“取反加一”的求负运算。
2.  **指令表示**：我们深入理解了“存储程序”的概念，学习了如何将一条汇编指令通过**编码**转换成32位的机器码。我们还详细解析了RISC-V的三种核心**指令格式（R-Type, I-Type, S-Type）**，并体会了其中蕴含的“好的设计需要好的折中”的设计哲学。