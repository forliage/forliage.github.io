---
title: "数据库系统设计07:事务(Transactions)"
description: ""
pubDate: "2025-08-26"
heroImage: ""
---

# 数据库系统设计07:事务(Transactions)

问题：**当事情出错时，会发生什么？**

想象一个最简单的银行转账场景：账户A要转100元给账户B。这个操作在数据库中至少需要两步：

```

UPDATE accounts SET balance = balance - 100 WHERE account_id = 'A';
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B';

```

现在，思考几个“意外”情况：

*   **系统崩溃:** 如果在执行完第一步后，服务器突然断电了，会发生什么？账户A的钱被扣了，但B的钱没到。银行凭空“吞”了100元！
*   **并发冲突:** 如果在A扣款之后、B到账之前，另一个程序恰好在此时查询A和B的总额，它会发现总额少了100元。这个“不一致”的中间状态被暴露了，可能会引发错误的决策。
*   **并发修改:** 如果在A转账的同时，另一个程序（比如银行结算利息）也在修改A或B的余额，最终的结果会是谁覆盖谁？

这些问题揭示了一个残酷的现实：**一系列相关的数据库操作，必须被视为一个不可分割的、逻辑上的整体。** 这个“整体”，就是我们今天要学习的核心概念——**事务 (Transaction)**。

事务是数据库系统提供给应用程序的**最重要的抽象**。它向我们承诺：你可以将一组操作打包，然后放心地交给数据库。数据库会保证，这个包里的操作要么**全部成功**，要么**全部失败**，并且在执行过程中，不会被其他并发操作干扰，其结果一旦成功，就将**永久保留**。

### **第一部分：ACID**

ACID是`Atomicity` (原子性), `Consistency` (一致性), `Isolation` (隔离性), `Durability` (持久性) 四个单词的首字母缩写。它是衡量一个事务处理系统是否可靠的黄金标准。我们将逐一解构它们，理解其深刻含义和现实意义。

#### **1.1 A for Atomicity (原子性)**

*   **定义:** 一个事务被视为一个**不可分割的最小工作单元**。事务中的所有操作，要么**全部**成功执行并提交，要么在任何一步失败后，**全部**回滚到事务开始前的状态，就好像这个事务从未发生过一样。
    
*   **解决的问题:** 系统崩溃（如转账例子中的断电）。
    
*   **实现机制的预览:** 原子性主要由数据库的**恢复系统 (Recovery System)** 来保证。其核心技术是**日志 (Logging)**。
    
    *   数据库在修改数据之前，会先将“要做什么”的意图（即操作日志）写入一个稳定存储（磁盘）上的日志文件中。
    *   如果在执行过程中崩溃，当系统重启时，恢复管理器会读取日志：
        *   对于已完成但未提交的事务，它会**撤销 (Undo)** 该事务所做的所有修改。
        *   对于已提交但可能未完全写入数据文件的事务，它会**重做 (Redo)** 这些修改，确保其效果被体现。
*   **事务的状态变迁:** 为了实现原子性，一个事务在其生命周期中会经历不同的状态。
    
    *   **Active (活动):** 事务正在执行。
    *   **Partially Committed (部分提交):** 事务的最后一条语句已执行。此时它已“完成”工作，但结果可能还在内存缓冲区，尚未保证持久化。
    *   **Committed (已提交):** 事务已成功完成，其所有修改都已被安全地记录下来，保证持久。
    *   **Failed (失败):** 事务在执行中遇到错误（如违反约束、死锁），无法继续。
    *   **Aborted (已中止):** 事务失败后，其所有修改已被成功回滚。

#### **1.2 C for Consistency (一致性)**

*   **定义:** 事务的执行，必须使数据库**从一个一致的状态，转变到另一个一致的状态**。
    
*   **“一致的状态”是什么意思？** 这意味着数据必须满足所有预定义的**完整性约束 (Integrity Constraints)**，例如：
    
    *   主键唯一性 (`PRIMARY KEY`)
    *   外键引用完整性 (`FOREIGN KEY`)
    *   字段的类型、非空约束 (`NOT NULL`)
    *   业务逻辑层面的约束（例如，银行账户余额不能为负；转账前后，所有账户总额不变）。
*   **谁的责任？** 一致性是一个**共担的责任**：
    
    *   **数据库的责任:** 保证**原子性、隔离性和持久性**。如果一个事务在中间失败，数据库必须通过回滚来恢复到前一个一致状态。
    *   **应用程序的责任:** 编写**逻辑正确**的事务。数据库无法阻止你写一个“从A账户扣100，给B账户加80”的错误转账事务。它只能保证这个错误的事务是原子地、隔离地执行的。
*   **总结:** **A, I, D 是数据库的承诺，C 是应用程序和数据库协同实现的目标。** A, I, D 是因，C 是果。
    

#### **1.3 I for Isolation (隔离性)**

*   **定义:** 尽管多个事务可能在**并发地**执行，但对于任何一个事务来说，它都感觉不到其他事务的存在。每个事务都像是**在整个数据库的一个私有副本上独立运行**一样。一个事务的中间状态，对其他并发事务是不可见的。
*   **解决的问题:** 并发执行时的数据冲突和不一致。
*   **并发异常 (Concurrency Anomalies):** 如果没有隔离性，会发生以下典型问题：
    1.  **脏读 (Dirty Read):** 事务$T\_1$修改了一条数据但**尚未提交**，此时事务$T\_2$读取了这条被修改的“脏”数据。如果$T\_1$随后回滚，那么$T\_2$读取的数据就是无效的、从未正式存在过的。
    2.  **不可重复读 (Non-Repeatable Read):** 事务$T\_1$在事务期间，两次读取同一条数据，但两次读取的结果不同。这是因为在两次读取之间，另一个事务$T\_2$修改并**提交**了这条数据。
    3.  **幻读 (Phantom Read):** 事务$T\_1$在事务期间，两次执行**范围查询**（例如 `SELECT * FROM users WHERE age > 20`），但两次查询返回的**记录行数**不同。这是因为在两次查询之间，另一个事务$T\_2$插入或删除了一些满足该范围条件的记录。
*   **实现机制的预览:** 隔离性主要由**并发控制管理器 (Concurrency Control Manager)** 保证。核心技术包括：
    *   **锁 (Locking):** 事务在访问数据前，先获取该数据的锁。其他事务如果想访问，就必须等待锁被释放。最常见的锁协议是**两阶段封锁 (Two-Phase Locking, 2PL)**。
    *   **多版本并发控制 (Multi-Version Concurrency Control, MVCC):** 不通过锁来阻塞，而是为数据维护多个历史版本。每个事务只能看到在它开始之前就已经提交的版本。这是PostgreSQL, Oracle, InnoDB等现代数据库的主流实现。

#### **1.4 D for Durability (持久性)**

*   **定义:** 一旦事务被成功**提交 (Commit)**，它对数据库所做的所有修改都必须是**永久性的**。即使在提交之后系统立即发生崩溃（如断电、宕机），这些修改也必须能够被恢复。
*   **解决的问题:** 保证已提交事务的结果在系统故障后的幸存。
*   **实现机制的预览:** 持久性同样由**恢复系统**保证，其核心也是**日志**。
    *   **预写日志 (Write-Ahead Logging, WAL):** 这是实现持久性的黄金法则。其内容是：在将数据的修改**写入数据文件之前**，必须**先**将描述该修改的**日志记录写入到稳定存储**。
    *   **工作流程:** 当事务提交时，系统并不需要立即将所有修改过的数据页都刷到磁盘（这很慢），它只需要保证**与该事务相关的所有日志记录**都已经被安全地写入磁盘日志文件即可。
    *   **崩溃恢复:** 系统重启后，恢复管理器会通过扫描日志，**重做 (Redo)** 那些已经提交但其数据修改可能未写入数据文件的事务，从而保证其持久性。
*   **\[拓展\] 影子分页 (Shadow Paging):**
    *   一种早期的、更简单的实现原子性和持久性的方法，但效率较低。
    *   **思想:** 从不原地修改数据页。当要修改一个页时，先将其复制一份，在新副本上进行修改。通过一个根指针`db_pointer`来维护当前一致的数据库版本。
    *   **提交:** 原子地更新`db_pointer`，使其指向包含新修改的页面树。
    *   **回滚:** 只需丢弃新副本，`db_pointer`保持不变即可。
    *   **缺点:** 破坏了数据的物理聚集性（新旧页散落各处）、提交开销大（需要复制路径上的所有节点）、并发控制复杂。因此，现代数据库普遍采用基于日志的恢复方案。

### **第二部分：并发的“正确性” —— 可串行化理论**

我们知道并发执行能提高系统吞吐率和资源利用率，但也引入了数据不一致的风险。那么，什么样的并发执行才是“正确”的呢？

#### **2.1 调度 (Schedule)**

*   **定义:** 一个**调度**是指示一组事务中所有操作的执行顺序的时间序列。
    
*   **串行调度 (Serial Schedule):** 一个接一个地执行事务，中间没有任何交错。例如 $T\_1 \\rightarrow T\_2$。
    
*   **并发调度 (Concurrent Schedule):** 事务的操作是交错执行的。
    
*   **Schedule 1 ($T\_1 \\rightarrow T\_2$):** 串行。A+B=3000 -> 3000。一致性得到保持。
    
*   **Schedule 2 ($T\_2 \\rightarrow T\_1$):** 串行。A+B=3000 -> 3000。一致性得到保持。
    
*   **Schedule 3 (并发，但结果正确):** $T\_1$读A,写A -> $T\_2$读A,写A,读B,写B -> $T\_1$读B,写B。最终A=855, B=2145, A+B=3000。结果与某个串行调度($T\_2 \\rightarrow T\_1$)等价。
    
*   **Schedule 4 (并发，但结果错误 - 丢失更新):** $T\_1$读A -> $T\_2$读A,写A -> $T\_1$写A。$T\_2$的更新被$T\_1$覆盖了。最终A+B != 3000。
    

#### **2.2 可串行化 (Serializability)**

*   **基本假设:** 我们相信每个独立事务本身是正确的（能保持一致性）。
*   **推论:** 任何串行调度都一定是正确的。
*   **核心定义:** 一个并发调度S，如果其执行结果与**某个**串行调度S'的执行结果完全等价，那么我们称调度S是**可串行化的 (Serializable)**。
*   **重要性:** **可串行化是数据库理论中定义的最高隔离级别**。它为并发事务的正确性提供了一个简单而强大的判断标准：我们只需要证明一个并发调度等价于某个串行调度，就可以断定它是正确的，而无需关心事务的具体语义。

#### **2.3 冲突可串行化 (Conflict Serializability)**

如何判断一个调度是否可串行化？检查所有可能的最终状态太复杂了。我们需要一个更简单的、基于操作**冲突 (Conflict)** 的判断方法。

*   **冲突操作的定义:** 两个来自**不同事务**的操作，作用于**同一个数据项**上，并且**至少有一个是写操作**，那么这两个操作就是冲突的。
    *   `Read(Q) - Read(Q)`: 不冲突。
    *   `Read(Q) - Write(Q)`: **冲突**。
    *   `Write(Q) - Read(Q)`: **冲突**。
    *   `Write(Q) - Write(Q)`: **冲突**。
*   **冲突的意义:** 冲突操作的执行顺序**不能随意交换**，否则可能会改变最终结果。
*   **冲突等价 (Conflict Equivalence):** 两个调度S1和S2，如果它们包含相同的事务集，并且所有冲突操作对的相对顺序在S1和S2中都完全相同，那么S1和S2是冲突等价的。
*   **冲突可串行化 (Conflict Serializable):** 一个调度S，如果它与**某个**串行调度冲突等价，那么S就是冲突可串行化的。

#### **2.4 使用优先图 (Precedence Graph) 进行测试**

这是一个用于判断一个调度是否**冲突可串行化**的简单图论方法。

*   **构建方法:**
    
    1.  图的**顶点**是参与调度的所有事务 ($T\_1$, $T\_2$, ...)。
    2.  如果调度中存在一个操作 $op\_i(Q)$ (来自$T\_i$) 在另一个操作 $op\_j(Q)$ (来自$T\_j$) 之前执行，并且这两个操作是冲突的，那么就在图中画一条从 $T\_i$ 指向 $T\_j$ 的有向边 $T\_i \\rightarrow T\_j$。
*   **判断定理:**
    
    *   一个调度是**冲突可串行化的，当且仅当 (if and only if) 它的优先图是无环的 (acyclic)**。
    *   如果图无环，那么该图的任意一个**拓扑排序 (Topological Sort)** 就对应一个与原调度等价的串行调度。

**\[示例分析\]**

*   为上一节的Schedule 3和Schedule 4画优先图。
*   Schedule 3: $T\_1$.write(A) 在 $T\_2$.read(A) 之前 -> 无冲突。 $T\_2$.write(A)在$T\_1$.read(B)之前 -> 无冲突。$T\_2$.write(B) 在$T\_1$.write(B)之前 -> $T\_2 \\rightarrow T\_1$。最终只有一条边，无环。
*   Schedule 4 (假设$T\_1$读A, $T\_2$读A, $T\_2$写A, $T\_1$写A): $T\_1$.read(A)在$T\_2$.write(A)之前 -> $T\_1 \\rightarrow T\_2$。$T\_2$.read(A)在$T\_1$.write(A)之前 -> $T\_2 \\rightarrow T\_1$。**图中存在 $T\_1 \\rightarrow T\_2 \\rightarrow T\_1$ 的环！** 因此，Schedule 4不是冲突可串行化的。

### **第三部分：隔离级别与可恢复性**

可串行化虽然提供了最强的保证，但实现它的并发控制协议（如严格两阶段封锁）通常会限制并发度，带来性能开销。因此，SQL标准和现实世界的数据库，定义了一系列**更弱的隔离级别**，允许应用程序在**性能和一致性之间做出权衡**。

#### **3.1 SQL隔离级别**

隔离级别

允许的并发异常

描述

**READ UNCOMMITTED (读未提交)**

脏读, 不可重复读, 幻读

最低级别。一个事务可以读取到其他事务尚未提交的修改。性能最高，但一致性最差。

**READ COMMITTED (读已提交)**

不可重复读, 幻读

一个事务只能读取到其他事务**已经提交**的数据。这是大多数数据库（如PostgreSQL, Oracle）的**默认隔离级别**。它避免了脏读，但无法保证在同一个事务内重复读取的结果一致。

**REPEATABLE READ (可重复读)**

幻读

保证在同一个事务内，对同一数据的多次读取结果都是一致的。它通过锁或MVCC快照来防止其他事务修改正在被读取的数据。但它无法阻止其他事务插入新的、满足范围查询条件的“幻影”行。MySQL InnoDB的默认级别，并通过Next-Key Locking在一定程度上解决了幻读。

**SERIALIZABLE (可串行化)**

(无)

最高级别。完全模拟串行执行，杜绝所有并发异常。性能开销最大。

#### **3.2 可恢复性 (Recoverability)**

除了隔离性，一个“好”的调度还必须是**可恢复的**。

*   **可恢复调度 (Recoverable Schedule):**
    *   **定义:** 对于任意两个事务$T\_i$和$T\_j$，如果$T\_j$读取了由$T\_i$写入的数据，那么**$T\_i$必须在$T\_j$提交之前提交**。
    *   **为什么需要？** 试想一个不可恢复的调度：$T\_1$写A -> $T\_2$读A -> $T\_2$提交 -> $T\_1$中止。$T\_2$提交了一个基于“脏数据”的结果，而这个脏数据的来源$T\_1$却回滚了，导致数据库进入一个不一致的状态，且无法修复。
*   **无级联回滚调度 (Cascadeless Schedule):**
    *   **问题:** 在一个可恢复调度中，如果 $T\_1$写A -> $T\_2$读A -> $T\_1$中止，那么$T\_2$也必须中止，因为它读了脏数据。如果$T\_3$又读了$T\_2$写的数据，那么$T\_3$也要中止…… 这种连锁反应称为**级联回滚 (Cascading Aborts)**，代价高昂。
    *   **定义:** 对于任意两个事务$T\_i$和$T\_j$，如果$T\_j$要读取由$T\_i$写入的数据，那么**$T\_i$必须在$T\_j$读取之前提交**。
    *   **优点:** 避免了级联回滚。一个事务的中止，不会引发其他事务的中止。这通过\*\*“读已提交”\*\*的策略来实现。
*   **严格调度 (Strict Schedule):**
    *   **定义:** 要求更高，如果$T\_j$要**读取或写入**由$T\_i$写入的数据，那么**$T\_i$必须在$T\_j$操作之前提交或中止**。
    *   **优点:** 使得回滚操作变得非常简单。要回滚一个事务，只需恢复它修改过的数据的“前像” (before-image) 即可，无需担心其他并发事务。几乎所有基于锁的商业数据库都实现了严格调度。