---
title: "操作系统01:Introduction"
description: ""
pubDate: "2025-09-16"
heroImage: ""
---

# 操作系统01:Introduction

#### **I 究竟什么是操作系统？**

我们先来看一个最根本的问题：操作系统是什么？

**操作系统的角色**

想象一下，你是一位公司的CEO，你的手下有各种各enta（员工，比如CPU、内存、硬盘），还有各种各样的项目（应用程序）。你作为CEO，并不会亲自去执行每一个具体的任务，但你需要：

*   **管理和分配资源**：决定哪个项目组（程序）可以使用会议室（内存），使用多久。
*   **制定规则和流程**：确保各个项目组之间不会互相干扰，能够有序地工作。
*   **提供公共服务**：比如提供打印、网络等基础服务，让项目组可以方便地使用。

在这个比喻里，**你（CEO）就是操作系统**。

所以，我们可以从两个视角来定义操作系统：

1.  **用户视角：一个中介**  
    操作系统是用户与计算机硬件之间的**中介程序**。它为我们提供了一个方便、易用的界面，让我们不必去关心底层硬件那些复杂的细节。我们只需要点击鼠标、敲击键盘，操作系统就会将我们的意图翻译成硬件能够理解的指令去执行。
    
    graph TD A\[用户 User\] --> B{操作系统 OS}; B --> C\[计算机硬件 Hardware\];
    
2.  **系统视角：一个管理者**  
    操作系统是计算机系统资源的**管理者**。它负责管理和分配计算机的所有硬件和软件资源，如CPU时间、内存空间、文件存储、I/O设备等。
    

**操作系统的目标**

综合来看，一个好的操作系统需要实现以下三个核心目标：

*   **方便性 (Convenience)**：让用户使用计算机更加方便。图形化界面、即插即用，都是为了这个目标。
*   **高效性 (Efficiency)**：高效地管理和利用计算机硬件资源，确保系统资源不被浪费。
*   **执行用户程序 (Execute Programs)**：为用户程序提供一个可以运行的环境，并帮助用户程序解决问题。

**操作系统的形态万千**

操作系统并非只有我们熟知的Windows或macOS。它无处不在，形态各异：

*   **桌面系统**：Windows, macOS, Linux (Ubuntu, etc.)
*   **服务器系统**：Linux (CentOS, RedHat), Windows Server
*   **移动设备系统**：Android, iOS
*   **嵌入式系统**：智能手表、路由器、汽车中控里的实时操作系统（RTOS）
*   **新兴形态**：云操作系统 (Cloud OS)、元宇宙操作系统 (Metaverse OS)，甚至大模型驱动的AI操作系统 (AIOS)，它们正在重新定义人机交互和资源管理的方式。

从过去需要手动操作开关和插拔线缆的庞大机器，到今天我们口袋里的智能手机，操作系统一直随着硬件和应用需求的发展而不断进化。

#### **II 计算机系统的整体结构**

为了理解操作系统是如何工作的，我们必须先了解它所运行的平台——计算机系统的结构。一个计算机系统可以被划分为四个层次，自底向上分别是：

1.  **硬件 (Hardware)**：提供最基本的计算资源，包括CPU、内存、I/O设备（键盘、鼠标、硬盘、显示器等）。
2.  **操作系统 (Operating System)**：控制和协调各个用户在运行不同应用程序时对硬件资源的使用。它是连接硬件和应用软件的桥梁。
3.  **应用程序 (Application Programs)**：定义了如何使用系统资源来解决用户的计算问题。例如：编译器、浏览器、游戏、文本编辑器等。
4.  **用户 (Users)**：可以是人，也可以是其他计算机或机器。

我们可以用一个层次图来清晰地展示它们之间的关系：

graph TD subgraph 计算机系统 U1\[用户1\] --> C\[编译器\] U2\[用户2\] --> A\[汇编器\] U3\[用户3\] --> T\[文本编辑器\] U4\[...\] --> D\[数据库系统\] subgraph "系统与应用软件" C --> OS A --> OS T --> OS D --> OS end subgraph "操作系统" OS end subgraph "计算机硬件" OS --> HW\[Computer Hardware\] end end style OS fill:#cde4ff

这个结构告诉我们，用户通过应用程序与操作系统交互，而操作系统则负责管理底层的硬件。每一层都建立在下一层的基础之上。

#### **III 计算机是如何启动和运行的？**

我们按下电源键后，发生了什么？操作系统是如何被唤醒并开始工作的？

**1\. 计算机启动 (Computer Startup)**

这个过程被称为**引导 (Bootstrapping)**。

*   当我们按下电源键，一个被称为**引导程序 (bootstrap program)** 的小程序会被加载并执行。
*   这个程序通常存储在一种只读存储器（ROM）或电可擦除可编程只读存储器（EPROM）中，我们通常称之为**固件 (Firmware)**，比如计算机主板上的BIOS或UEFI。
*   引导程序会执行一系列**加电自检 (POST)**，初始化CPU、内存、设备控制器等系统各个方面。
*   最后，它会从硬盘等存储设备中找到**操作系统内核 (Kernel)**，将其加载到内存中，并将控制权交给内核。
*   至此，操作系统正式开始运行，接管整个计算机。

**2\. 计算机系统操作 (Computer-System Operation)**

操作系统一旦运行起来，就需要处理来自CPU和各种I/O设备的请求。现代计算机系统的核心架构是**总线 (Bus)** 结构。

graph TD subgraph " " CPU <--> B((总线 Bus)) MEM\[内存 Memory\] <--> B end subgraph " " D\_CTRL\[磁盘控制器\] <--> B U\_CTRL\[USB控制器\] <--> B G\_CTRL\[显卡适配器\] <--> B end subgraph "I/O 设备" DISK\[磁盘 Disks\] <--> D\_CTRL MOUSE\[鼠标\] --> U\_CTRL KEYBOARD\[键盘\] --> U\_CTRL PRINTER\[打印机\] --> U\_CTRL MONITOR\[显示器\] <--> G\_CTRL end style B fill:#f9f,stroke:#333,stroke-width:2px

*   一个或多个CPU和多个设备控制器通过公共**总线**连接，共享对主内存的访问。
*   CPU和I/O设备可以**并发执行**。例如，CPU在执行计算任务的同时，硬盘可以进行数据读取。
*   每个设备控制器负责管理一类特定的设备（如USB控制器管理所有USB设备），并且它有自己的**本地缓冲区 (local buffer)**。
*   当I/O操作发生时（例如，从硬盘读数据），数据先从设备传输到控制器的本地缓冲区，然后再由CPU（或DMA）将其从缓冲区移到主内存。

**3\. 中断 (Interrupts)**

这里有一个关键问题：当一个缓慢的I/O设备（比如打印机）完成了它的任务，它如何通知CPU呢？总不能让CPU一直傻等吧？

答案是**中断**。

*   **中断是现代操作系统的核心驱动机制**。
*   当一个设备完成了操作，设备控制器会通过系统总线向CPU发送一个**中断信号**。
*   CPU接收到中断信号后，会**暂停**当前正在执行的任务，保存好现场（即当前的寄存器状态和程序计数器），然后跳转到内存中一个特定的地址去执行一段代码，这段代码被称为**中断服务程序 (Interrupt Service Routine)**。
*   中断服务程序处理完该事件后（比如，告诉操作系统打印任务已完成），CPU会恢复之前保存的现场，继续执行被打断的任务。

整个过程可以用一个时间线图来表示：

gantt title CPU 与 I/O 设备的中断时间线 dateFormat X axisFormat %s section CPU 用户进程执行 : 0, 4 I/O中断处理 : 4, 5 用户进程执行 : 5, 8 I/O中断处理 : 8, 9 用户进程执行 : 9, 12 section I/O设备 空闲(Idle) : 0, 2 数据传输(Transferring) : 2, 4 空闲(Idle) : 4, 6 数据传输(Transferring) : 6, 8 空闲(Idle) : 8, 12 %% 描述事件 %% 在时间点2，用户进程发起I/O请求 %% 在时间点4，I/O完成，发出中断 %% 在时间点6，用户进程再次发起I/O请求 %% 在时间点8，I/O完成，发出中断

从图中可以看到，当I/O设备在进行数据传输时，CPU并没有闲着，而是在执行用户进程。只有当I/O完成并产生中断时，CPU才需要花一小部分时间去处理中断。这就是并发的精髓。

除了硬件产生的中断，还有一种由软件产生的中断，称为**陷阱 (Trap)** 或 **异常 (Exception)**。比如，当你的程序试图除以零，或者需要请求操作系统服务（如读文件）时，就会产生一个陷阱。我们之后会学到，用户程序通过这种方式（称为**系统调用 System Call**）来请求内核的服务。

**4\. I/O 结构与 DMA**

*   **同步I/O (Synchronous I/O)**：用户进程发起I/O请求后，会一直**阻塞**，直到I/O操作完成。简单，但CPU效率低。
*   **异步I/O (Asynchronous I/O)**：用户进程发起I/O请求后，会**立即返回**，继续执行其他代码。当I/O操作完成时，操作系统会通过某种方式（如中断或回调）通知该进程。效率高，但编程复杂。

graph TD subgraph 同步I/O A\[请求进程\] -- 发起请求 --> B\[设备驱动\]; B -- I/O操作 --> C\[硬件\]; A -. 等待 .-> A; C -- 中断 --> D\[中断处理\]; D -- 返回 --> B; B -- 完成 --> A; end subgraph 异步I/O X\[请求进程\] -- 发起请求，立即返回 --> Y\[设备驱动\]; Y -- I/O操作 --> Z\[硬件\]; X -- 继续执行其他任务 --> X; Z -- 中断 --> W\[中断处理\]; W -- 通知 --> X; end

为了进一步解放CPU，现代计算机系统引入了**直接内存访问 (Direct Memory Access, DMA)**。

*   对于高速I/O设备（如硬盘、网卡），如果没有DMA，CPU需要一个字节一个字节地把数据从设备控制器的缓冲区搬到内存，这会消耗大量的CPU周期。
*   有了DMA，CPU只需告诉DMA控制器：“请把xxx字节的数据从源地址搬到目标地址”。然后CPU就可以去做别的事了。DMA控制器会自己完成数据传输，并在传输结束后，**只产生一次中断**来通知CPU，而不是每个字节都中断一次。这极大地提高了系统性能。

#### **IV 存储结构与层次**

计算机的存储器不是单一的，而是一个**分层的体系结构 (Storage Hierarchy)**。分层的依据是三个特性：

*   **速度 (Speed)**：越往上越快。
*   **成本 (Cost)**：越往上每字节成本越高。
*   **易失性 (Volatility)**：越往上越容易断电丢失数据。

graph TD direction TB R\[寄存器 Registers\] C\[缓存 Cache\] M\[主内存 Main Memory\] D\[电子磁盘/固态硬盘 SSD\] HD\[磁盘 Magnetic Disk\] O\[光盘 Optical Disk\] T\[磁带 Magnetic Tapes\] R -- 快/贵/小 --> C C --> M M --> D D --> HD HD --> O O -- 慢/便宜/大 --> T style R fill:#ffadad style C fill:#ffd6a5 style M fill:#fdffb6 style D fill:#caffbf style HD fill:#9bf6ff style O fill:#a0c4ff style T fill:#bdb2ff

*   **主内存 (Main Memory)**：通常指DRAM，是CPU能直接访问的大容量存储。它是易失的。
*   **二级存储 (Secondary Storage)**：如硬盘、SSD，用于永久保存数据，是非易失的。

**缓存 (Caching)** 是这个层次结构中最重要的原则。

*   核心思想：将低速存储中常用的数据**复制**一份到高速存储中，以弥合它们之间的速度差异。
*   当CPU需要数据时，它会**首先检查缓存**。
    *   **命中 (Cache Hit)**：如果在缓存中找到了，就直接从缓存中快速读取。
    *   **未命中 (Cache Miss)**：如果没找到，就去下一级存储（如主存）中读取，并**同时将这份数据加载到缓存中**，以便下次快速访问。
*   主内存可以看作是硬盘的缓存；L2缓存是主内存的缓存；L1缓存是L2的缓存。

#### **V 操作系统的核心结构与运行**

**1\. 多道程序设计 (Multiprogramming)**

早期计算机一次只能运行一个程序，当程序需要等待I/O时，CPU就处于空闲状态，造成了极大的浪费。

**多道程序设计**的思想是：在内存中同时存放多个作业（程序和数据）。当一个作业需要等待时（例如等待I/O），操作系统就立即切换到另一个已准备好的作业去执行。这样，CPU就总有事可做，大大提高了**CPU利用率**。

graph TD subgraph 内存布局 OS\[操作系统\] J1\[任务1\] J2\[任务2\] J3\[任务3\] J4\[任务4\] end

**2\. 分时系统 (Timesharing / Multitasking)**

多道程序设计虽然提高了效率，但用户无法与程序进行实时交互。分时是多道程序设计的自然扩展，它的目标是**提供交互性**。

系统将CPU时间分割成非常短的**时间片 (time slice)**，轮流分配给内存中的各个作业。由于切换速度非常快（通常是几十到几百毫秒），每个用户都感觉自己独占了整个计算机，可以实时地与自己的程序进行交互。

*   一个在内存中准备运行的程序，我们称之为**进程 (Process)**。
*   如果内存空间不足以容纳所有待运行的进程，操作系统会使用**交换 (Swapping)** 技术，将暂时不运行的进程换出到硬盘，等需要时再换入内存。
*   **虚拟内存 (Virtual Memory)** 技术则允许我们运行比物理内存还要大的程序。

**3\. 双重模式操作与保护 (Dual-Mode Operation)**

操作系统是系统的管理者，如果一个普通的用户程序可以随意修改操作系统的核心代码，那整个系统很快就会崩溃。因此，必须要有保护机制。

现代CPU提供了硬件级别的支持，即**双重模式**：

*   **内核模式 (Kernel Mode)**：也叫系统模式、特权模式。操作系统内核运行在此模式下，可以执行**所有**指令，访问**所有**内存和硬件。
*   **用户模式 (User Mode)**：用户应用程序运行在此模式下，只能执行**一部分**安全的指令，访问受限的内存区域。像修改时钟、访问硬件等**特权指令 (privileged instructions)** 在此模式下是禁止的。

CPU中有一个**模式位 (mode bit)** 来标识当前处于哪种模式（例如，0代表内核模式，1代表用户模式）。

那么，用户程序如何请求内核的服务呢？答案就是前面提到的**系统调用 (System Call)**。

graph TD subgraph "用户空间 (用户模式, mode bit = 1)" A\[用户进程执行\] --> B{发起系统调用}; E\[从系统调用返回\] --> F\[继续执行\]; end subgraph "内核空间 (内核模式, mode bit = 0)" C(陷阱, 切换到内核模式<br/>mode bit = 0) --> D\[执行系统调用代码\]; D --> R(返回, 切换回用户模式<br/>mode bit = 1); end B -- trap --> C; R -- return --> E; style A fill:#lightblue style B fill:#lightblue style E fill:#lightblue style F fill:#lightblue style C fill:#lightgreen style D fill:#lightgreen style R fill:#lightgreen

当用户进程需要执行特权操作（如读文件）时，它会执行一个特殊的“陷阱”指令，发起系统调用。这会导致CPU硬件自动：

1.  将模式位从1切换到0（进入内核模式）。
2.  跳转到内核中预设好的代码地址开始执行。

内核代表该进程执行完请求的服务后，在返回前，再将模式位从0切换回1，将控制权交还给用户进程。

此外，为了防止用户程序陷入死循环而独占CPU，操作系统会设置一个**定时器 (Timer)**。定时器每隔一段时间就会产生一次**中断**，强制将控制权从用户程序夺回给操作系统，让操作系统可以重新进行调度。

**双重模式**和**定时器中断**是操作系统实现自我保护和控制权掌控的两大基石。

#### **VI 操作系统核心功能概览 (A Grand Tour)**

作为一次“宏观旅行”，我们最后来快速浏览一下操作系统需要管理的核心模块，这些也是我们后续课程将要深入学习的内容：

*   **进程管理 (Process Management)**：负责进程的创建、销毁、暂停、恢复，以及处理进程间的同步、通信和死锁问题。
*   **内存管理 (Memory Management)**：管理内存的分配与回收，记录哪些内存正在被谁使用，以及在进程和内存之间移动数据。
*   **存储管理 (Storage Management)**：
    *   **文件系统管理**：提供统一的、逻辑的视角（文件和目录）来管理信息存储，并控制对文件的访问。
    *   **大容量存储管理**：管理硬盘等二级存储设备，包括磁盘调度、空闲空间管理等。
*   **I/O子系统管理 (I/O Subsystem)**：隐藏不同硬件设备的复杂性，为上层提供统一的接口，并负责设备驱动、缓冲、缓存等。
*   **保护与安全 (Protection and Security)**：
    *   **保护**：控制进程或用户对系统资源的访问权限。
    *   **安全**：抵御来自内部和外部的攻击，如病毒、蠕虫等。