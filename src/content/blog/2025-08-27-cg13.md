---
title: "计算机图形学13:全局光照"
description: ""
pubDate: "2025-08-27"
heroImage: ""
---

# 计算机图形学13:全局光照

### **1\. 为什么需要全局光照？**

局部光照模型有几个无法克服的根本性缺陷：

*   **无法产生阴影：** 物体无法遮挡光线，光会“穿透”所有物体。
*   **没有相互反射：** 场景中的物体都是孤立的，一个物体的颜色不会影响到另一个物体。
*   **无法模拟折射与焦散：** 无法表现透明物体（如水、玻璃）扭曲光线的效果，也无法模拟光线透过透镜汇聚形成的亮斑（焦散）。

要解决这些问题，我们必须跳出“一次光照”的框架，去模拟光线在整个场景中的完整传播路径。这就是全局光照的目标。

### **2\. 阴影 (Shadows)**

阴影可能是全局光照中最直观、最重要的一个元素。它能：

*   **提供空间关系：** 阴影能明确物体与地面（或其他表面）的接触关系，避免物体看起来像“漂浮”在空中。
*   **增强立体感：** 阴影的形状和方向揭示了光源的位置和物体的三维形态。
*   **区分软硬：**
    *   **硬阴影 (Hard Shadows):** 由点光源（无限小的光源）产生，边缘清晰锐利。
    *   **软阴影 (Soft Shadows):** 由面光源（有体积的光源，如窗户、灯管）产生，边缘模糊，有**本影 (Umbra)** 和**半影 (Penumbra)** 的过渡区域。

#### **实时阴影技术：阴影贴图 (Shadow Mapping)**

在实时渲染（如游戏）中，最常用的阴影生成技术是**阴影贴图 (Shadow Mapping)**，也称为Shadow Z-buffering。

*   **核心思想：** 一个点是否在阴影中，取决于**它是否能被光源“看见”**。
*   **算法流程（两步法）：**
    1.  **Pass 1 (从光源视角渲染):**
        *   将虚拟相机移动到**光源的位置**，朝光源的方向看。
        *   对整个场景进行一次渲染。但这次我们不关心颜色，只关心**深度**。我们将渲染出的深度信息存储到一张特殊的纹理中，这张纹理就是**阴影贴图 (Shadow Map)**。阴影贴图的每个像素记录了从光源出发，到达最近物体的距离。
    2.  **Pass 2 (从主相机视角渲染):**
        *   回到主相机的视角，正常渲染场景。
        *   对于场景中的每一个即将被着色的片元（像素），我们将其坐标变换到光源的视角下。
        *   用变换后的坐标去查询第一步生成的阴影贴图，得到一个深度值 $D\_{map}$（光源到最近遮挡物的距离）。
        *   比较该片元自身的深度 $D\_{current}$（光源到当前片元的距离）与 $D\_{map}$。
            *   如果 $D\_{current} > D\_{map}$，说明在光源和当前片元之间，有一个更近的物体挡住了光线。因此，该片元处于**阴影中**，只计算环境光。
            *   否则，该片元被光源照亮，正常进行光照计算。

阴影贴图是实时渲染的基石技术之一，但它也有其局限性，比如容易产生锯齿（需要PCF等技术平滑）、无法很好地处理半透明阴影等。

### **3\. 光线追踪 (Ray Tracing)**

光线追踪是目前能够生成最逼真图像的渲染技术之一，其原理非常优雅。

*   **核心思想：** 与物理世界中光从光源发出，最终进入眼睛相反，我们**从眼睛（相机）出发，反向追踪光线的路径**。
*   **算法流程（经典递归光线追踪）：**
    1.  **主光线 (Primary Ray):** 对于屏幕上的每一个像素，从视点（eye）出发，穿过该像素中心，向场景中发射一条**主光线**。
    2.  **求交 (Intersection):** 计算这条光线与场景中所有物体的交点，找到**最近的那个交点**。如果没有交点，则该像素显示背景色。
    3.  **着色 (Shading):** 在该交点处，进行颜色计算。该点的最终颜色由三部分贡献：
        *   **a. 局部光照：** 从交点向**每一个光源**发射一条**阴影光线 (Shadow Ray)**。如果这条光线在到达光源前没有碰到任何其他物体，则该光源对交点有直接贡献，计算其漫反射和镜面反射。否则，该点处于该光源的阴影中。
        *   **b. 反射光：** 如果交点所在的表面是反射性的（如镜子），则根据反射定律计算出**反射光线 (Reflection Ray)** 的方向，并**递归地**调用光线追踪函数，追踪这条新的光线，将其返回的颜色按材质的反射率叠加到当前颜色上。
        *   **c. 折射光：** 如果表面是透明的（如玻璃），则根据折射定律（斯涅尔定律）计算出**折射光线 (Refraction Ray)** 的方向，并**递归地**调用光线追踪函数，将其返回的颜色按材质的透射率叠加到当前颜色上。
    4.  **递归终止：** 当光线没有碰到任何物体，或递归达到预设的最大深度时，递归返回。

**优点：**

*   **效果逼真：** 能自然地、物理正确地模拟出精确的阴影、镜面反射和折射效果。
*   **对象空间精度：** 计算完全在三维对象空间中进行，结果非常精确。

**缺点：**

*   **计算量巨大：** 每条光线都可能需要与场景中所有物体进行求交测试，且递归会产生大量的次生光线，计算成本极高，传统上难以实时运行。
*   **不擅长模拟漫反射间的相互作用** (Color Bleeding)。

### **4\. 辐射度 (Radiosity)**

辐射度算法与光线追踪正好相反，它专注于完美地模拟光线在**漫反射**表面之间的相互作用。

*   **核心思想：** 基于热辐射传导的物理原理，它不追踪单条光线，而是计算场景中**面片 (Patch)** 之间能量的相互传递。它假设所有表面都是**理想漫反射体 (Lambertian)**。
*   **算法流程：**
    1.  **离散化：** 将场景中的所有表面剖分成许多小的面片。
    2.  **计算形状因子 (Form Factors):** 对于任意两个面片 $i$ 和 $j$，计算一个**形状因子** $F\_{ij}$，它表示从面片 $i$ 发出的能量中，有多少比例会直接到达面片 $j$。这个计算是纯粹的几何问题，非常耗时。
    3.  **建立方程组：** 为每个面片建立一个能量平衡方程，描述它射出的总能量（Radiosity）等于它自身发出的能量加上从所有其他面片接收并反射的能量。这将形成一个巨大的线性方程组。
    4.  **求解：** 求解这个方程组，得到每个面片最终的、稳定的光照强度（颜色）。
*   **特点：**
    *   **视点无关 (View-Independent):** 计算结果是场景中每个面的固有光照，与观察者位置无关。计算一次后，可以从任意角度快速漫游浏览。
    *   **效果柔和真实：** 能完美模拟漫反射表面间的颜色渗透（Color Bleeding）和极其柔和的软阴影。非常适合渲染室内建筑、艺术馆等场景。

**优点：**

*   能产生物理精确的柔和光照效果。
*   计算结果与视点无关。

**缺点：**

*   **只能处理漫反射：** 无法模拟镜面反射和高光。
*   **预处理计算量大：** 计算形状因子和求解方程组非常耗时。
*   **不适用于动态场景。**

### **5\. 两大技术的融合与未来**

光线追踪和辐射度各有擅长，它们像是全局光照的“一体两面”：

特性

光线追踪 (Ray Tracing)

辐射度 (Radiosity)

**擅长**

镜面反射、折射、硬阴影

漫反射、颜色渗透、软阴影

**视点关系**

视点相关

视点无关

**核心**

追踪光线

计算能量平衡

为了结合两者的优点，人们发展出了许多**混合渲染技术**，如**双向路径追踪 (Bidirectional Path Tracing)**、**光子映射 (Photon Mapping)** 等，它们同时模拟漫反射和镜面反射，是当今离线渲染（如电影特效）领域的主流。

随着NVIDIA RTX等实时光线追踪硬件的出现，曾经遥不可及的光线追踪技术正逐步进入实时游戏领域，通常与传统的光栅化渲染相结合，用于生成高质量的阴影、反射和全局光照效果，标志着实时渲染正向着电影级画质的目标大步迈进。