---
title: "数值分析01:有限位数表达、误差传递和收敛性"
description: ""
pubDate: "2025-08-27"
heroImage: ""
---

# 数值分析01:有限位数表达、误差传递和收敛性

### **引言：为何需要数值分析？**

当我们试图将数学理论应用于解决复杂的工程、金融或科学问题时，会遇到两个核心挑战：

1.  **理论上的不可解性：** 许多问题，尽管在理论上存在解，但无法用初等函数表示出来。一个经典的例子就是我们今天将要讨论的积分 $\\int\_{0}^{1} e^{-x^2} dx$。它的原函数无法用我们熟悉的函数（如多项式、三角函数、指数函数）表示。
2.  **实践中的不可行性：** 即使问题有精确的解析解，例如求解一个大型的线性方程组，当维度达到数万甚至数百万时，手动计算或使用解析方法（如克莱姆法则）的计算量是天文数字，完全不现实。

这时，**计算机**成为了我们最强大的工具。但计算机有其固有的局限性：

*   **离散性 (Discreteness):** 计算机只能处理离散的数据，而数学理论中的变量通常是连续的。
*   **有限性 (Finiteness):** 计算机的内存和存储空间是有限的，它无法表示无限长的数字（如 $\\pi$ 或 $\\sqrt{2}$），也无法执行无限多次的运算（如无穷级数求和）。

**数值分析 (Numerical Analysis)** 正是连接**连续的数学理论**与**离散的、有限的计算机**之间的桥梁。它研究如何设计、分析和实现算法，用计算机来近似解决数学问题。

课程的核心，就是围绕着“**近似**”这个词展开。只要有近似，就必然会产生**误差 (Error)**。我们这堂课的目标，就是要理解误差的来源、如何度量它、它如何传播，以及我们如何设计出“好”的算法来控制误差，确保我们得到的近似解是可靠和有意义的。

今天，我们将从最基础也是最核心的三个概念入手：

1.  **有限位数表达 (Finite-digit Representation):** 计算机是如何表示数字的，这直接导致了**舍入误差**。
2.  **误差的产生与传播 (Error Generation and Propagation):** 探讨另一类主要误差——**截断误差**，并分析在计算过程中误差是如何累积和放大的。
3.  **算法的稳定性与收敛性 (Algorithm Stability and Convergence):** 衡量一个数值算法好坏的关键标准。

### **第一部分：误差的两种主要来源**

#### **1.1 案例分析：近似计算高斯积分**

考虑一个在统计学和物理学中非常重要的积分，正态分布的概率密度函数就与它有关：

**讨论 1: 近似计算 $\\int\_{0}^{1} e^{-x^2} dx$ 的值。**

我们知道这个积分的精确值大约是 $0.746824...$。但正如前面提到的，我们找不到 $e^{-x^2}$ 的初等原函数。那么，我们如何用计算机来计算它呢？

**解决方案：** 一个强大的工具是泰勒展开。我们知道 $e^u$ 在 $u=0$ 处的麦克劳林级数是： $$e^u = 1 + u + \\frac{u^2}{2!} + \\frac{u^3}{3!} + \\dots = \\sum\_{k=0}^{\\infty} \\frac{u^k}{k!}$$

将 $u = -x^2$ 代入，我们得到 $e^{-x^2}$ 的泰勒级数： $$e^{-x^2} = 1 - x^2 + \\frac{(-x^2)^2}{2!} + \\frac{(-x^2)^3}{3!} + \\frac{(-x^2)^4}{4!} + \\dots$$ $$e^{-x^2} = 1 - x^2 + \\frac{x^4}{2!} - \\frac{x^6}{3!} + \\frac{x^8}{4!} - \\dots = \\sum\_{k=0}^{\\infty} \\frac{(-1)^k x^{2k}}{k!}$$

这个级数在整个实数域上收敛。我们可以对这个级数进行逐项积分（因为在收敛域内这是允许的）：

$$\\begin{aligned} \\int\_{0}^{1} e^{-x^2} dx &= \\int\_{0}^{1} \\left( 1 - x^2 + \\frac{x^4}{2!} - \\frac{x^6}{3!} + \\frac{x^8}{4!} - \\dots \\right) dx \\\\ &= \\left\[ x - \\frac{x^3}{3} + \\frac{x^5}{5 \\cdot 2!} - \\frac{x^7}{7 \\cdot 3!} + \\frac{x^9}{9 \\cdot 4!} - \\dots \\right\]\_{0}^{1} \\\\ &= 1 - \\frac{1}{3} + \\frac{1}{5 \\cdot 2!} - \\frac{1}{7 \\cdot 3!} + \\frac{1}{9 \\cdot 4!} - \\dots \\\\ &= 1 - \\frac{1}{3} + \\frac{1}{10} - \\frac{1}{42} + \\frac{1}{216} - \\dots \\end{aligned} $$

这是一个交错级数。现在，我们面临了计算机的“有限性”挑战：我们不可能计算无穷多项的和。我们必须在某处**截断 (truncate)** 这个级数。

假设我们只取前4项来近似这个积分： $$S\_4 = 1 - \\frac{1}{3} + \\frac{1}{10} - \\frac{1}{42}$$

这个近似值与真实值之间的差异，就是第一种主要误差。

#### **1.2 截断误差 (Truncation Error)**

**定义：** 截断误差是由于使用有限的过程（例如，有限项求和、有限步迭代）来近似一个无限过程而产生的误差。它本质上是**数学方法本身的近似**所带来的误差。

在我们的例子中，截断误差就是被我们“扔掉”的尾巴，即余项 $R\_4$： $$R\_4 = \\int\_{0}^{1} \\left( \\frac{x^8}{4!} - \\frac{x^{10}}{5!} + \\dots \\right) dx = \\frac{1}{9 \\cdot 4!} - \\frac{1}{11 \\cdot 5!} + \\dots$$

对于收敛的交错级数，其误差的绝对值小于被截断的第一项的绝对值。因此，我们可以估计截断误差的大小： $$|R\_4| = \\left| \\frac{1}{216} - \\frac{1}{1320} + \\dots \\right| < \\frac{1}{9 \\cdot 4!} = \\frac{1}{9 \\cdot 24} = \\frac{1}{216} \\approx 0.0046$$

这意味着，如果我们能精确计算 $S\_4$，那么我们的结果与真实值的差距不会超过 $0.0046$。

现在，让我们来计算 $S\_4$ 的值： $$S\_4 = 1 - \\frac{1}{3} + \\frac{1}{10} - \\frac{1}{42}$$

这里就出现了第二种误差。当我们用计算器或计算机计算这些分数时，例如 $\\frac{1}{3} = 0.33333...$，我们必须在某个位置进行取舍。

假设我们使用3位小数进行计算： $$S\_4 \\approx 1 - 0.333 + 0.100 - 0.024 = 0.743$$

这个 $0.743$ 与 $S\_4$ 的精确值 $1 - \\frac{1}{3} + \\frac{1}{10} - \\frac{1}{42} = \\frac{311}{420} \\approx 0.74047...$ 之间的差异，就是第二种主要误差。

#### **1.3 舍入误差 (Roundoff Error)**

**定义：** 舍入误差是由于计算机使用有限的位数（或数字）来表示实数而产生的误差。它是**计算机硬件的局限性**所带来的误差。

在上面的计算中，将 $\\frac{1}{3}$ 表示为 $0.333$，将 $\\frac{1}{42}$ 表示为 $0.024$，都引入了舍入误差。这些小的误差在后续的加减运算中会累积起来。

**总结一下：**

*   **截断误差**：我们选择的**数学模型**（用前4项代替无穷级数）与**真实问题**之间的误差。
*   **舍入误差**：我们使用的**计算机表示**（3位小数）与**数学模型中的精确数**（如 $1/3$）之间的误差。

总误差是这两者之和（以及它们之间复杂的相互作用）： **总误差 = 真实值 - 计算值 = (真实值 - 数学模型) + (数学模型 - 计算值) = 截断误差 + 舍入误差**

核心思想：**数值计算中的误差总是由这两种来源共同作用的结果。**

### **第二部分：计算机中的数字表示与舍入误差分析**

为了深入理解舍入误差，我们必须了解计算机是如何存储数字的。

#### **2.1 浮点表示法 (Floating-Point Form)**

任何一个非零实数 $y$ 都可以表示为**规范化的十进制浮点形式**： $$y = \\pm 0.d\_1d\_2...d\_k... \\times 10^n$$ 其中 $d\_1, d\_2, ...$ 是 $0$ 到 $9$ 之间的整数，且为了表示的唯一性，我们要求 $d\_1 \\neq 0$（这被称为**规范化**）。

*   $\\pm$ 是**符号 (Sign)**。
*   $0.d\_1d\_2...d\_k...$ 是**尾数 (Mantissa or Significand)**。
*   $n$ 是**指数 (Exponent)**。

计算机内部存储数字的位数是有限的。一个**k位十进制机器数**指的是尾数只能存储 $k$ 位数字。 $$\\hat{y} = \\pm 0.d\_1d\_2...d\_k \\times 10^n$$

**重要拓展：** 实际的计算机内部使用二进制，遵循 **IEEE 754 标准**。例如，一个64位的**双精度 (double precision)** 浮点数，它分配1位给符号，11位给指数，剩下的52位给尾数。我们这里为了教学方便，使用十进制进行讨论，其原理是完全相通的。

当一个实数 $y = 0.d\_1d\_2...d\_kd\_{k+1}... \\times 10^n$ 需要被存入一个只能存 $k$ 位尾数的机器时，就必须进行取舍。主要有两种方式：

**1\. 截断 (Chopping):** 直接丢掉第 $k+1$ 位以及之后的所有数字。 $$fl\_{chop}(y) = 0.d\_1d\_2...d\_k \\times 10^n$$

**2\. 四舍五入 (Rounding):** 检查第 $k+1$ 位数字 $d\_{k+1}$。

*   如果 $d\_{k+1} < 5$，则执行截断。
*   如果 $d\_{k+1} \\geq 5$，则在第 $k$ 位上加1（这可能导致进位），然后截断。 一个巧妙的实现方式是： $$fl\_{round}(y) = \\text{chop}(y + 5 \\times 10^{n-(k+1)})$$

**示例：** 将 $\\pi \\approx 0.31415926... \\times 10^1$ 用5位十进制机器数表示。

*   **截断:** $fl\_{chop}(\\pi) = 0.31415 \\times 10^1$
*   **四舍五入:** 第6位是9（$\\geq 5$），所以第5位加1。$fl\_{round}(\\pi) = 0.31416 \\times 10^1$。 显然，四舍五入通常更精确。

#### **2.2 误差的度量：绝对误差与相对误差**

假设 $p$ 是精确值，$p^\*$ 是它的近似值。

**定义：**

*   **绝对误差 (Absolute Error):** $E\_{abs} = |p - p^\*|$
*   **相对误差 (Relative Error):** $E\_{rel} = \\frac{|p - p^\*|}{|p|}$ (要求 $p \\neq 0$)

**为什么相对误差更重要？** 相对误差是无量纲的，它衡量了误差相对于真实值的大小。

*   **例子1：** 测量一张桌子的长度，真实值是1.50米，测量值是1.60米。绝对误差是0.1米，相对误差是 $\\frac{0.1}{1.50} \\approx 6.7%$。这个误差很显著。
*   **例子2：** 测量地球到月球的距离，真实值约384,400公里，测量值是384,500公里。绝对误差是100公里，非常大！但相对误差是 $\\frac{100}{384400} \\approx 0.026%$，非常小。

相对误差更能反映近似的“质量”。

#### **2.3 舍入误差的界**

我们可以为截断和四舍五入两种方式产生的相对误差给出一个上界。 设 $y = 0.d\_1d\_2...d\_kd\_{k+1}... \\times 10^n$。

**1\. 截断 (Chopping):** $$|y - fl\_{chop}(y)| = |0.00...0d\_{k+1}d\_{k+2}... \\times 10^n| = 0.d\_{k+1}d\_{k+2}... \\times 10^{n-k}$$ 由于 $0.d\_{k+1}d\_{k+2}... < 1$，所以 $|y - fl\_{chop}(y)| < 1 \\times 10^{n-k}$。 相对误差为： $$\\frac{|y - fl\_{chop}(y)|}{|y|} = \\frac{0.d\_{k+1}d\_{k+2}... \\times 10^{n-k}}{|0.d\_1d\_2... \\times 10^n|} = \\frac{0.d\_{k+1}d\_{k+2}...}{0.d\_1d\_2...} \\times 10^{-k}$$ 因为 $y$ 是规范化的，所以 $0.d\_1d\_2... \\ge 0.1$。因此： $$E\_{rel} \\le \\frac{1}{0.1} \\times 10^{-k} = 10^{-k+1}$$

**2\. 四舍五入 (Rounding):** 通过类似分析，无论是向上还是向下取整，误差的绝对值都不会超过“半个单位”。 $$|y - fl\_{round}(y)| \\le \\frac{1}{2} \\times 10^{n-k}$$ 相对误差为： $$E\_{rel} = \\frac{|y - fl\_{round}(y)|}{|y|} \\le \\frac{0.5 \\times 10^{n-k}}{|0.d\_1d\_2... \\times 10^n|} \\le \\frac{0.5}{0.1} \\times 10^{-k} = 0.5 \\times 10^{-k+1}$$

**结论：** 四舍五入的误差上界是截断的一半。这就是为什么在科学计算中，默认的舍入方式几乎总是四舍五入。这个 $10^{-k+1}$ 或 $0.5 \\times 10^{-k+1}$ 也被称为**机器精度 (Machine Epsilon)** 的一个度量。

#### **2.4 有效数字 (Significant Digits)**

**定义：** 若 $p^\*$ 是 $p$ 的近似值，我们说 $p^\*$ 对 $p$ 有 $t$ 位有效数字，如果 $t$ 是满足下式的最大非负整数： $$\\frac{|p - p^\*|}{|p|} < 5 \\times 10^{-t}$$

这个定义直观地将相对误差与我们熟悉的“有效数字”概念联系起来。例如，如果相对误差小于 $5 \\times 10^{-4}$，我们至少可以说这个近似有3位有效数字。

### **第三部分：灾难性的舍入误差——有效数字的损失**

舍入误差本身通常很小。然而，在某些特定的算术运算中，它会被急剧放大，导致灾难性的后果。

#### **3.1 相近数相减**

**核心问题：** 两个非常接近的数字相减，会导致有效数字的严重损失。

**示例:** 设 $a\_1 = 0.12345$ 和 $a\_2 = 0.12346$。假设这是两个用5位浮点数精确表示的数字，它们都有5位有效数字。 计算它们的差： $$a\_2 - a\_1 = 0.12346 - 0.12345 = 0.00001$$ 这个结果可以写成规范化的浮点数 $0.1 \\times 10^{-4}$。

**发生了什么？** 原始数字的前4位有效数字 ($1, 2, 3, 4$) 在相减过程中完全抵消了。结果 $0.00001$ 中的前4个0只是占位符，不携带信息。真正有意义的数字只剩下最后一位 ‘1’。我们从两个拥有5位有效信息的数字，得到了一个只拥有1位有效信息的数字。

**关键点：** 这不是说减法本身有错，而是如果原始的 $a\_1$ 和 $a\_2$ 本身就是近似值（例如，它们是经过舍入得到的），那么它们末尾的数字可能是不准确的。 假设 $a\_1$ 的真实值是 $0.123451...$，$a\_2$ 的真实值是 $0.123459...$。 $a\_1$ 被舍入为 $0.12345$，$a\_2$ 被舍入为 $0.12346$。 它们的真实差值是 $0.000008...$。 而我们用近似值计算的差是 $0.00001$。 相对误差为 $\\frac{|0.00001 - 0.000008|}{|0.000008|} = \\frac{0.000002}{0.000008} = 25%$！ 一个微小的初始舍入误差，在相近数相减后，被放大了成百上千倍。

**记住：** 在数值计算中，要**极力避免两个大小相近的数直接相减**。如果不可避免，通常需要对公式进行代数变形。

#### **3.2 案例研究：求解一元二次方程**

这是一个展示如何避免有效数字损失的经典例子。

**研究课题 1: 求解二次方程 $ax^2 + bx + c = 0$。以 $x^2 + 62.10x + 1 = 0$ 为例，假设我们使用4位有效数字的四舍五入算术。**

我们都熟悉求根公式： $$x\_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$

这里，$a=1, b=62.10, c=1$。 首先计算判别式中的项：

*   $b^2 = (62.10)^2 = 3856.41$。四舍五入到4位，我们得到 $3856$。
*   $4ac = 4 \\times 1 \\times 1 = 4$。
*   $b^2 - 4ac \\approx 3856 - 4 = 3852$。
*   $\\sqrt{b^2 - 4ac} \\approx \\sqrt{3852}$。计算器给出 $62.06448...$。四舍五入到4位，得到 $62.06$。

现在，我们计算两个根： $$x\_1 = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} \\approx \\frac{-62.10 + 62.06}{2} = \\frac{-0.04}{2} = -0.0200$$

这里发生了什么？$-62.10$ 和 $62.06$ 是两个非常接近的数！它们的相减导致了严重的有效数字损失。我们得到的 $-0.04$ 很可能是不准确的。

$$x\_2 = \\frac{-b - \\sqrt{b^2 - 4ac}}{2a} \\approx \\frac{-62.10 - 62.06}{2} = \\frac{-124.16}{2} = -62.08$$ 这个计算是两个负数相加，没有相近数相减的问题，所以这个根 $x\_2$ 应该是比较准确的。

**如何改进？** 我们的目标是避免计算 $x\_1$ 时的相减操作。我们可以利用韦达定理： $$x\_1 \\cdot x\_2 = \\frac{c}{a}$$

**更优的算法：**

1.  首先，计算符号不会抵消的那个根。当 $b>0$ 时，这是 $x\_2$。当 $b<0$ 时，这将是 $x\_1$。总之，是分子中加号（或减去一个负数）的那个。 $x\_2 = \\frac{-b - \\text{sgn}(b)\\sqrt{b^2 - 4ac}}{2a} \\approx -62.08$ (这里 sgn(b)=+1)
2.  然后，利用韦达定理计算另一个根： $x\_1 = \\frac{c}{a \\cdot x\_2} \\approx \\frac{1}{1 \\times (-62.08)} = -0.016108...$ 四舍五入到4位，得到 $x\_1 \\approx -0.01611$。

**对比结果：**

*   **传统方法:** $x\_1 \\approx -0.0200$
*   **改进方法:** $x\_1 \\approx -0.01611$
*   **精确解 (更高精度计算):** $x\_1 \\approx -0.0161072...$, $x\_2 \\approx -62.0839...$

可以看到，改进后的算法得到的 $x\_1$ 精确得多。这是一个完美的例子，说明**好的数值算法不仅仅是把数学公式直接翻译成代码，而是要预见到并规避数值陷阱。**

#### **3.3 案例研究：多项式求值**

**讨论 2: 计算 $f(x) = x^3 - 6.1x^2 + 3.2x + 1.5$ 在 $x=4.71$ 处的值，使用3位数字算术。**

**精确值：** $$ \\begin{aligned} f(4.71) &= (4.71)^3 - 6.1(4.71)^2 + 3.2(4.71) + 1.5 \\\\ &= 104.487111 - 6.1(22.1841) + 15.072 + 1.5 \\\\ &= 104.487111 - 135.32301 + 15.072 + 1.5 = -14.263899 \\end{aligned} $$

**方法一：直接计算 (使用3位截断算术)**

1.  $x = 4.71$
2.  $x^2 = (4.71)^2 = 22.1841 \\rightarrow 22.1$ (截断)
3.  $x^3 = x \\cdot x^2 \\approx 4.71 \\times 22.1 = 104.091 \\rightarrow 104.$
4.  $6.1x^2 \\approx 6.1 \\times 22.1 = 134.81 \\rightarrow 134.$
5.  $3.2x \\approx 3.2 \\times 4.71 = 15.072 \\rightarrow 15.0$
6.  $f(4.71) \\approx (104. - 134.) + 15.0 + 1.5 = -30.0 + 15.0 + 1.5 = -13.5$ **相对误差：** $\\frac{|-13.5 - (-14.26)|}{|-14.26|} \\approx 5.3%$

**方法二：秦九韶算法 (Horner's Method)** 这是评估多项式的一种非常高效且数值稳定的方法。它的思想是嵌套乘法。 $f(x) = x^3 - 6.1x^2 + 3.2x + 1.5 = ((x - 6.1)x + 3.2)x + 1.5$

**使用3位截断算术计算：**

1.  $x - 6.1 = 4.71 - 6.1 = -1.39$
2.  $(x - 6.1)x \\approx -1.39 \\times 4.71 = -6.5469 \\rightarrow -6.54$
3.  $((x - 6.1)x + 3.2) \\approx -6.54 + 3.2 = -3.34$
4.  $f(x) \\approx -3.34 \\times 4.71 + 1.5 = -15.7314 + 1.5 \\rightarrow -15.7 + 1.5 = -14.2$ **相对误差：** $\\frac{|-14.2 - (-14.26)|}{|-14.26|} \\approx 0.42%$

**结论：** 秦九韶算法需要的乘法次数更少（2次 vs 3次），加法/减法次数相同，但最重要的是，它减少了中间步骤的舍入次数，并且避免了计算非常大的数（如 $x^3$）再减去另一个大数，从而有效地控制了舍入误差的累积。

### **第四部分：算法的稳定性**

我们已经看到，对于同一个问题，不同的算法可能会得到精度迥异的结果。这引出了一个核心概念：**算法的稳定性**。

#### **4.1 稳定性的定义**

**定义：**

*   一个算法被称为**稳定的 (Stable)**，如果初始数据的微小改变（例如，由于舍入误差）只导致最终结果的微小改变。
*   如果初始数据的微小改变会导致最终结果的巨大改变，则称该算法是**不稳定的 (Unstable)**。
*   如果一个算法只对某些特定的初始数据选择是稳定的，则称其为**条件稳定的 (Conditionally Stable)**。

**误差的增长方式：** 假设 $E\_0$ 是初始误差， $E\_n$ 是经过 $n$ 步运算后的误差。

*   **线性增长 (Linear Growth):** 如果 $E\_n \\approx C \\cdot n \\cdot E\_0$（其中 $C$ 是一个常数），这种增长通常是可接受的。
*   **指数增长 (Exponential Growth):** 如果 $E\_n \\approx C^n \\cdot E\_0$（其中 $C > 1$），这种增长是灾难性的，它意味着误差会迅速淹没真实信号。这样的算法是不稳定的。

#### **4.2 案例研究：一个递推关系的两种算法**

**问题：** 计算积分序列 $I\_n = \\frac{1}{e} \\int\_{0}^{1} x^n e^x dx$ 对于 $n=0, 1, 2, ...$

首先，我们可以通过分部积分法得到一个递推关系： $$I\_n = \\frac{1}{e} \\left\[ \[x^n e^x\]\_0^1 - \\int\_0^1 n x^{n-1} e^x dx \\right\] = \\frac{1}{e} \[e - n \\cdot e \\cdot I\_{n-1}\] = 1 - n I\_{n-1}$$

我们可以计算出 $I\_0$： $$I\_0 = \\frac{1}{e} \\int\_0^1 e^x dx = \\frac{1}{e} \[e^x\]\_0^1 = \\frac{e-1}{e} = 1 - \\frac{1}{e} \\approx 0.63212056$$

另外，我们注意到 $x^n$ 在 $\[0,1\]$ 上是递增的，$e^x$ 也是。所以 $I\_n$ 应该是正的，并且随着 $n$ 增大，$x^n$ 在大部分区间更接近0，所以 $I\_n$ 应该是递减的。

**方法一：正向递推 (Forward Recurrence)** 使用公式 $I\_n = 1 - n I\_{n-1}$。 假设我们使用的 $I\_0^\*$ 是一个近似值，带有初始误差 $E\_0 = I\_0 - I\_0^\*$。

*   $I\_1^\* = 1 - 1 \\cdot I\_0^\* \\approx 0.36787944$
*   $I\_2^\* = 1 - 2 \\cdot I\_1^\* \\approx 1 - 2(0.36787944) = 0.26424112$ ...
*   $I\_{10}^\* = 1 - 10 \\cdot I\_9^\* \\approx 0.08812800$
*   $I\_{11}^\* = 1 - 11 \\cdot I\_{10}^\* \\approx 0.03059200$
*   $I\_{12}^\* = 1 - 12 \\cdot I\_{11}^\* \\approx 0.63289600$ **(变大)**
*   $I\_{13}^\* = 1 - 13 \\cdot I\_{12}^\* \\approx -7.2276480$ **(变成负数)**
*   $I\_{15}^\* \\approx -1423.3914$

我们来分析误差传播： $$E\_n = I\_n - I\_n^\* = (1 - n I\_{n-1}) - (1 - n I\_{n-1}^\*) = n(I\_{n-1}^\* - I\_{n-1}) = -n E\_{n-1}$$ 所以，$|E\_n| = n |E\_{n-1}| = n(n-1)|E\_{n-2}| = \\dots = n!|E\_0|$。

误差以**阶乘 (Factorial)** 的速度增长！这比指数增长还要快。任何微小的初始舍入误差 $E\_0$ 都会被迅速放大到毁灭性的程度。因此，**正向递推算法是极度不稳定的**。

**方法二：反向递推 (Backward Recurrence)** 我们将递推公式变形： $I\_{n-1} = \\frac{1 - I\_n}{n}$ 这个公式让我们能从 $I\_n$ 计算出 $I\_{n-1}$。 我们可以从一个很大的 $N$ 开始，然后往回计算 $I\_{N-1}, I\_{N-2}, \\dots, I\_0$。 但我们需要一个 $I\_N$ 的初始值。我们知道 $I\_n \\to 0$ 当 $n \\to \\infty$。 我们可以做一个合理的猜测，例如，取 $N=20$，并假设 $I\_{20}^\* = 0$。

我们来分析这种方法的误差传播。假设 $I\_N$ 的真实值与我们的猜测 $I\_N^\*$ 之间存在误差 $E\_N = I\_N - I\_N^\*$。 $$E\_{N-1} = I\_{N-1} - I\_{N-1}^\* = \\frac{1-I\_N}{N} - \\frac{1-I\_N^\*}{N} = \\frac{I\_N^\* - I\_N}{N} = -\\frac{E\_N}{N}$$ $$|E\_{N-1}| = \\frac{|E\_N|}{N}$$ $$|E\_{N-2}| = \\frac{|E\_{N-1}|}{N-1} = \\frac{|E\_N|}{N(N-1)}$$ $$...$$ $$|E\_n| = \\frac{|E\_N|}{N(N-1)...(n+1)}$$

初始的误差 $E\_N$ 在每一步反向递推中都被**除以**一个越来越大的数。误差被迅速地**衰减**了！ 即使我们对 $I\_N$ 的初始猜测很不准确（例如，设 $I\_{20}^\*=0$ 而真实值可能是 $0.01$），这个初始误差在反向计算到 $I\_{10}, I\_9, ...$ 时，其影响已经小到可以忽略不计。

**这就是一个稳定的算法。** 它对初始值的微小（甚至不那么微小）的扰动具有“自我修正”的能力。

### **第五部分：课程总结**

**本讲核心要点回顾：**

1.  **误差无处不在：** 数值计算的误差主要来源于**截断误差**（数学方法的近似）和**舍入误差**（计算机有限表示）。
2.  **警惕有效数字损失：** **相近数相减**是数值计算中的头号“杀手”，会导致舍入误差的灾难性放大。务必通过代数变形等手段规避它。
3.  **算法的选择至关重要：** 同样一个问题，可能有多种数值算法。一个**稳定**的算法能够抑制误差的传播，而一个**不稳定**的算法会使误差失控，导致结果毫无意义。我们通过二次方程求根、多项式求值和递推关系三个案例深刻体会了这一点。
4.  **数值分析的思维方式：** 不仅仅是实现数学公式，更是要分析算法的数值特性，特别是它对误差的敏感度。

**作业预览：Lab 01 - 数值级数求和** **问题：** 制作一个表格，计算函数 $\\psi(x) = \\sum\_{k=1}^{\\infty} \\frac{1}{k(k+x)}$ 在 $x = 0.0, 0.1, 0.2, \\dots, 300.00$ 共3001个点上的值。要求所有计算结果的**绝对误差小于 $1.0 \\times 10^{-10}$**。

**思考与挑战：**

1.  这是一个无穷级数，你必须**截断**它。你需要计算多少项才能保证截断误差小于 $10^{-10}$？
2.  你需要分析余项 $R\_N(x) = \\sum\_{k=N+1}^{\\infty} \\frac{1}{k(k+x)}$。如何有效地估计这个余项的上界，从而确定需要计算的项数 $N$？
3.  对于不同的 $x$ 值，$N$ 会是相同的吗？
4.  在求和过程中，累加的顺序会影响最终的舍入误差吗？（提示：将一堆小数相加时，从最小的数开始加，通常能得到更精确的结果。）

#### 解答方案：数值级数求和

##### **1\. 问题重述与分析**

**目标：** 计算函数 $\\psi(x) = \\sum\_{k=1}^{\\infty} \\frac{1}{k(k+x)}$ 在 $x \\in \[0.0, 0.1, \\dots, 300.00\]$ 上的3001个值，并确保每个值的**绝对误差**小于 $\\epsilon = 1.0 \\times 10^{-10}$。

**核心挑战：**

1.  **无穷级数：** 计算机无法进行无穷次运算。我们必须用一个有限和 $S\_N(x) = \\sum\\limits\_{k=1}^{N} \\frac{1}{k(k+x)}$ 来近似 $\\psi(x)$。
2.  **截断误差控制：** 我们必须选择一个足够大的 $N$，使得截断误差 $R\_N(x) = \\psi(x) - S\_N(x) = \\sum\\limits\_{k=N+1}^{\\infty} \\frac{1}{k(k+x)}$ 的绝对值小于给定的容差 $\\epsilon$。
3.  **计算效率：** 1秒的时间限制意味着我们不能让 $N$ 大到不切实际的程度。
4.  **数值稳定性：** 计算过程中需要避免舍入误差的过度累积。

##### **2\. 初步尝试：直接求和法及其局限性**

最直接的想法是：选择一个足够大的 $N$，然后直接计算 $S\_N(x)$。关键在于如何确定 $N$。

**截断误差估计：** 我们需要为 $R\_N(x)$ 找一个上界。对于一个正项、单调递减的级数，我们可以使用积分来估计其尾项和： $$R\_N(x) = \\sum\_{k=N+1}^{\\infty} \\frac{1}{k(k+x)} < \\int\_{N}^{\\infty} \\frac{1}{t(t+x)} dt$$

这个积分可以通过部分分式分解来求解： $\\frac{1}{t(t+x)} = \\frac{1}{x} \\left( \\frac{1}{t} - \\frac{1}{t+x} \\right)$ (假设 $x \\neq 0$)

$$ \\begin{aligned} \\int\_{N}^{\\infty} \\frac{1}{x} \\left( \\frac{1}{t} - \\frac{1}{t+x} \\right) dt &= \\frac{1}{x} \\left\[ \\ln(t) - \\ln(t+x) \\right\]\_{N}^{\\infty} \\\\ &= \\frac{1}{x} \\left\[ \\ln\\left(\\frac{t}{t+x}\\right) \\right\]\_{N}^{\\infty} = \\frac{1}{x} \\left( \\ln(1) - \\ln\\left(\\frac{N}{N+x}\\right) \\right) \\\\ &= \\frac{1}{x} \\ln\\left(\\frac{N+x}{N}\\right) = \\frac{1}{x} \\ln\\left(1 + \\frac{x}{N}\\right) \\end{aligned} $$

所以，我们必须选择 $N$，使得对于所有 $x \\in \[0.1, 300.00\]$，都满足： $$\\frac{1}{x} \\ln\\left(1 + \\frac{x}{N}\\right) < \\epsilon = 10^{-10}$$

**分析这个条件：** 当 $N$ 很大时，$x/N$ 很小，我们可以使用泰勒展开 $\\ln(1+u) \\approx u$。 $$R\_N(x) < \\frac{1}{x} \\left( \\frac{x}{N} \\right) = \\frac{1}{N}$$

这意味着，为了满足误差要求，我们需要 $\\frac{1}{N} < 10^{-10}$，即 $N > 10^{10}$。

**结论：** 直接求和需要计算超过一百亿项！这在1秒内是绝对不可能完成的。**直接求和法不可行。** 这个问题的设计初衷就是为了说明，一个看似简单的方法在数值上可能是灾难性的。

##### **3\. 改进策略：带积分修正的求和法**

既然直接求和收敛太慢，我们可以换一个思路：只对级数的前一部分（例如 $N$ 项）进行直接求和，而用更精确的积分值来**近似**级数的尾部。

**新近似公式：** $$\\psi(x) \\approx S\_N(x) + \\int\_{N}^{\\infty} \\frac{1}{t(t+x)} dt$$ $$\\psi(x) \\approx \\sum\_{k=1}^{N} \\frac{1}{k(k+x)} + \\frac{1}{x} \\ln\\left(1 + \\frac{x}{N}\\right)$$

**新方法的误差分析：** 现在，这个新方法的误差是级数尾项和积分尾项的差： $$E\_{new} = \\left| R\_N(x) - \\int\_{N}^{\\infty} \\frac{1}{t(t+x)} dt \\right| = \\left| \\sum\_{k=N+1}^{\\infty} f(k) - \\int\_{N}^{\\infty} f(t) dt \\right|$$ 其中 $f(t) = \\frac{1}{t(t+x)}$。

根据**欧拉-麦克劳林公式 (Euler-Maclaurin formula)** 的第一项，这个误差可以被很好地近似： $$E\_{new} \\approx \\frac{1}{2} f(N) = \\frac{1}{2N(N+x)}$$

为了得到一个不依赖于 $x$ 的、适用于所有情况的 $N$，我们取其上界： $$E\_{new} < \\frac{1}{2N(N+0)} = \\frac{1}{2N^2}$$

现在，我们用这个新的误差界来确定 $N$： $$\\frac{1}{2N^2} < \\epsilon = 10^{-10}$$ $$\\Longleftrightarrow N^2 > \\frac{1}{2 \\times 10^{-10}} = 0.5 \\times 10^{10}$$ $$\\Longleftrightarrow N > \\sqrt{0.5 \\times 10^{10}} \\approx 70710.67$$

**结论：** 我们可以选择一个固定的、稍大一点的整数，例如 $N=71000$ 或者更保险的 $N=100000$。这个计算量（十万次循环）对于现代计算机来说是瞬时完成的。这个方法是可行的。

##### **4\. 最终算法设计**

**特殊情况处理：**

*   **当 $x = 0.0$ 时：** $$\\psi(0) = \\sum\_{k=1}^{\\infty} \\frac{1}{k^2}$$ 这是一个著名的级数，称为巴塞尔问题，其和为 $\\frac{\\pi^2}{6}$。这是一个解析解，可以直接使用高精度的 $\\pi$ 值计算，误差远小于 $\\epsilon$。
*   **当 $x \\to 0$ 时：** 修正项 $\\frac{1}{x} \\ln(1 + \\frac{x}{N})$ 会变成 $\\frac{0}{0}$ 型，直接计算会导致严重的舍入误差。我们需要使用泰勒展开： $$\\frac{1}{x} \\ln\\left(1 + \\frac{x}{N}\\right) = \\frac{1}{x} \\left( \\frac{x}{N} - \\frac{1}{2}\\left(\\frac{x}{N}\\right)^2 + O(x^3) \\right) = \\frac{1}{N} - \\frac{x}{2N^2} + \\dots$$ 当 $x$ 非常小（例如小于 $10^{-8}$）时，应该使用这个展开式来计算修正项，以避免相消误差。

**算法步骤：**

1.  **设定参数：**
    
    *   容差 $\\epsilon = 1.0 \\times 10^{-10}$。
    *   根据误差分析，确定求和项数 $N = 100000$。
    *   预先计算并存储高精度的 $\\pi^2/6$ 值。
2.  **主循环：** 遍历 $x$ 从 $0.0$ 到 $300.00$，步长为 $0.1$。
    
    *   **IF $x = 0.0$:** 结果就是预计算的 $\\pi^2/6$。
    *   **ELSE ($x > 0$):** a. **初始化有限和** $S\_N = 0.0$。 b. **计算有限和：** `FOR k FROM 1 TO N:` `S_N = S_N + 1.0 / (k * (k + x))` _(注意: 使用浮点数运算，例如 1.0)_ c. **计算积分修正项 $C\_N(x)$:** `IF x < 1.0e-8:` (阈值选择) `C_N = 1.0/N - x/(2.0*N*N)` `ELSE:` `C_N = (1.0/x) * log(1.0 + x/N)` d. **计算最终结果：** `psi_x = S_N + C_N` e. **输出或存储** $x$ 和 `psi_x`。
3.  **结束。**
    

##### **5\. 伪代码实现**

```
PROCEDURE Solve_Lab_01:
    CONSTANT N = 100000
    CONSTANT PI = 3.141592653589793
    psi_at_zero = PI*PI / 6.0

    // Print header for the table
    PRINT "x", "psi(x)"

    // Loop through all required x values
    FOR x_val FROM 0.0 TO 300.0 STEP 0.1:
        IF abs(x_val) < 1.0e-12: // Check for x=0 safely
            result = psi_at_zero
        ELSE:
            // Part 1: Direct Summation
            sum_part = 0.0
            FOR k FROM 1 TO N:
                sum_part = sum_part + 1.0 / (k * (k + x_val))
            
            // Part 2: Integral Correction Term
            correction_part = 0.0
            IF x_val < 1.0e-8: // Use Taylor expansion for small x
                correction_part = (1.0 / N) - (x_val / (2.0 * N * N))
            ELSE: // Use direct formula for other x
                correction_part = (1.0 / x_val) * log(1.0 + x_val / N)
            
            result = sum_part + correction_part
        
        PRINT x_val, result
    END FOR
END PROCEDURE
```

##### **6\. 总结**

这个问题的解决方案完美地体现了数值分析的核心思想：

*   **分析先行：** 在编写任何代码之前，必须进行严格的数学分析，以理解算法的收敛性和误差特性。
*   **避免蛮力：** 直接的、显而易见的方法往往在数值上是低效或不稳定的。
*   **组合方法：** 将离散的求和与连续的积分思想结合起来，可以创造出收敛速度快得多的新算法。
*   **关注细节：** 必须处理好特殊情况和潜在的数值陷阱，如 $x=0$ 的情况和 $x \\to 0$ 时可能出现的舍入误差。