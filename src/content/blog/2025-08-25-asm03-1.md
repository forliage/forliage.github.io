---
title: "x86汇编03-1:内存"
description: ""
pubDate: "2025-08-25"
heroImage: ""
---

# x86汇编03-1:内存

### **1\. 逻辑地址**

我们故事的起点是Intel 8086处理器。它的寄存器、ALU都是16位的，这意味着它一次最擅长处理16位的数字。如果直接用一个16位寄存器来寻址，它能访问的内存空间是多少？$2^{16}$ 字节，也就是65536字节，仅仅64KB。在1978年，这已经捉襟见肘。

**设计的核心矛盾：**

*   **内部能力：** CPU是16位架构，寄存器只有16位宽。
*   **外部需求：** 需要访问比64KB大得多的内存空间。事实上，8086的物理地址总线有20位，能访问 $2^{20}$ 字节，即1MB的内存。

**如何用16位的“尺子”去度量20位的“空间”？**

这就是x86体系结构历史上最重要，也最具争议的设计决策——**分段式内存管理（Segmented Memory）**。Intel的工程师们没有选择彻底革新架构（那样成本太高且不兼容），而是设计了一种“双指针”方案。

这个方案的核心是**逻辑地址（Logical Address）**，它由两部分组成：

1.  **段地址 (Segment Address)**: 一个16位的值，它指向一个64KB大小内存块的**基址**。
2.  **偏移地址 (Offset Address)**: 另一个16位的值，它表示目标内存在这个64KB段内的**具体位置**。

我们通常将逻辑地址写作 `段地址:偏移地址`，例如 `2000h:1234h`。

**那么，这个逻辑地址如何映射到20位的物理地址呢？**

公式如下： **物理地址 (Physical Address) = 段地址 $\\times$ 16 + 偏移地址**

用 $\\LaTeX$ 表示就是： $$PhysicalAddress = SegmentValue \\times 16\_{10} + OffsetValue$$

其中，乘以16在二进制中等价于**左移4位**。这是一个硬件可以瞬间完成的操作。

$$PhysicalAddress\_{20bit} = (SegmentValue\_{16bit} \\ll 4) + OffsetValue\_{16bit}$$

**让我们来看一个例子：** 计算逻辑地址 `2F00h:0158h` 对应的物理地址。

1.  取段地址 `2F00h`，左移4位（相当于末尾加一个0）：`2F000h`。
2.  加上偏移地址 `0158h`。
    
    ```
      2F000h
                    +  0158h
                    ----------
                      2F158h
                    
    ```
    
3.  所以，物理地址是 `2F158h`。

**设计的哲学与评价：**

*   **优点：**
    
    *   **解决了寻址范围问题**：用两个16位寄存器成功生成了20位地址，实现了1MB寻址。
    *   **向后兼容**：对于那些只需要64KB内存的旧程序，只需固定段地址，就可以像以前一样只操作偏移地址。
    *   **内存保护的雏形**：通过为代码、数据、堆栈分配不同的段，可以提供最基础的内存隔离。
*   **缺点：**
    
    *   **复杂性**：程序员必须同时管理段和偏移，心智负担加重。
    *   **地址不唯一**：同一个物理地址可以由多个不同的逻辑地址表示。例如：
        *   `2F00h:0158h` -> `2F158h`
        *   `2F15h:0008h` -> `2F150h + 0008h` -> `2F158h`
        *   `2E00h:1158h` -> `2E000h + 1158h` -> `2F158h` 这给编程带来了混乱。

### **2\. 小端规则 (Little-Endian Byte Order)**

在我们讨论如何在内存中存取数据之前，必须先解决一个基本问题：当一个多字节数据（如一个16位的`WORD`或32位的`DWORD`）要存入以字节为单位编址的内存时，是高位字节在前还是低位字节在前？

这存在两种设计流派：

1.  **大端 (Big-Endian)**: “所见即所得”，高位字节存储在低地址，低位字节存储在高地址。符合人类的阅读习惯。例如，`0x12345678` 存放在地址 `0x100`，则 `[0x100]=0x12`, `[0x101]=0x34`...
2.  **小端 (Little-Endian)**: “反着存”，低位字节存储在低地址，高位字节存储在高地址。这是**Intel x86架构的选择**。

**为什么Intel选择小端？** 这并非一个随意的决定，而是基于硬件效率的考量。 假设你要从内存读取一个32位的`DWORD`到`EAX`寄存器，然后再单独使用它的低16位`AX`或低8位`AL`。在小端模式下，这个`DWORD`的地址就是它的最低字节的地址。CPU读取`AL`或`AX`时，不需要进行任何地址计算，直接使用原始地址即可。这简化了CPU内部的电路设计，并带来微小的性能优势。

**示例：** 将 `DWORD` 值 `0x12345678` 存入以 `0x1000` 开始的内存地址：

```
         内存地址
                       +----------+
                0x1003 |    12    |  <-- 最高有效字节 (MSB)
                       +----------+
                0x1002 |    34    |
                       +----------+
                0x1001 |    56    |
                       +----------+
                0x1000 |    78    |  <-- 最低有效字节 (LSB)
                       +----------+
                
```

作为汇编程序员，你必须时刻牢记小端规则，尤其是在调试、查看内存时，否则你会对看到的数据感到困惑。

### **3\. 直接寻址和间接寻址 (Direct and Indirect Addressing)**

现在我们知道了地址的计算方式和数据的存储格式，那么在指令中如何指定一个内存地址呢？

*   **直接寻址 (Direct Addressing)** 偏移地址是一个**常量**，直接编码在指令中。这通常用于访问静态分配的全局变量。
    
    ```
    .data
                        myVar dw 1234h ; 在数据段定义一个字变量
                    .code
                        mov ax, [myVar] ; 将myVar的值加载到ax
                        ; 汇编器会将其转换为类似 mov ax, [0x100] 的指令
                        ; 偏移地址0x100是固定的
                    
    ```
    
    优点是简单明了，缺点是缺乏灵活性，因为地址在编译时就已固定。
    
*   **间接寻址 (Indirect Addressing)** 偏移地址存储在**寄存器**中。这是汇编语言强大功能的体现，是实现指针、数组遍历、动态数据结构的基础。
    
    ```
    mov bx, offset myVar ; 将myVar的偏移地址放入bx寄存器
                    mov ax, [bx]         ; 通过bx寄存器间接访问myVar
                                         ; ax的值现在是1234h
    
                    add bx, 2            ; 让bx指向下一个字 (地址+2)
                    mov [bx], 5678h      ; 向新的地址写入数据
                    
    ```
    
    这里，`[bx]` 的含义是：“取出bx寄存器中的值，把它当作一个内存地址，然后去那个地址进行读写操作”。
    

### **4\. 缺省段地址和段覆盖 (Default Segments and Segment Override)**

每次内存访问都要写成 `段:偏移` 的形式，比如 `mov ax, ds:[bx]`，这太繁琐了。CPU设计者为此引入了**缺省段**（Default Segments）规则，简化编程。

**规则:** CPU根据指令的类型和使用的寄存器，自动选择一个默认的段寄存器。

*   **代码获取**: 总是使用 **CS** (Code Segment)。CPU取下一条指令时，隐式地使用 `CS:IP`。
*   **堆栈操作** (`PUSH`, `POP`, `CALL`, `RET`): 总是使用 **SS** (Stack Segment)。堆栈指针 `SP` 或 `BP` 相关的访问默认段是 `SS`。
*   **数据访问**: 大多数情况使用 **DS** (Data Segment)。当使用 `AX, BX, CX, DX, SI, DI` 等寄存器进行间接寻址时，默认段是 `DS`。
*   **字符串操作目标地址**: 某些字符串指令（如`STOS`）的目的操作数默认使用 **ES** (Extra Segment)。

**段覆盖 (Segment Override)**: 当然，这些只是默认规则。如果你需要访问其他段的数据，可以使用**段覆盖前缀**来显式指定。

```
mov ax, [bx]          ; 默认从DS段读取, 相当于 mov ax, ds:[bx]
                mov ax, es:[bx]       ; 使用段覆盖前缀, 强制从ES段读取
                mov ax, ss:[bx]       ; 强制从SS段读取
                mov ax, cs:[bx]       ; 强制从CS段读取
                
```

**注意：** CS 通常是只读的，不能作为大多数写入指令的目的段。SS 的修改需要特别小心，否则会造成堆栈崩溃。

### **5\. 1M内存空间划分和显卡地址映射 (A Case Study)**

让我们把前面的知识应用到经典的PC内存布局中。这1MB的空间并不是一块统一的RAM。

**1M内存空间划分:**

```
+------------------+ 0xFFFFF (1MB - 1)
                |  ROM BIOS        |
                +------------------+ 0xF0000
                |  扩展 ROM         |
                +------------------+ 0xC8000
                |  显卡 ROM BIOS    |
                +------------------+ 0xC0000
                |  显存区域 (Video RAM) |
                +------------------+ 0xA0000
                |                  |
                |  常规内存 (RAM)  |
                |  (给DOS和程序用) |
                |                  |
                +------------------+ 0x00500
                |  BIOS 数据区      |
                +------------------+ 0x00400
                |  中断向量表      |
                +------------------+ 0x00000
                
```

*   **0x00000 - 0x003FF**: 中断向量表 (IVT)。存放中断服务程序的地址。
*   **0x00400 - 0x004FF**: BIOS数据区 (BDA)。存放硬件状态信息。
*   **... - 0x9FFFF**: 常规内存 (Conventional Memory)。这是用户程序能自由使用的主要RAM区域，最大为640KB。这就是著名的“640KB内存限制”的由来。
*   **0xA0000 - 0xBFFFF**: **显存映射区 (Video Memory)**。这是关键！
*   **0xC0000 - 0xFFFFF**: BIOS ROM和其他硬件的ROM。存放固化代码。

**显卡地址映射 (Memory-Mapped I/O):** 在早期的PC中，要让屏幕显示字符，并不是调用一个复杂的API。而是通过一种叫做**内存映射I/O (Memory-Mapped I/O, MMIO)** 的技术。 显卡控制器会监听地址总线。当CPU访问特定地址范围（如 `0xB8000` 开始的区域）时，物理RAM不会响应，而是显卡会“认领”这个地址，并将CPU写入的数据接收到它自己的显存中。

*   **文本模式显存**:
    
    *   物理地址从 `0xB8000` 开始。
    *   逻辑地址可以是 `B800h:0000`。
    *   屏幕上每个字符位置对应显存中的**2个字节**。
        *   **第1字节**: 字符的ASCII码。
        *   **第2字节**: 字符的属性（前景色、背景色、是否闪烁等）。
    
    例如，要在屏幕左上角（第0行，第0列）显示一个白底红字的 'A'：
    
    ```
    mov ax, 0B800h
                    mov es, ax             ; 将ES指向文本显存段
                    mov byte ptr es:[0], 'A'  ; 写入字符 'A' 的 ASCII 码
                    mov byte ptr es:[1], 01110100b ; 写入属性: 白底(0111)红字(0100)
                    
    ```
    
    执行这两条指令后，屏幕左上角会立即出现一个红色的'A'。这就是汇编语言直接操控硬件的魅力所在。
    

### **6\. 宽度修饰与变量引用 (Type Safety in Assembly)**

考虑指令 `mov [bx], 5`。CPU应该写入一个字节(BYTE)、一个字(WORD)还是一个双字(DWORD)？指令本身没有提供这个信息，这会造成歧义。

汇编器提供了两种方式解决这个问题：

1.  **变量引用 (Variable Reference)** 如果你的内存操作数是一个已经定义好类型的变量，汇编器会根据变量的定义自动确定操作宽度。
    
    ```
    .data
                        myByte  db ?  ; 定义一个字节
                        myWord  dw ?  ; 定义一个字
                    .code
                        mov [myByte], 5 ; 汇编器知道这是一个字节操作
                        mov [myWord], 5 ; 汇编器知道这是一个字操作
                    
    ```
    
2.  **宽度修饰符 (Size Specifier)** 当操作数没有明确类型时（如 `[bx]`），你必须**显式**地告诉汇编器操作的宽度。这通过 `PTR` 操作符完成。
    
    ```
    mov BYTE PTR [bx], 5  ; 明确写入一个字节 (8位)
                    mov WORD PTR [bx], 5  ; 明确写入一个字 (16位)
                    mov DWORD PTR [bx], 5 ; 明确写入一个双字 (32位, 在386+处理器)
                    
    ```
    
    **忘记宽度修饰符是新手在汇编编程中最常犯的错误之一。**