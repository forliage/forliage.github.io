---
title: "数据库系统设计06:查询优化"
description: ""
pubDate: "2025-08-26"
heroImage: ""
---

# 数据库系统设计06:查询优化

在上一讲中，我们扮演了查询执行引擎的角色，学习了如何实现各种关系操作的物理算法，比如不同的`JOIN`和`SELECT`方法。我们知道了，对于同一个逻辑操作，存在多种“做法”，它们的性能天差地别。这引出了一个至关重要的问题：当用户提交一条复杂的SQL查询时，数据库是如何从成千上万种可能的执行方式中，选择出那条“最佳路径”的？

这就是查询优化的核心任务。它不是一个简单的任务，而是一个极其复杂的**搜索问题**。搜索空间的大小是**组合爆炸**级别的，对于一个涉及10张表的JOIN查询，可能的执行计划数量比宇宙中的原子还要多。一个幼稚的优化器，其优化的时间本身就可能比直接执行一个糟糕计划的时间还要长。

因此，一个优秀的查询优化器，必须是一个集\*\*数学家（利用关系代数的严谨规则）、统计学家（基于数据分布进行精确估算）和算法大师（在巨大的搜索空间中进行高效剪枝）\*\*于一身的复杂系统。

今天，我们将分为三个部分，完整地模拟一次查询优化的生命周期：

1.  **逻辑优化：** 如何在不动用成本计算的情况下，对查询进行“整形”，使其天生就更易于高效执行。
2.  **成本估算：** 优化器如何利用数据库的“人口普查数据”（统计信息），来预测每一个操作的“开销”。
3.  **计划选择：** 我们将学习优化器是如何使用动态规划等系统性方法，在众多候选计划中，权衡利弊，做出最终的、基于成本的决策。

### **第一部分：逻辑优化与关系代数等价变换**

查询优化的第一步，是**基于规则的优化 (Rule-Based Optimization, RBO)**，也称为逻辑优化。这个阶段不关心具体的成本，而是运用一系列经过证明的、逻辑上等价的关系代数变换规则，将初始的查询表达式，转化为一个或多个结构上更优的、逻辑上等价的表达式。

#### **1.1 从SQL到逻辑查询计划**

这个过程我们在上一讲已经提及，这里再做一次梳理：

1.  **解析(Parsing) & 验证(Validation):** SQL语句被转化为一棵初始的、未优化的**逻辑查询计划树**。
2.  **核心问题:** 这棵初始的树可能非常低效，比如先做笛卡尔积再做选择。

#### **1.2 逻辑优化**

**启发式优化的核心思想是：尽可能早地减小中间结果集的大小。** 越早过滤掉无用的数据（行和列），后续昂贵的操作（如JOIN）需要处理的数据就越少。

##### **法则1：选择下推 (Pushing Selections)**

这是**最重要**的优化手段。

*   **规则:**
    
    *   **分解合取谓词:** $\\sigma\_{P1 \\land P2}(R) \\equiv \\sigma\_{P1}(\\sigma\_{P2}(R))$
    *   **将选择移动到连接之前:** $\\sigma\_{P\_R \\land P\_S}(R \\bowtie S) \\equiv \\sigma\_{P\_R}(R) \\bowtie \\sigma\_{P\_S}(S)$ (其中$P\_R$只涉及R, $P\_S$只涉及S)
    *   **将选择移动到笛卡尔积之前:** $\\sigma\_{P\_R}(R \\times S) \\equiv \\sigma\_{P\_R}(R) \\times S$
*   **直观解释:** 与其连接两个巨大的表，然后再从天文数字般的连接结果中筛选，不如先各自对两个表进行筛选，然后再连接两个小得多的“瘦身”后的表。
    

##### **法则2：投影下推 (Pushing Projections)**

*   **规则:** $\\pi\_A(R \\bowtie S) \\equiv \\pi\_A(\\pi\_{A\_R \\cup J}(R) \\bowtie \\pi\_{A\_S \\cup J}(S))$
    *   $J$: 连接所需的属性集合。
    *   $A\_R, A\_S$: 分别是$R, S$中，最终输出或后续操作需要的属性。
*   **直观解释:** 在连接之前，就把那些未来肯定用不到的列给“扔掉”。这不仅减少了中间结果的I/O（数据更窄），也减少了内存消耗。

##### **法则3：合并选择与笛卡尔积为连接**

*   **规则:** $\\sigma\_{R.a=S.b}(R \\times S) \\equiv R \\bowtie\_{R.a=S.b} S$
*   **重要性:** 这是优化器最基本的“常识”。它看到一个带有连接条件的`WHERE`子句作用于一个`FROM`子句的笛卡尔积上时，会自动将其识别为一个JOIN操作，从而可以使用高效的JOIN算法（如哈希连接），而不是真的去计算笛卡尔积。

#### **1.3 连接的重塑：交换律与结合律**

*   **交换律:** $R \\bowtie S \\equiv S \\bowtie R$
*   **结合律:** $(R \\bowtie S) \\bowtie T \\equiv R \\bowtie (S \\bowtie T)$
*   **战略意义:** 这两条规则赋予了优化器**重新安排连接顺序**的权力。这对于基于成本的优化至关重要，因为不同的连接顺序，其产生的中间结果集大小和总成本可能有数量级的差异。逻辑优化阶段会生成所有可能的连接树形态（如左深树、右深树、浓密树），供后续的物理优化阶段进行成本评估。

#### **1.4 枚举等价表达式**

优化器会递归地应用上述规则，系统性地生成一个等价表达式的集合。这个过程通常从初始的逻辑计划树开始，自顶向下或自底向上地尝试应用所有适用的规则，直到无法生成新的、不同的表达式为止。

### **第二部分：用于成本估算的统计信息**

逻辑优化告诉了我们“哪些计划是合理的”，但没有告诉我们“哪个计划是最好的”。要回答这个问题，我们必须进入**基于成本的优化 (Cost-Based Optimization, CBO)** 阶段。而CBO的基石，就是对每一个操作的成本进行**估算**，这又依赖于对中间结果大小的**基数估算 (Cardinality Estimation)**。

#### **2.1 系统目录 (System Catalog)**

优化器进行估算所依赖的数据，都存储在系统目录中。对于每个关系`r`，它至少需要知道：

*   $T(r)$: `r`中的元组总数。
*   $B(r)$: `r`占用的磁盘块数。
*   $S(r)$: `r`中每个元组的平均大小（字节）。
*   对于`r`中的每个属性`A`：
    *   $V(A, r)$: `A`属性的不同值的数量（值的基数）。
    *   $\\min(A, r), \\max(A, r)$: `A`属性的最小值和最大值。
    *   **直方图 (Histograms):** 更详细地描述`A`属性的值分布。

这些统计信息通常由数据库后台任务（如`ANALYZE`命令）定期收集和更新。**过时的统计信息是导致优化器选择次优计划的最常见原因。**

#### **2.2 选择操作的基数估算**

*   **等值选择 $\\sigma\_{A=v}(r)$:**
    *   **估算:** $T(r) / V(A, r)$
    *   **选择率 (Selectivity):** $1 / V(A, r)$
*   **范围选择 $\\sigma\_{A > v}(r)$:**
    *   **简单估算 (均匀分布假设):** $T(r) \\times (\\max(A, r) - v) / (\\max(A, r) - \\min(A, r))$
    *   **基于直方图的估算:** 查找`v`所在的桶，根据桶内信息和`v`在桶内的相对位置，进行更精确的估算。
*   **复杂谓词:**
    *   **合取 ($\\land$):** 假设谓词独立，选择率相乘。$\\text{Sel}(P1 \\land P2) = \\text{Sel}(P1) \\times \\text{Sel}(P2)$。
    *   **析取 ($\\lor$):** $\\text{Sel}(P1 \\lor P2) = \\text{Sel}(P1) + \\text{Sel}(P2) - \\text{Sel}(P1) \\times \\text{Sel}(P2)$。
    *   **否定 ($\\neg$):** $\\text{Sel}(\\neg P) = 1 - \\text{Sel}(P)$。

#### **2.3 连接操作的基数估算**

这是最困难也最重要的估算。

*   **笛卡尔积 $r \\times s$:** $T(r \\times s) = T(r) \\times T(s)$
*   **自然连接/等值连接 $r \\bowtie\_{r.A=s.B} s$:**
    *   **核心思想:** 考虑`r`中的一个元组，它能与`s`中多少个元组匹配？平均而言，是 $T(s) / V(B, s)$ 个。
    *   **通用估算公式:** $$ T(r \\bowtie s) = \\frac{T(r) \\times T(s)}{\\max(V(A, r), V(B, s))} $$
    *   **直观解释:** 连接结果的大小，受限于两个连接列中**不同值较多**的那个列。
    *   **外键约束下的估算:** 如果`A`是`r`中引用`s`的主键`B`的外键，那么`r`中的每个元组最多只会与`s`中的一个元组匹配。因此，$T(r \\bowtie s) \\le T(r)$。在这种情况下，通常估算 $T(r \\bowtie s) = T(r)$。

#### **2.4 其他操作的基数估算**

*   **投影 $\\pi\_L(r)$:**
    *   如果不去重，结果大小为 $T(r)$。
    *   如果去重 (`DISTINCT`)，结果大小为 $V(L, r)$，即属性集`L`的不同值组合数。这个值的估算比较复杂，通常近似为 $\\min(T(r), \\prod\_{A\_i \\in L} V(A\_i, r))$。
*   **分组/聚合 `GROUP BY G`:** 结果大小为 $V(G, r)$，即分组属性`G`的不同值组合数。

### **第三部分：评估计划的选择与搜索**

有了逻辑计划的候选集，又有了估算每个操作成本的工具，现在我们进入最后一步：**系统性地搜索并选择全局最优的物理执行计划。**

#### **3.1 独立选择的谬误**

一个常见的误区是：为每个逻辑算子独立地选择其成本最低的物理实现。

*   **反例:** 考虑一个`JOIN`操作后跟一个`ORDER BY`。
    *   独立来看，`Hash Join`的成本可能低于`Sort-Merge Join`。
    *   但是，`Sort-Merge Join`的输出结果**本身就是有序的**。如果这个顺序恰好是`ORDER BY`所需要的，那么后续的排序操作成本就为0！
    *   而选择`Hash Join`后，我们还需要对无序的连接结果进行一次昂贵的外部排序。
    *   **全局来看，`Sort-Merge Join` + (免费的) `Sort` 的总成本，可能远低于 `Hash Join` + (昂贵的) `Sort`。**
*   **结论:** 必须以**整个计划的总成本**为目标进行优化，而不是局部的最优。物理属性（如排序顺序）的传递是优化器必须考虑的重要因素。

#### **3.2 搜索最佳计划**

这是CBO的核心算法，我们在上一讲已经概述，这里我们深入其细节。

**算法流程:**

1.  **初始化 (Pass 1):**
    
    *   对每个单表`R`，计算所有可能的**访问路径 (Access Paths)** 的成本和物理属性。
        *   `File Scan(R)`: 成本为 $B(R)$，输出无序。
        *   `Index Scan(R, I)` on `R.A = v`: 成本依赖索引`I`，输出无序（如果是辅助索引）或按`A`排序（如果是主索引）。
    *   为每个表保留成本最低的无序计划，以及每个“有趣顺序”下成本最低的计划。
2.  **迭代构建 (Pass 2 to N):**
    
    *   **For i = 2 to N:**
        *   **For each subset of i tables `{R_1, ..., R_i}`:**
            *   **For each partitioning of this subset into `{S1}` and `{S2}`:**
                *   `Plan1 = BestPlan(S1)`, `Plan2 = BestPlan(S2)` (从前一轮次的结果中获取)
                *   **For each join algorithm `J` (Hash, Merge, Index...):**
                    *   `Cost = Cost(Plan1) + Cost(Plan2) + Cost(J(Plan1, Plan2))`
                    *   计算结果的基数和物理属性。
                    *   如果这个新生成的计划 `P` 的成本，低于当前已知的连接 `{R_1, ..., R_i}` 的最优计划成本，则更新。
                    *   同时，如果 `P` 产生了新的有趣顺序，也将其保留。

**剪枝与启发式:**

*   **只考虑左深树 (Left-Deep Trees):** 如前所述，这极大地缩小了搜索空间，同时有利于流水线执行。
*   **跳过高成本的笛卡尔积:** 如果两个子集之间没有连接条件，优化器会尽量推迟它们的连接。

#### **3.3 优化器之外**

*   **参数化查询 (Prepared Statements):** `SELECT * FROM T WHERE id = ?`
    *   优化器在不知道具体`?`值的情况下，只能生成一个**通用计划 (Generic Plan)**。
    *   对于某些`?`值，这个通用计划可能是次优的。现代数据库（如PostgreSQL）会在执行几次后，如果发现通用计划性能不佳，会为特定参数值重新生成**定制计划 (Custom Plan)**。
*   **查询重写 (Query Rewrite):** 在优化之前，某些数据库会对用户的SQL进行更高级的重写，例如：
    *   **视图展开 (View Expansion):** 将查询中的视图定义直接展开。
    *   **子查询解关联 (Subquery Unnesting):** 将相关的子查询（`WHERE EXISTS ...`）改写为`JOIN`。
    *   **物化视图匹配:** 如果存在一个物化视图可以满足部分或全部查询，则直接使用物化视图。

如果你想更详细了解CBO，可以查看我的[另外一篇文章](https://forliage.github.io/_posts/2025-06-20-CBO.html)。