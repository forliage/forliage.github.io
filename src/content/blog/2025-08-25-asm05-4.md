---
title: "x86汇编05-4:字符串与控制转移指令"
description: ""
pubDate: "2025-08-25"
heroImage: ""
---

# x86汇编05-4:字符串与控制转移指令

### **1 字符串操作指令 (String Instructions)**

**设计的核心哲学：自动化** 在高级语言中，`memcpy`, `memset`, `strcmp` 等函数无处不在。这些操作的共同点是：它们都在一块内存上进行重复性的操作。Intel的设计师们意识到，如果能将这些重复的软件循环（`loop`, `dec cx`, `inc si`, `inc di`）固化到CPU的微码（microcode）中，用一条指令来触发，将能极大地提升性能。这就是字符串指令的由来。

**参与者（The Cast of Characters）:** 所有字符串指令都依赖于一组固定的寄存器，你必须在使用前正确设置它们：

*   **`SI` / `ESI`**: **源变址寄存器 (Source Index)**。永远指向源操作数。段地址默认为 `DS`。
*   **`DI` / `EDI`**: **目的变址寄存器 (Destination Index)**。永远指向目的操作数。段地址默认为 `ES`。**注意是ES，不是DS！** 你必须确保`ES`指向了正确的目标段。
*   **`CX` / `ECX`**: **计数器 (Counter)**。用于`REP`前缀，决定了操作要重复多少次。
*   **`DF` (Direction Flag)**: **方向标志**。在`FLAGS`寄存器中，由你主动设置。
    *   `CLD` (Clear Direction Flag) -> `DF=0` (推荐的默认状态)。`SI`和`DI`在每次操作后**自动增加**。
    *   `STD` (Set Direction Flag) -> `DF=1`。`SI`和`DI`在每次操作后**自动减少**。

#### **1.1 字符串复制指令 (`MOVSB`, `MOVSW`, `MOVSD`) 与 `REP` 前缀**

*   **`MOVSB/W/D` (Move String Byte/Word/Doubleword)**
    *   **高级描述**: 从`DS:SI`复制一个字节/字/双字到`ES:DI`。
    *   **CPU/架构层面**: 这是一条“复合”微码指令。它的原子操作是：
        1.  `MOV byte/word/dword ptr [ES:DI], [DS:SI]`
        2.  根据`DF`标志位和操作宽度(1, 2, or 4)，更新`SI`和`DI`。
*   **`REP` (Repeat) 前缀**
    *   **高级描述**: 当`CX`不为0时，重复执行其后的字符串指令。
    *   **CPU/架构层面**: `REP`不是一条独立的指令，它是一个**前缀字节**，会改变下一条指令的行为。CPU看到`REP MOVSB`后，会进入一个特殊的、由硬件控制的高速循环状态：
        1.  执行`MOVSB`的微码。
        2.  `DEC CX`。
        3.  如果`CX != 0`，则回到第1步。 这个循环完全在CPU内部进行，不需要从内存中反复取指、译码，因此效率远高于软件循环。
*   **系统层面**: 这就是C语言标准库函数 `memcpy` 的最底层、最高效的实现。
*   **例子**: 将 `source_buffer` 中的100个字节复制到 `dest_buffer`
    
    ```
    .DATA
                        source_buffer DB 100 DUP('S')
                        dest_buffer   DB 100 DUP(?)
                    .CODE
                        ; --- 设置段寄存器 ---
                        MOV AX, @DATA
                        MOV DS, AX
                        MOV ES, AX      ; 必须确保DS和ES都指向数据段
    
                        ; --- 设置参与者 ---
                        LEA SI, [source_buffer] ; 源地址
                        LEA DI, [dest_buffer]   ; 目标地址
                        MOV CX, 100             ; 计数器
                        CLD                     ; 确保从低地址向高地址复制
    
                        ; --- 执行 ---
                        REP MOVSB       ; 一条指令完成100字节的复制
                    
    ```
    

#### **1.2 字符串比较指令 (`CMPSB/W/D`) 与 `REPE`/`REPNE` 前缀**

*   **`CMPSB/W/D` (Compare String ...)**
    *   **高级描述**: 比较`DS:SI`和`ES:DI`处的数据，并根据结果设置标志位。
    *   **CPU/架构层面**: 类似`CMP [DS:SI], [ES:DI]`，然后更新`SI`和`DI`。
*   **`REPE`/`REPZ` (Repeat while Equal / Repeat while Zero)**
    *   **高级描述**: 当`CX != 0` **并且** `ZF == 1` (表示上次比较结果相等)时，重复。
*   **`REPNE`/`REPNZ` (Repeat while Not Equal / Repeat while Not Zero)**
    *   **高级描述**: 当`CX != 0` **并且** `ZF == 0` (表示上次比较结果不相等)时，重复。
*   **系统层面**: `REPE CMPSB` 是 `memcmp` 的底层实现。循环退出的条件有两个：要么`CX`减到0（表示所有字节都相等），要么`ZF`变为0（表示找到了第一个不相等的字节）。
*   **例子**: 比较两个字符串 `str1` 和 `str2` (最多比较50个字节)
    
    ```
    ; (DS, ES, SI, DI, CX设置同上)
                    LEA SI, [str1]
                    LEA DI, [str2]
                    MOV CX, 50
                    CLD
                    REPE CMPSB      ; 重复比较，直到找到不同或CX=0
    
                    ; --- 检查结果 ---
                    JE strings_are_equal ; 如果循环是因为CX=0而结束 (ZF仍然为1)，说明相等
                    ; 否则，就是因为找到了不同
                    ; 此时 SI 和 DI 指向了第一个不相等字符的下一个位置
                    
    ```
    

#### **1.3 搜索字符串指令 (`SCASB/W/D`)**

*   **`SCASB/W/D` (Scan String ...)**
    *   **高级描述**: 将累加器(`AL`/`AX`/`EAX`)中的值与`ES:DI`处的数据进行比较，并设置标志位。
    *   **CPU/架构层面**: 类似`CMP [ES:DI], AL/AX/EAX`，然后更新`DI`。
*   **系统层面**: `REPNE SCASB` 是 `strlen` (计算空结尾字符串长度) 的经典实现。
*   **例子**: 计算一个以0结尾的字符串的长度
    
    ```
    ; (DS, ES, DI设置同上)
                    LEA DI, [my_string] ; 指向要计算的字符串
                    MOV CX, 0FFFFh      ; 设置一个足够大的计数器
                    XOR AL, AL          ; 将要搜索的字符(0)放入AL
                    CLD
                    REPNE SCASB         ; 重复扫描，直到找到AL(0)或CX=0
    
                    ; --- 计算长度 ---
                    ; 循环结束后, CX = 0FFFFh - (length + 1)
                    ; 所以 length = 0FFFFh - CX - 1
                    MOV AX, 0FFFFh
                    SUB AX, CX
                    DEC AX              ; AX中就是字符串长度
                    
    ```
    

#### **1.4 写入字符串指令 (`STOSB/W/D`)**

*   **`STOSB/W/D` (Store String ...)**
    *   **高级描述**: 将累加器(`AL`/`AX`/`EAX`)中的值存入`ES:DI`。
    *   **CPU/架构层面**: `MOV [ES:DI], AL/AX/EAX`，然后更新`DI`。
*   **系统层面**: `REP STOSB` 是 `memset` 的底层实现。
*   **例子**: 将一个1024字节的缓冲区清零
    
    ```
    ; (DS, ES, DI设置同上)
                    LEA DI, [buffer]
                    MOV CX, 1024
                    XOR AL, AL      ; 将要写入的值(0)放入AL
                    CLD
                    REP STOSB       ; 一条指令完成1024字节的填充
                    
    ```
    

#### **1.5 读取字符串指令 (`LODSB/W/D`)**

*   **`LODSB/W/D` (Load String ...)**
    *   **高级描述**: 从`DS:SI`处加载一个数据到累加器(`AL`/`AX`/`EAX`)。
    *   **CPU/架构层面**: `MOV AL/AX/EAX, [DS:SI]`，然后更新`SI`。
*   **系统层面**: 这条指令不常与`REP`配合（因为每次都会覆盖AL），但它在软件循环中处理字符串时非常方便，因为它自动更新`SI`指针。

### **2 控制转移指令 (Control Transfer Instructions)**

这些指令通过直接或间接地修改指令指针寄存器 `IP` (或 `EIP`/`RIP`) 和/或代码段寄存器 `CS` 来改变程序的执行流程。

#### **2.1 无条件跳转指令: `JMP`**

*   **高级描述**: 立即、无条件地跳转到目标地址执行。
*   **CPU/架构层面**: 直接修改 `IP` 和/或 `CS`。
*   **类型**:
    *   **`short dest` (短跳转)**: 目标地址与当前指令的距离在 **\-128到+127字节** 之间。机器码只有2字节，非常高效。`dest`是一个8位有符号偏移量。`IP = IP + offset8`。
    *   **`near ptr dest` (近跳转)**: **段内跳转**。目标地址在当前代码段内，但距离超过了short的范围。`dest`是一个16位或32位偏移量。`IP = IP + offset16/32`。这是最常用的跳转类型。
    *   **`far ptr dest` (远跳转)**: **段间跳转**。跳转到另一个代码段。指令中包含了目标段地址和偏移地址。`CS = new_segment`, `IP = new_offset`。在现代平坦内存模型操作系统中，应用程序很少使用，但在操作系统内核或引导加载程序中用于切换代码段。

#### **2.2 条件跳转指令: `Jcc`**

*   **高级描述**: 根据`FLAGS`寄存器中的一个或多个标志位的状态，**决定是否**进行一个**短跳转**。
*   **CPU/架构层面**: CPU检查`FLAGS`寄存器。如果条件满足，就执行一个 `JMP short dest`；否则，什么也不做，继续执行下一条指令。
*   **系统层面**: 这是实现所有`if-else`, `switch-case`, `while/for`循环判断的基础。它总是跟在 `CMP` 或 `TEST` 等会修改标志位的指令之后。
*   **条件码 `cc` 分类**:
    *   **单个标志**: `JZ` (Jump if Zero, ZF=1), `JNZ` (ZF=0), `JS` (SF=1), `JC` (CF=1), ...
    *   **无符号比较 (基于 `CF` 和 `ZF`)**:
        *   `JA` (Jump if Above) / `JNBE` (Not Below or Equal)
        *   `JB` (Jump if Below) / `JNAE` (Not Above or Equal)
    *   **有符号比较 (基于 `SF`, `OF` 和 `ZF`)**:
        *   `JG` (Jump if Greater) / `JNLE` (Not Less or Equal)
        *   `JL` (Jump if Less) / `JNGE` (Not Greater or Equal)
*   **例子**: 实现 `if (eax > ebx)`
    
    ```
    CMP EAX, EBX
                    JLE skip_if_body   ; Jump if Less or Equal (eax <= ebx)
                    ; --- if body ---
                    ; eax > ebx 的代码
                    ...
                    skip_if_body:
                    ; --- afrer if ---
                    
    ```
    

#### **2.3 循环指令**

*   **高级描述**: `JMP short` 和 `DEC CX` 的CISC风格组合。
*   **CPU/架构层面**: `LOOP` 指令的微码会先递减`CX`，然后检查`CX`是否为0。
*   **指令**:
    *   **`LOOP dest`**: `DEC CX; if(CX != 0) JMP short dest;`
    *   **`LOOPZ`/`LOOPE dest`**: `DEC CX; if(CX != 0 && ZF == 1) JMP short dest;`
    *   **`LOOPNZ`/`LOOPNE dest`**: `DEC CX; if(CX != 0 && ZF == 0) JMP short dest;`
*   **系统层面**: 提供了一种比`DEC CX`/`JNZ`组合更紧凑（机器码更短）的循环方式。但现代CPU的流水线和分支预测机制非常先进，简单的`DEC/JNZ`组合性能可能反而更好。`LOOP`指令主要是历史遗产。

#### **2.4 子程序调用与返回指令**

这是实现函数/过程的基石，是结构化编程的核心。

*   **`CALL dest`**
    
    *   **高级描述**: 调用一个子程序。
    *   **CPU/架构层面 (关键！)**: `CALL`执行两个原子操作：
        1.  **压栈返回地址**: 将**下一条指令**的地址压入堆栈 (`PUSH IP` 或 `PUSH CS` + `PUSH IP`)。
        2.  **跳转**: 执行一个 `JMP` 到目标地址 `dest`。
    *   `near`和`far`版本的区别与`JMP`相同。
*   **`RET [imm16]` (Return from Procedure)**
    
    *   **高级描述**: 从子程序返回。
    *   **CPU/架构层面**: `RET`执行一个核心操作：
        1.  **出栈返回地址**: 从栈顶弹出一个地址到`IP` (`POP IP` 或 `POP IP` + `POP CS`)。
    *   **可选的 `imm16`**: `RET 8` 表示在返回**之后**，再将堆栈指针`SP`增加8。
    *   **系统层面 (调用约定)**: 这个`imm16`是区分不同**调用约定 (Calling Convention)** 的关键。
        *   **cdecl** (C语言默认): **调用者**负责清理堆栈上的参数。子程序用 `RET`。
        *   **stdcall** (Win32 API): **被调用者**负责清理堆栈。子程序用 `RET imm16`，其中`imm16`是参数的总字节数。
*   **`RETF` (Return Far)**: 远返回，从堆栈弹出`IP`和`CS`。
    
*   **例子**: 一个简单的函数调用
    
    ```
    main:
                        PUSH 10         ; 参数2
                        PUSH 5          ; 参数1
                        CALL my_add     ; 1. PUSH address_after_call; 2. JMP my_add
                    address_after_call:
                        ADD SP, 8       ; cdecl约定，调用者清理8字节参数
                        ; AX中现在是返回值15
                        ...
                        
                    my_add:
                        PUSH BP         ; 建立栈帧
                        MOV BP, SP
                        MOV AX, [BP+8]  ; 获取参数1 (5)
                        ADD AX, [BP+12] ; 加上参数2 (10)
                        POP BP          ; 恢复栈帧
                        RET             ; POP address_after_call -> IP
                    
    ```
    

#### **2.5 中断和中断返回指令**

中断是操作系统与硬件、应用程序与操作系统之间交互的核心机制。

*   **`INT imm8` (Software Interrupt)**
    
    *   **高级描述**: 产生一个软件中断。
    *   **CPU/架构层面 (比CALL更复杂)**:
        1.  `PUSH EFLAGS`
        2.  `PUSH CS`
        3.  `PUSH EIP`
        4.  从**中断描述符表 (IDT)** 中查找第`imm8`号表项，获取中断服务程序的地址。
        5.  跳转到该地址。硬件通常会自动清除`IF`标志位，以防止中断嵌套。
    *   **系统层面**: 这是应用程序执行**系统调用 (System Call)** 的主要方式。例如，Linux的`INT 80h`，Windows的`INT 2Eh`。应用程序通过中断陷入(trap)内核模式，请求操作系统提供服务（如文件读写）。
    *   **`INT 3`**: 一个特殊的、单字节的中断，专用于**断点 (Breakpoint)**。调试器通过将代码替换为`INT 3` (`0xCC`)来设置断点。
*   **`INTO` (Interrupt on Overflow)**
    
    *   **高级描述**: 如果`OF`标志位为1，则产生4号中断。
    *   **系统层面**: 一个用于捕获算术溢出的专用指令，但现代编译器和操作系统很少使用它。
*   **`IRET`/`IRETD` (Interrupt Return)**
    
    *   **高级描述**: 从中断服务程序返回。
    *   **CPU/架构层面**: `RET`的“超级版”，它按相反的顺序恢复所有状态：
        1.  `POP EIP`
        2.  `POP CS`
        3.  `POP EFLAGS`
    *   **系统层面**: 恢复`EFLAGS`是至关重要的，因为它恢复了中断前的中断使能状态(`IF`)以及所有算术标志。这确保了被中断的程序能无缝地继续执行。