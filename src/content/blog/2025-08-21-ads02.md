---
title: "ads02:红黑树与B+树"
description: ""
pubDate: "2025-08-21"
heroImage: ""
---

# ads02:红黑树与B+树

**注**：关于红黑树的更详细的算法内容及实现可以参考: [我的另一篇文章](https://forliage.github.io/_posts/2025-09-24-RBT.html)

### 第一部分：红黑树 (Red-Black Trees)

#### 1\. 目标与定义

我们的目标非常明确：构建一个**近似平衡的二叉搜索树**。红黑树通过引入“颜色”属性和一套严格的规则来实现这一目标。

首先，我们来看一下红黑树的节点结构。除了二叉搜索树原有的 `key`（键值）、`left`（左孩子）、`right`（右孩子）和 `parent`（父节点）指针外，它还增加了一个 `color` 属性。

graph TD A\[Node\] --> B(parent); A --> C(color); A --> D(key); A --> E(left); A --> F(right);

在红黑树中，我们通常将叶子节点视为特殊的 `NIL` 节点，它们是黑色的。这些 `NIL` 节点在实际实现中通常用一个共享的哨兵节点（sentinel node）来表示，以简化代码逻辑。所以，下文提到的“叶子节点”均指这些 `NIL` 节点。

**【定义】** 一棵红黑树是一棵满足以下五条**红黑性质**的二叉搜索树：

1.  **颜色性质**: 每个节点要么是**红色**，要么是**黑色**。
2.  **根性质**: 根节点是**黑色**。
3.  **叶子性质**: 所有叶子节点（NIL）都是**黑色**。
4.  **红色性质**: 如果一个节点是**红色**的，那么它的两个子节点都是**黑色**的。（这也就意味着，从根到叶子的任何路径上，不会有两个连续的红色节点）。
5.  **黑色性质**: 对每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的**黑色**节点。这个数目被称为该节点的**黑高 (black-height)**。

我们来看一个具体的例子。图中，圆形节点代表内部节点，方形的NIL节点是外部叶子节点。红色节点用红色填充，黑色节点用黑色填充。

graph TD subgraph Red-Black Tree Example R(7) --> N2(2); R --> N11(11); N2 --> N1(1); N2 --> N5(5); N5 --> N4((4)); N11 --> N8(8); N11 --> N14(14); N14 --> N15((15)); subgraph NIL Leaves direction LR N1 --> nil1(NIL); N1 --> nil2(NIL); N4 --> nil3(NIL); N4 --> nil4(NIL); N5 --> nil5(NIL); N8 --> nil6(NIL); N8 --> nil7(NIL); N15 --> nil8(NIL); N15 --> nil9(NIL); N14 --> nil10(NIL); end end style R fill:#333,color:#fff style N2 fill:#f00,color:#fff style N11 fill:#f00,color:#fff style N1 fill:#333,color:#fff style N5 fill:#333,color:#fff style N8 fill:#333,color:#fff style N14 fill:#333,color:#fff style N4 fill:#f00,color:#fff style N15 fill:#f00,color:#fff style nil1 fill:#333,color:#fff style nil2 fill:#333,color:#fff style nil3 fill:#333,color:#fff style nil4 fill:#333,color:#fff style nil5 fill:#333,color:#fff style nil6 fill:#333,color:#fff style nil7 fill:#333,color:#fff style nil8 fill:#333,color:#fff style nil9 fill:#333,color:#fff style nil10 fill:#333,color:#fff

可以验证一下，这棵树完全符合上述五条性质。比如，根节点7是黑色的；路径 7 -> 2 -> 1 -> NIL 上有3个黑节点（7, 1, NIL），而路径 7 -> 11 -> 14 -> 15 -> NIL 上也有3个黑节点（7, 14, NIL）。

#### 2\. 关键性质证明：为什么红黑树是平衡的？

红黑树的平衡性是由其性质，特别是性质4和5，间接保证的。我们可以通过一个引理来证明一棵包含 N 个内部节点的红黑树，其高度 h 不会超过 `2 * log(N+1)`。

**【定义】黑高 (black-height)** 一个节点 `x` 的黑高，记为 `bh(x)`，是指从 `x` 出发（不含 `x`）到其任意后代叶子节点路径上的黑色节点数目。整棵树的黑高 `bh(Tree)` 就是根节点的黑高。

**【引理】** 一棵以 `x` 为根的子树，其内部节点的数量 `sizeof(x)` 至少为 `2^(bh(x)) - 1`。

**证明（使用数学归纳法）：**

*   **基础情况**: 当 `x` 的高度 `h(x) = 0` 时，`x` 是一个 NIL 节点。此时，其内部节点数为 `sizeof(x) = 0`。`x` 的黑高 `bh(x) = 0`（因为从NIL出发到自身的路径上没有黑节点）。 `2^(bh(x)) - 1 = 2^0 - 1 = 1 - 1 = 0`。 `sizeof(x) >= 0` 成立。引理在基础情况下成立。
    
*   **归纳假设**: 假设对于所有高度小于 `h(x)` 的节点 `y`，引理 `sizeof(y) >= 2^(bh(y)) - 1` 均成立。
    
*   **归纳步骤**: 现在我们考虑高度为 `h(x)` 的节点 `x`。`x` 是一个内部节点，它至少有两个孩子节点 `child`。
    
    *   `x` 的孩子的黑高 `bh(child)` 是多少？
        *   如果孩子是黑色的，`bh(child) = bh(x) - 1`。
        *   如果孩子是红色的，`bh(child) = bh(x)` (因为红色节点不计入黑高)。
    *   因此，对于 `x` 的任何一个孩子 `child`，其黑高 `bh(child)` 至少是 `bh(x) - 1`。
    *   根据我们的归纳假设，`x` 的每个孩子 `child` 所构成的子树，其内部节点数 `sizeof(child) >= 2^(bh(child)) - 1`。
    *   结合上面两点，我们得到 `sizeof(child) >= 2^(bh(x)-1) - 1`。
    *   那么，以 `x` 为根的子树的总内部节点数是 `sizeof(x) = 1 (x自身) + sizeof(left_child) + sizeof(right_child)`。
    *   所以，`sizeof(x) >= 1 + (2^(bh(x)-1) - 1) + (2^(bh(x)-1) - 1) = 2 * 2^(bh(x)-1) - 1 = 2^(bh(x)) - 1`。
    *   归纳步骤完成，引理得证。✔

有了这个引理，我们就可以完成最终的证明了。

**【定理】** 一棵有 `N` 个内部节点的红黑树，其高度 `h` 满足 `h <= 2 * log(N+1)`。

**证明：**

1.  首先，我们来建立树高 `h` 和黑高 `bh(root)` 之间的关系。
    
    *   在一棵红黑树中，从根到最远的叶子节点的路径（即树高 `h` 所在的路径），根据性质4（红色节点的孩子必须是黑色），红色节点不能连续出现。
    *   这意味着在这条路径上，黑色节点的数量至少是路径总长度的一半（或者更准确地说，至少是 `h/2`）。
    *   路径上的黑色节点数就是根节点的黑高 `bh(root)`（如果算上根节点本身）。更严谨地说，从根到叶子的简单路径上，黑节点的数量至少是 `(h+1)/2`，如果将叶子NIL也算作一层的话。通常我们说的黑高不包含起始节点，所以 `bh(root)` 是路径上除了根之外的黑节点数。
    *   考虑从根到叶子的任意路径，路径长度为 `k`。节点数为 `k+1`。其中黑节点数至少为 `ceil((k+1)/2)`。
    *   我们可以得到一个更简单的关系：路径上的节点数（不含NIL）最多是 `2 * (黑色节点数)`。因为每两个黑节点之间最多夹一个红节点。
    *   所以，树的高度 `h` <= `2 * bh(root)`。✔ (这里的 `h` 是边的数量，`bh(root)` 是根到叶子路径上的黑节点数，不含根)。
    *   更准确地，`bh(root) >= h / 2`。
2.  现在，我们将这个关系与之前的引理结合起来。
    
    *   设 `N` 是树中内部节点的总数。根据引理，`N = sizeof(root) >= 2^(bh(root)) - 1`。
    *   移项得 `N + 1 >= 2^(bh(root))`。
    *   两边取对数（以2为底），`log(N+1) >= bh(root)`。
    *   结合第1步的结论 `bh(root) >= h / 2`，我们得到 `log(N+1) >= bh(root) >= h / 2`。
    *   最终得出 `h <= 2 * log(N+1)`。

**结论**: 红黑树的高度是对数级别的，因此其查找、插入、删除操作的时间复杂度都是 **O(log N)**。

#### 3\. 插入操作 (Insert)

红黑树的插入过程分为两步：

1.  **标准BST插入**: 像普通二叉搜索树一样，找到合适的位置插入新节点。
2.  **着色与修复**: 将新插入的节点着色为**红色**，然后通过一系列的**旋转**和**重新着色**来修复可能被破坏的红黑性质。

**为什么新节点是红色的？**

*   如果我们插入黑色节点，几乎肯定会违反性质5（黑高性质），因为新节点所在路径的黑高会比其他路径多1。修复黑高性质非常复杂。
*   如果我们插入红色节点，性质5一定不会被违反。性质3（叶子是黑色）也不会。唯一可能被违反的是性质2（如果新节点是根节点）或性质4（如果新节点的父节点也是红色）。这两种情况相对容易修复。

**插入修复的 Cases (以插入节点 `z`，其父为 `p`，祖父为 `g`，叔叔为 `u` 为例):**

*   **Case 1: 叔叔 `u` 是红色**
    
    *   **情况**: 父节点 `p` 和叔叔 `u` 都是红色。
    *   **操作**: 将父节点 `p` 和叔叔 `u` 都变为黑色，将祖父 `g` 变为红色。然后，将当前节点 `z` 指向祖父 `g`，继续向上迭代检查，因为 `g` 变成红色可能会与它的父节点冲突。这相当于把“问题”（连续的红色）向上推了一层。
    *   **图示**:
    
    graph TD subgraph Before G((g: black)) --> P((p: red)); G --> U((u: red)); P --> Z((z: red)); end subgraph Arrow direction LR A\[" "\] -- "Recolor & Recurse" --> B\[" "\] end subgraph After G2((g: red)) --> P2((p: black)); G2 --> U2((u: black)); P2 --> Z2((z: red)); end
    
*   **Case 2: 叔叔 `u` 是黑色，且 `z` 是 `p` 的内侧孩子 (形成 "三角" 结构)**
    
    *   **情况**: 例如，`g` 的左孩子是 `p`，而 `z` 是 `p` 的右孩子。
    *   **操作**: 对父节点 `p` 进行一次**左旋**。这样就将 Case 2 转化为了 Case 3 的情况。
    *   **图示**:
    
    graph TD subgraph Before G((g: black)) --> P((p: red)); P --> Z((z: red)); G --> U(u: black); end subgraph Arrow direction LR A\[" "\] -- "Rotate p" --> B\[" "\] end subgraph "After (Now Case 3)" G2((g: black)) --> Z2((z: red)); Z2 --> P2((p: red)); G2 --> U2(u: black); end
    
*   **Case 3: 叔叔 `u` 是黑色，且 `z` 是 `p` 的外侧孩子 (形成 "直线" 结构)**
    
    *   **情况**: 例如，`g` 的左孩子是 `p`，`z` 也是 `p` 的左孩子。
    *   **操作**: 将父节点 `p` 变为黑色，祖父 `g` 变为红色。然后对祖父 `g` 进行一次**右旋**。这样修复完成后，红黑性质得到满足，循环结束。
    *   **图示**:
    
    graph TD subgraph Before G((g: black)) --> P((p: red)); P --> Z((z: red)); G --> U(u: black); end subgraph Arrow direction LR A\[" "\] -- "Recolor & Rotate g" --> B\[" "\] end subgraph "After (Fixed)" P2((p: black)) --> Z2((z: red)); P2 --> G2((g: red)); G2 --> U2(u: black); end
    

当然，以上三种情况都有其对应的**对称情况**（例如 `p` 是 `g` 的右孩子）。整个修复过程是迭代或递归的，从插入点开始，一路向上，直到根节点，时间复杂度为 O(log N)。

#### 4\. 删除操作 (Delete)

删除操作是红黑树中最复杂的部分。

1.  **标准BST删除**: 首先，按照二叉搜索树的删除规则找到要删除的节点。
    
    *   **叶子节点**: 直接删除。
    *   **只有一个孩子的节点**: 用其孩子替换它。
    *   **有两个孩子的节点**: 找到它的后继节点（右子树中最小的节点），用后继节点的值替换当前节点的值，然后问题转化为删除那个后继节点（后继节点最多只有一个右孩子）。
    
    最终，问题都归结为**删除一个最多只有一个孩子的节点**。
    
2.  **修复**:
    
    *   如果被删除（或被移动来替换）的节点是**红色**的，那么树的红黑性质不会被破坏，操作结束。
    *   如果被删除的节点是**黑色**的，这就麻烦了。它会导致它所在路径的黑高减 1，违反了性质5。我们称这个问题为“**双重黑色**”问题。我们需要通过一系列操作来修复它。

**删除修复的 Cases (以被删除黑节点的替代节点 `x` 和其兄弟 `w` 为例):** 这个过程的目标是给 `x` 所在的路径增加一个黑色，或者把“双重黑色”的属性向上推。

*   **Case 1: 兄弟 `w` 是红色**
    
    *   **操作**: 将 `w` 变为黑色，父节点 `p` 变为红色。对 `p` 进行一次旋转（`x` 是左孩子则左旋，反之右旋）。这样，`x` 的新兄弟就变成了一个黑色的节点，问题转化为 Case 2, 3 或 4。
    *   **图示 (x为左孩子)**:
    
    graph TD subgraph Before P((p: black)) --> X((x: double black)); P --> W((w: red)); W --> WL(wl: black); W --> WR(wr: black); end subgraph Arrow direction LR A\[" "\] -- "Recolor & Rotate p" --> B\[" "\] end subgraph "After (Now new sibling is black)" W2((w: black)) --> P2((p: red)); P2 --> X2((x: double black)); P2 --> WL2(wl: black); W2 --> WR2(wr: black); end
    
*   **Case 2: 兄弟 `w` 是黑色，且 `w` 的两个孩子都是黑色**
    
    *   **操作**: 将 `w` 变为红色。这样 `x` 和 `w` 所在子树的黑高都恢复了。但是，父节点 `p` 所在的路径现在少了一个黑色，所以我们将“双重黑色”问题向上移动到 `p`。继续对 `p` 进行修复。
    *   **图示 (x为左孩子)**:
    
    graph TD subgraph Before P((p: ?)) --> X((x: double black)); P --> W((w: black)); W --> WL(wl: black); W --> WR(wr: black); end subgraph Arrow direction LR A\[" "\] -- "Recolor w, move problem up" --> B\[" "\] end subgraph "After (Problem moved to p)" P2((p: double black)) --> X2((x: black)); P2 --> W2((w: red)); W2 --> WL2(wl: black); W2 --> WR2(wr: black); end
    
*   **Case 3: 兄弟 `w` 是黑色，`w` 的内侧孩子是红色，外侧孩子是黑色**
    
    *   **操作**: 交换 `w` 和其内侧孩子的颜色，然后对 `w` 进行一次旋转。这将 Case 3 转化为 Case 4。
    *   **图示 (x为左孩子)**:
    
    graph TD subgraph Before P((p: ?)) --> X(x: double black); P --> W((w: black)); W --> WL((wl: red)); W --> WR(wr: black); end subgraph Arrow direction LR A\[" "\] -- "Recolor & Rotate w" --> B\[" "\] end subgraph "After (Now Case 4)" P2((p: ?)) --> X2(x: double black); P2 --> WL2((wl: black)); WL2 --> W2((w: red)); W2 --> WR2(wr: black); end
    
*   **Case 4: 兄弟 `w` 是黑色，且 `w` 的外侧孩子是红色**
    
    *   **操作**: 将 `w` 的颜色设为父节点 `p` 的颜色，将 `p` 设为黑色，将 `w` 的外侧孩子设为黑色。然后对 `p` 进行一次旋转。这样，“双重黑色”问题就被彻底解决，循环结束。
    *   **图示 (x为左孩子)**:
    
    graph TD subgraph Before P((p: ?)) --> X(x: double black); P --> W((w: black)); W --> WR((wr: red)); end subgraph Arrow direction LR A\[" "\] -- "Recolor & Rotate p" --> B\[" "\] end subgraph "After (Fixed)" W2((w: color of p)) --> P2((p: black)); P2 --> X2(x: black); W2 --> WR2((wr: black)); end
    

删除操作虽然复杂，但同样地，它最多需要 O(log N) 的时间和常数次旋转（最多3次）就能完成。

#### 5\. 性能对比：红黑树 vs AVL树

操作

AVL 树

红黑树

**插入旋转**

≤ 1 (单/双旋)

≤ 2

**删除旋转**

O(log N)

≤ 3

*   **AVL树** 是更严格的平衡树（左右子树高度差不超过1），因此它的查找性能理论上略优于红黑树。
*   **红黑树** 的平衡条件更宽松，导致它在插入和删除时需要进行的**旋转操作更少**。在写操作频繁的场景下，红黑树的综合性能通常更好。这就是为什么C++的 `std::map`, `std::set` 和 Java 的 `TreeMap`, `TreeSet` 等底层都采用红黑树实现的原因。

#### 6\. 红黑树伪代码与 C++ 实现

**伪代码 (插入修复)**

```
RB-INSERT-FIXUP(T, z)
  while z.p.color == RED
    if z.p == z.p.p.left  // 父节点是左孩子
      y = z.p.p.right     // y 是叔叔节点
      if y.color == RED   // Case 1
        z.p.color = BLACK
        y.color = BLACK
        z.p.p.color = RED
        z = z.p.p
      else 
        if z == z.p.right // Case 2
          z = z.p
          LEFT-ROTATE(T, z)
        // Case 3
        z.p.color = BLACK
        z.p.p.color = RED
        RIGHT-ROTATE(T, z.p.p)
    else // 父节点是右孩子 (对称情况)
      ...
  T.root.color = BLACK
```

**C++ 实现 (核心结构)**

```cpp
#include <iostream>

enum Color { RED, BLACK };

struct Node {
    int key;
    Color color;
    Node *parent, *left, *right;

    Node(int key) : key(key), color(RED), parent(nullptr), left(nullptr), right(nullptr) {}
};

class RedBlackTree {
private:
    Node* root;
    Node* TNULL; // 哨兵节点

    void leftRotate(Node* x) {
        // ... 实现左旋 ...
    }

    void rightRotate(Node* y) {
        // ... 实现右旋 ...
    }

    void insertFixup(Node* z) {
        // ... 实现插入修复逻辑 ...
    }
    
    void deleteFixup(Node* x) {
        // ... 实现删除修复逻辑 ...
    }
    
public:
    RedBlackTree() {
        TNULL = new Node(0);
        TNULL->color = BLACK;
        root = TNULL;
    }

    void insert(int key) {
        Node* z = new Node(key);
        z->left = TNULL;
        z->right = TNULL;
        
        Node* y = nullptr;
        Node* x = this->root;

        while (x != TNULL) {
            y = x;
            if (z->key < x->key) {
                x = x->left;
            } else {
                x = x->right;
            }
        }

        z->parent = y;
        if (y == nullptr) {
            root = z;
        } else if (z->key < y->key) {
            y->left = z;
        } else {
            y->right = z;
        }

        if (z->parent == nullptr) {
            z->color = BLACK;
            return;
        }
        if (z->parent->parent == nullptr) {
            return;
        }

        insertFixup(z);
    }
    
    // ... 其他成员函数，如删除、查找、析构函数等
};
```

* * *

### 第二部分：B树与B+树 (B-Trees and B+ Trees)

现在，让我们把视线从内存转向外存。当数据量大到内存无法容纳时，我们就需要将数据存储在磁盘上。磁盘的读写速度比内存慢几个数量级，而且是按“块”（Block/Page）为单位进行的。

我们的目标变成了：**设计一种数据结构，使得查找任何数据所需的磁盘I/O次数最少。**

二叉树，哪怕是平衡的红黑树，它的“扇出”（fan-out，即一个节点能有多少个孩子）太小了，只有2。这意味着树会很高。树高为 h，查找就需要 h 次磁盘I/O。我们需要一种**矮胖**的树结构。

#### 1\. B树 (B-Tree)

**【定义】** 一棵 $M$ 阶 (order $M$) 的B树是具有以下性质的多路搜索树：

1.  **节点结构**: 每个内部节点最多包含 $M-1$ 个键和 $M$ 个子节点指针。
2.  **键与子树**: 节点内的键是有序的。`key_1 < key_2 < ... < key_k`。位于 `key_i` 和 `key_{i+1}` 之间的子树指针，指向的子树中所有键的值都介于 `key_i` 和 `key_{i+1}` 之间。
3.  **填充因子**:
    *   根节点至少有1个键（除非树为空）和2个子节点。
    *   除根节点外的所有内部节点，至少有 $\\lceil M/2\\rceil - 1$ 个键和 $\\lceil M/2\\rceil$ 个子节点。这保证了树的利用率。
4.  **叶子节点**: 所有叶子节点都在同一层。
5.  **数据存储**: **键和对应的数据（或指向数据的指针）都存储在节点中，包括内部节点和叶子节点。**

**B树示例 (M=5)** 一个内部节点可能的样子：`[ptr1, (key1, data1), ptr2, (key2, data2), ptr3]`

*   `ptr1` 指向的子树所有键 < `key1`
*   `ptr2` 指向的子树所有键 > `key1` 且 < `key2`
*   `ptr3` 指向的子树所有键 > `key2`

**操作**:

*   **查找**: 从根节点开始，在节点内部使用二分查找确定要去哪个子树，然后递归下去，直到找到键或到达叶子节点。
*   **插入**: 找到要插入的叶子节点。如果叶子节点未满，直接插入。如果叶子节点已满，则**分裂**该节点：将中间的键提升到父节点，节点分裂成两个。这个过程可能向上传播，最坏情况会一直分裂到根节点，使树增高一层。
*   **删除**: 找到要删除的键。如果键在叶子节点且删除后节点键数仍满足要求，直接删除。如果不满足，尝试从兄弟节点**借一个**键，或者与兄弟节点**合并**。这个过程也可能向上传播。

B树的优势在于，$M$ 可以设置得很大（例如，等于一个磁盘块能容纳的 `(key, ptr)` 对的数量），使得树非常矮，大大减少了磁盘I/O次数。

#### 2\. B+树 (B+ Tree)

B+树是B树的一个重要变种，它在数据库索引领域应用更广。

**【定义】** 一棵 $M$ 阶的B+树具有以下性质：

1.  **节点填充**:
    *   根节点要么是叶子，要么有 $2$ 到 $M$ 个子节点。
    *   非叶子节点（除根外）有 $\\lceil M/2\\rceil$ 到 $M$ 个子节点。
2.  **叶子节点**: 所有叶子都在同一层。
3.  **结构差异 (与B树的核心区别)**:
    *   **所有数据都只存在于叶子节点中**。内部节点只存储键，作为“路标”或索引，不存储数据。这使得内部节点可以容纳更多的键，进一步降低树的高度。
    *   **所有叶子节点通过指针连接成一个有序链表**。

我们来看一个 **4阶B+树 (2-3-4树)** 的例子：

graph TD subgraph "B+ Tree (Order 4)" Root("21 | 48 | 72") --> L1("12 | 15"); Root --> L2("25 | 31 | 41"); Root --> L3("59"); Root --> L4("84 | 91"); subgraph "Leaf Nodes (Linked List)" direction LR D1\["1,4,8,11"\] --> D2\["12,13"\]; D2 --> D3\["15,18,19"\]; D3 --> D4\["21,24"\]; D4 --> D5\["25,26"\]; D5 --> D6\["31,38"\]; D6 --> D7\["41,43,46"\]; D7 --> D8\["48,49,50"\]; D8 --> D9\["59,68"\]; D9 --> D10\["72,78"\]; D10 --> D11\["84,88"\]; D11 --> D12\["91,92,99"\]; end L1 --> D1; L1 --> D2; L1 --> D3; L2 --> D4; L2 --> D5; L2 --> D6; L3 --> D7; L3 --> D8; L3 --> D9; L4 --> D10; L4 --> D11; L4 --> D12; end style Root fill:#eee,stroke:#333,stroke-width:2px style L1 fill:#eee,stroke:#333,stroke-width:2px style L2 fill:#eee,stroke:#333,stroke-width:2px style L3 fill:#eee,stroke:#333,stroke-width:2px style L4 fill:#eee,stroke:#333,stroke-width:2px

注意观察，内部节点（如根 "21|48|72"）中的键（如21, 48）也会在叶子节点中作为起始键出现。这是B+树的典型特征，内部节点的键是其右子树中最小键的副本。

**B+树操作示例** (以 order 3，即2-3树为例)

*   **查找 52**: 从根 `22:-` 开始，`52 > 22`，走右边到 `41:58`。`41 < 52 < 58`，走中间指针，到叶子节点 `41,52`，找到！
    
*   **插入 18**:
    
    1.  找到叶子 `16,17,18`。发现这个节点已经有两个键，是满的。
    2.  插入 `18`，节点变为 `16,17,18`。
    3.  分裂此节点，中间值 `17` 不存在，分裂成 `16` 和 `17,18`。将 `17` 提升到父节点 `11:16`。
    4.  父节点变为 `11:16:17`，也满了。
    5.  分裂父节点，中间值 `16` 提升到根节点。
    6.  最终树结构发生较大变化。
*   **插入 28**:
    
    1.  找到叶子 `22,23,31`。
    2.  插入 `28`，节点变为 `22,23,28,31` (假设阶为4)。
    3.  分裂，中间 `28` 提升到父节点。

**B+树操作算法概览 (Insert)**

```
Btree_Insert(X, T)
{
    // 1. 从根到叶子查找合适的插入位置
    Search from root to leaf and find the proper leaf node;
    
    // 2. 在叶子节点插入 X
    Insert X into the leaf node;
    
    // 3. 循环检查分裂
    while (this node has M+1 keys) {
        // 分裂成两个节点
        split it into 2 nodes;
        
        // 提升中间键到父节点
        promote the middle key to the parent;
        
        if (this node is the root) {
            create a new root with two children;
            // 树增高一层，循环结束
            break;
        } else {
            // 继续检查父节点是否溢出
            check its parent;
        }
    }
}
```

**复杂度分析**

*   **查找**: `T_Find(M, N) = O(log_M N)`。因为树高是 `O(log_M N)`，每个节点内部查找是 `O(log M)`，所以总时间是 `O(log M * log_M N) = O(log N)`。但关键在于 I/O 次数，就是树高，为 `O(log_M N)`。
*   **深度**: `Depth(M, N) = O(log_ceil(M/2) N)`。
*   **插入/删除**: `O(log_M N)` 次 I/O。

**关于M的选择** 课堂的幻灯片中提到 "The best choice of M is 3 or 4"。这个结论适用于**内存中**实现的B树/B+树（如 2-3 树、2-3-4 树），因为它们与红黑树等结构有等价关系，且实现相对简单。 但在**磁盘数据库**中，M 的选择原则是：**让一个节点的大小恰好等于一个磁盘页的大小（例如 4KB）**。这样一次I/O就能读取整个节点。此时 M 的值会很大，可能是几百甚至上千。

#### 3\. B树 vs B+树：终极对决

特性

B树

B+树

**数据存储**

内部节点和叶子节点都存数据

只有叶子节点存数据

**内部节点**

存储 (key, data)

只存储 key 作为索引

**查询效率**

不稳定，最好的情况在根节点就找到

稳定，任何查询都必须走到叶子节点

**空间利用率**

内部节点因存数据，能放的key较少

内部节点不存数据，key更多，树更矮胖

**叶子节点结构**

无序，不相连

有序，通过指针相连形成链表

**范围查询**

效率低，需要中序遍历，涉及大量回溯

**效率极高**，找到范围起点后，沿链表遍历即可

**应用场景**

文件系统

**数据库索引 (如 MySQL InnoDB)**

**为什么数据库索引偏爱B+树？**

1.  **更少的I/O**: B+树的内部节点更小，一个磁盘块能装下更多索引键，使得树更矮，单点查询的I/O次数更少。
2.  **稳定的查询性能**: 所有查询都走到叶子层，查询性能可预测。
3.  **极佳的范围查询支持**: 这是B+树相对于B树的**杀手级优势**。SQL中的 `WHERE age > 20` 或 `BETWEEN 10 AND 30` 这样的查询，在B+树上执行起来行云流水。

#### 4\. B+树 C++ 实现思路

B+树的实现比红黑树更复杂，我们只看核心结构和思路。

```cpp
#include <vector>

const int ORDER = 4; // B+树的阶

struct Node {
    bool is_leaf;
    std::vector<int> keys;
    std::vector<Node*> children; // 对于叶子节点，children[0]是next指针
    Node* parent;

    Node(bool leaf = false) : is_leaf(leaf), parent(nullptr) {}
};

class BPlusTree {
private:
    Node* root;

    Node* find_leaf(int key) {
        // ... 从根节点开始查找，直到叶子节点 ...
    }
    
    void split_child(Node* parent, int child_index) {
        // ... 这是最核心的函数：分裂一个满了的子节点 ...
        // 1. 创建新节点
        // 2. 将被分裂节点的后半部分key和child移动到新节点
        // 3. 将中间的key提升到父节点
        // 4. 更新指针
    }

public:
    BPlusTree() : root(nullptr) {}

    void insert(int key) {
        if (root == nullptr) {
            root = new Node(true);
            root->keys.push_back(key);
            return;
        }

        Node* leaf = find_leaf(key);
        // ... 在叶子节点中插入key ...

        // 如果叶子节点满了
        if (leaf->keys.size() >= ORDER) {
            // ... 向上分裂 ...
        }
    }
    
    bool search(int key) {
        // ... 实现查找 ...
    }
};
```