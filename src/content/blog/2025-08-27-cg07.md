---
title: "计算机图形学07:三维视图管线"
description: ""
pubDate: "2025-08-27"
heroImage: ""
---

# 计算机图形学07:三维视图管线

### **引言：从3D世界到2D屏幕**

我们的最终目标非常明确：**将一个用三维坐标描述的世界，显示在一个二维的像素屏幕上**。这个从3D到2D的降维过程，是整个图形学中最核心、最精妙的部分。它不仅仅是简单地丢弃一个坐标轴，而是要模拟真实世界中人眼或相机的成像原理，创造出具有深度和真实感的视觉体验。

整个过程可以被看作是一条**流水线 (Pipeline)**，三维顶点数据从一端进入，经过一系列连续的坐标系变换，最终在另一端输出为二维屏幕上的像素颜色。理解这条流水线，就等于掌握了从模型到图像的完整路径。

### **1\. 模型变换与视图变换**

让我们先理清两个容易混淆的概念：**模型变换 (Modeling Transformation)** 和 **视图变换 (Viewing Transformation)**。

*   **模型变换：** 我们上一讲学习的内容。它回答的是“**物体在世界中的哪个位置？**”。它将物体从自身的**局部坐标系**（或称模型坐标系）变换到统一的**世界坐标系**中。这一步是在搭建场景。
*   **视图变换：** 今天的新内容。它回答的是“**我们（相机）站在哪里，朝哪里看？**”。它将整个世界（包括所有物体）从**世界坐标系**变换到**相机坐标系**（或称观察坐标系、视觉坐标系）。这一步是在确定拍摄机位。

**相机类比法** 是理解视图变换最直观的方式：

1.  **确定相机位置 (Eye/Camera Position):** 相机在世界中的 $(x, y, z)$ 坐标。
2.  **确定拍摄目标 (Look-At Point):** 相机镜头对准的点。
3.  **确定相机“头顶”朝向 (Up Vector):** 定义相机的旋转，防止画面歪斜。通常我们会指定一个大致的“向上”的向量（如(0,1,0)），系统会自动计算出与视线垂直的精确相机顶部方向。

在数学上，视图变换构建了一个以相机为原点的新坐标系，通常称为\*\*(u, v, n)\*\*坐标系。然后计算一个变换矩阵，将世界坐标系中的所有顶点都转换到这个新的相机坐标系下。通常，我们习惯让相机看向 **\-Z** 轴方向，这在后续的深度测试等操作中会带来便利。

在OpenGL中，`gluLookAt(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ)` 这个函数就为我们封装了这一整个复杂的过程，自动计算并应用视图变换矩阵。

### **2\. 投影变换**

当所有物体都转换到相机坐标系下之后，我们就进入了整个流程中最关键的一步：**投影 (Projection)**。投影变换定义了我们能**看见什么**以及**如何看见**。

投影变换的核心任务，是将一个三维的**视景体 (View Volume)** 内的物体，“压扁”到一个二维的\*\*投影平面 (Projection Plane)\*\*上。

我们主要有两种投影方式：

#### **2.1 正交投影 (Orthographic Projection)**

*   **原理：** 投影线相互平行，且垂直于投影平面。可以想象成将物体直接“拍平”到屏幕上。
*   **视景体：** 一个长方体（Cuboid）。
*   **特点：**
    *   **没有远近感：** 物体的大小不会随着距离的远近而改变。
    *   **保留平行线和角度：** 适用于工程制图、建筑蓝图、2.5D游戏等需要精确测量和展示的场合。
*   **OpenGL实现：** `glOrtho(left, right, bottom, top, near, far)`，这六个参数定义了长方体视景体的六个面。

#### **2.2 透视投影 (Perspective Projection)**

*   **原理：** 所有投影线都汇聚于一点——**视点 (Center of Projection)**，即相机的位置。这完全模拟了人眼的成像原理。
*   **视景体：** 一个被远近两个平面截断的四棱锥，称为**视锥体 (Frustum)**。
*   **特点：**
    *   **近大远小：** 距离相机越远的物体，在屏幕上看起来越小，产生强烈的深度感。
    *   **透视收缩 (Foreshortening):** 平行线在远处会汇聚于**灭点 (Vanishing Point)**。这是艺术和现实世界中的基本视觉规律。
*   **OpenGL实现：**
    *   `glFrustum(left, right, bottom, top, near, far)`: 直接定义视锥体的六个面，功能强大但不直观。
    *   `gluPerspective(fovy, aspect, near, far)`: 更常用、更符合人类直觉的方式。
        *   `fovy`: 垂直方向的**视野角度 (Field of View)**，决定了镜头的“广角”程度。
        *   `aspect`: 视口的**宽高比 (Aspect Ratio)**，即 `width / height`。
        *   `near`, `far`: **近、远裁剪面**的距离。

**投影的数学本质** 无论是正交投影还是透视投影，其背后都是一个**投影矩阵**。这个矩阵会将视景体内的所有顶点，变换到一个统一的、规则的立方体空间中，这个空间称为**规范化观察体 (Canonical View Volume, CVV)** 或**裁剪空间 (Clip Space)**。CVV通常是一个从-1到+1的立方体。

透视投影的矩阵会产生一个奇妙的效果：它会将原来的视锥体“扭曲”成一个长方体。这个扭曲的过程，正是通过齐次坐标的`w`分量和后续的**透视除法**实现的，从而产生了“近大远小”的效果。

### **3\. 裁剪**

投影变换完成后，所有顶点都进入了裁剪空间。现在，判断一个物体是否在视野内就变得异常简单：

*   一个顶点 $(x, y, z)$ 在CVV内，当且仅当： $-1 \\le x \\le 1$ $-1 \\le y \\le 1$ $-1 \\le z \\le 1$

任何不满足这个条件的图元，都会被**裁剪 (Clipping)** 算法处理，部分或全部被丢弃。

### **4\. 视口变换：从标准画布到你的屏幕**

经过裁剪后，我们剩下的所有几何体都位于一个从-1到+1的标准立方体中。最后一步，就是**视口变换 (Viewport Transformation)**。

*   **目的：** 将这个标准化的、与设备无关的CVV坐标，映射到你屏幕上指定的像素区域——**视口 (Viewport)**。
*   **过程：** 本质上是一个简单的线性缩放和平移操作，将 x 和 y 坐标从 `[-1, 1]` 范围映射到 `[x, x+width]` 和 `[y, y+height]` 的像素范围。
*   **OpenGL实现：** `glViewport(x, y, width, height)`，其中(x,y)是视口左下角的像素坐标，width和height是视口的像素尺寸。

### **5\. 完整的视图管线总结**

现在，我们可以串联起整个流程，形成一个完整的从3D模型到2D图像的经典视图管线：

1.  **模型变换 (Modeling Transformation):**
    
    *   `模型坐标系` -> `世界坐标系`
    *   目的：在世界中摆放物体。
2.  **视图变换 (Viewing Transformation):**
    
    *   `世界坐标系` -> `相机坐标系`
    *   目的：确定相机位置和朝向。
    *   _(在OpenGL中，模型和视图变换通常合并为 **模型视图矩阵 (Model-View Matrix)**)_
3.  **投影变换 (Projection Transformation):**
    
    *   `相机坐标系` -> `裁剪空间 (CVV)`
    *   目的：定义视景体，进行降维。
4.  **裁剪 (Clipping):**
    
    *   在`裁剪空间`中，丢弃视景体外的几何体。
5.  **透视除法 (Perspective Division):**
    
    *   `裁剪空间` -> `规范化设备坐标 (NDC)`
    *   将坐标除以w分量，完成透视效果。
6.  **视口变换 (Viewport Transformation):**
    
    *   `NDC` -> `屏幕坐标系 (像素)`
    *   目的：将最终图像映射到屏幕窗口的指定区域。