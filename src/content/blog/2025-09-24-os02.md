---
title: "操作系统02:操作系统结构"
description: ""
pubDate: "2025-09-24"
heroImage: ""
---

# 操作系统02:操作系统结构

### 01.操作系统服务

一组操作系统服务提供对用户有用的功能：

*   用户接口：几乎所有操作系统都具备用户界面（UI）。其形式涵盖命令行界面（CLI）、图形用户界面（GUI）及批处理界面
*   程序生成：系统必须能够将程序加载到内存中并运行该程序，在正常或异常（指示错误）情况下终止执行。
*   I/O操作：正在运行的程序可能需要进行输入/输出操作，这可能涉及文件或输入/输出设备。
*   文件-系统操作：文件系统尤为重要。显然，程序需要读写文件和目录，创建和删除它们，搜索它们，列出文件信息，以及进行权限管理。
*   通信——进程可在同一台计算机上或通过网络在计算机之间交换信息。通信可通过共享内存或消息传递（由操作系统传输的数据包）实现
*   错误检测：操作系统需要时刻警惕可能出现的错误
    *   这些错误可能发生在CPU和内存硬件、I/O设备以及用户程序中
    *   对于每种错误类型，操作系统都应采取相应措施以确保计算的正确性和一致性
    *   调试功能能显著提升用户和程序员高效使用系统的能力

### 02.用户操作系统接口

**CLI**：  
命令行界面（CLI）允许直接输入命令。有时在内核中实现，有时由系统程序实现。有时实现多种变体——即各种shell。

主要功能是从用户处获取命令并执行，有时命令为内置命令（如DOS），有时仅为程序名称（如Unix）。若采用后者，新增功能无需修改shell

**GUI**

*   用户友好的桌面隐喻界面
    *   通常包含鼠标、键盘和显示器
    *   图标代表文件、程序、操作等
    *   鼠标在界面对象上点击不同按钮可触发多种操作（提供信息、选项、执行功能、打开目录（即文件夹））
*   现今多数系统同时包含命令行界面与图形界面
    *   微软Windows采用图形界面，并配备命令行“命令”外壳
    *   苹果Mac OS X采用“Aqua”图形界面，底层搭载UNIX内核并支持多种外壳
    *   Solaris采用命令行界面，可选配图形界面（Java桌面、KDE）

### 03.系统调用

##### 03.1.系统调用的实现

*   通常，每个系统调用都关联一个编号
    *   系统调用接口维护着一个表，该表根据这些编号进行索引
*   系统调用接口在操作系统内核中调用目标系统调用，并返回系统调用的状态及任何返回值。
*   调用者无需了解系统调用的具体实现方式
    *   只需遵守API规范，并理解操作系统在调用后将采取的行动
    *   操作系统接口的大部分细节通过API对程序员隐藏
        *   由运行时支持库管理（编译器附带库中内置的一组函数）

##### 03.2.API-系统调用-OS关系

flowchart TB %% --- 节点 --- A\["user application"\] B\["system call interface"\] C\["Implementation of open() system call"\] D\[(i)\] %% --- 连接（与原图流程一致） --- A -- "open()" --> B B -- "open()" --> C C -- "return" --> B B --> A %% 内核路径 B --> D D --> C %% --- 分区（用户态 / 内核态）--- subgraph U\["user mode"\] direction TB A end %% B 放在两个分区之外，居中像“接口层” subgraph K\["kernel mode"\] direction TB D C end

##### 03.3.系统调用参数传递

*   通常需要的信息不仅限于所需系统调用的标识
    *   具体信息类型和数量因操作系统和调用而异
*   向操作系统传递参数的三种通用方法
    *   最简单：通过寄存器传递参数
        *   某些情况下参数数量可能超过寄存器容量
    *   参数存储在内存中的块或表中，并将块地址作为寄存器参数传递
        *   Linux和Solaris采用此方法
    *   程序将参数放置（或压入）栈中，由操作系统从栈中弹出
    *   区块法与栈法均不受传递参数数量或长度的限制

### 04.系统调用的类型

*   Process control
*   File management
*   Device management
*   Information maintenance (e.g. time, date)
*   Communications

### 05.系统程序

系统程序为程序开发和执行提供了便捷的环境。它们可分为：

*   File manipulation
*   Status information
*   File modification
*   Communications
*   Application programs
*   Programming language support
*   Program loading and execution

大多数用户对操作系统的认知是由系统程序定义的，而非实际的系统调用。

提供便捷的程序开发与执行环境

*   其中部分仅作为系统调用的用户界面；另一些则复杂得多

文件管理——创建、删除、复制、重命名、打印、转储、列出，以及对文件和目录进行常规操作

状态信息

*   部分程序向系统查询信息——日期、时间、可用内存量、磁盘空间、用户数量
*   另一些则提供详细的性能、日志记录和调试信息
*   通常这些程序会将输出格式化后发送到终端或其他输出设备
*   部分系统实现注册表功能——用于存储和检索配置信息

文件修改

*   文本编辑器用于创建和修改文件
*   特殊命令用于搜索文件内容或执行文本转换  
    编程语言支持——有时提供编译器、汇编器、调试器和解释器  
    程序加载与执行-绝对加载器、可重定位加载器、链接编辑器、覆盖加载器，以及面向高级语言和机器语言的调试系统  
    通信功能-提供在进程、用户及计算机系统间建立虚拟连接的机制
*   支持用户间屏幕消息传递、网页浏览、电子邮件发送、远程登录及跨机文件传输

### 06.操作系统设计与实现

*   操作系统的设计与实现并非“可解决”问题，但某些方法已被证实有效
*   不同操作系统的内部结构可能存在显著差异
*   首先需明确目标与规格要求
*   受硬件选择与系统类型影响
*   用户目标与系统目标
    *   用户目标——操作系统应具备易用性、易学性、可靠性、安全性及运行速度
    *   系统目标——操作系统应易于设计、实现与维护，同时兼具灵活性、可靠性、无错误性及高效性
*   成功案例：Windows 95、Windows XP、OSX
*   失败案例：Windows Vista、Windows 8、Android 1.x

分离的重要原则（2.6.2）

*   策略：将采取什么行动？
*   机制：如何实施？

示例：CPU保护计时器即为机制

*   机制决定实施方式，策略决定行动内容
    *   策略与机制的分离是至关重要的原则，它确保了策略决策后续变更时的最大灵

### 07.操作系统结构

**Simple Structure**:

*   MS-DOS——旨在以最小空间实现最大功能
    *   未划分为模块
    *   尽管MS-DOS具有一定结构，但其接口与功能层级并未实现良好分离

**分层方法**

*   操作系统被划分为若干层级，每层都构建在更底层之上。底层（第0层）是硬件；顶层（第N层）是用户界面。
*   基于模块化设计，各层级仅调用其下层的功能（操作）与服务

**UNIX**  
UNIX——受硬件功能限制，原始UNIX操作系统结构较为简单。该操作系统由两个可分离部分构成：

*   系统程序
*   内核
    *   包含系统调用接口之下、物理硬件之上的所有组件
    *   提供文件系统、CPU调度、内存管理及其他操作系统功能；单一层级实现大量功能

flowchart TB %% 样式 classDef layer fill:#eaf6ff,stroke:#999,stroke-width:1px,color:#000; classDef bar fill:#d8d8dd,stroke:#999,stroke-width:1px,color:#000,font-style:italic; %% 顶层 U\[the users\] S\["shells and commands  
compilers and interpreters  
system libraries"\]:::layer U --> S %% Kernel（整体分组，仅作显示） subgraph Kernel\[kernel\] direction TB SC\["system-call interface to the kernel"\]:::bar %% 内核服务（横排） subgraph Services\[ \] direction LR K1\["signals terminal handling  
character I/O system  
terminal drivers"\]:::layer K2\["file system  
swapping block I/O system  
disk and tape drivers"\]:::layer K3\["CPU scheduling  
page replacement  
demand paging  
virtual memory"\]:::layer end KH\["kernel interface to the hardware"\]:::bar %% 硬件接口（横排） subgraph HW\[ \] direction LR H1\["terminal controllers  
terminals"\]:::layer H2\["device controllers  
disks and tapes"\]:::layer H3\["memory controllers  
physical memory"\]:::layer end end %% 连接 S --> SC SC --> K1 SC --> K2 SC --> K3 K1 --> KH K2 --> KH K3 --> KH KH --> H1 KH --> H2 KH --> H3

**Microkernel System Structure**

*   将更多功能从内核迁移至“用户”空间
*   用户模块间通过消息传递进行通信
*   优势：
    *   更易扩展微内核
    *   更易将操作系统移植至新架构
    *   更可靠（运行于内核模式的代码更少）
    *   更安全
*   劣势：
    *   用户空间与内核空间通信的性能开销

**Modules**

*   大多数现代操作系统都实现了内核模块
    *   采用面向对象的方法
    *   每个核心组件都是独立的
    *   它们通过已知接口相互通信
        *   模块之间通过调用而非消息传递进行交互
    *   每个模块都可在内核中按需加载
*   总体而言，类似于分层结构但更具灵活

### 08.虚拟机

*   虚拟机将分层方法推向了逻辑极致。它将硬件和操作系统内核都视为硬件实体。
    
*   虚拟机提供与底层裸机完全一致的接口。
    
*   操作系统营造出多进程的幻象，每个进程都在独立处理器上运行，拥有专属的（虚拟）内存。
    
*   物理计算机的资源被共享以创建虚拟机
    
    *   CPU调度机制可使用户获得专属处理器的体验
    *   后台处理与文件系统可提供虚拟读卡器和虚拟行式打印机
    *   普通用户分时终端充当虚拟机操作员控制台
*   虚拟机概念通过将每台虚拟机与其他虚拟机完全隔离，实现了对系统资源的全面保护。然而这种隔离机制不允许资源的直接共享。
    
*   虚拟机系统是操作系统研究与开发的理想载体。 系统开发在虚拟机而非物理机上进行，因此不会干扰正常系统运行。
    
*   虚拟机概念的实现难度较大，因为需要投入大量精力来精确复制底层机器（例如虚拟用户模式和内核模式）。
    

### 09.操作系统的生成

*   操作系统旨在运行于某类机器上；系统必须针对每个特定计算机站点进行配置
*   SYSGEN程序获取有关硬件系统具体配置的信息
*   启动——通过加载内核来启动计算机
*   引导程序——存储在ROM中的代码，能够定位内核、将其加载到内存并启动其执行

### 10.系统启动

操作系统必须向硬件提供启动条件，以便硬件能够启动它

*   一小段代码——引导程序（又称引导加载程序），定位内核，将其加载到内存并启动
*   有时采用两步过程：固定位置的引导区加载引导加载程序
*   系统通电初始化时，程序执行从固定内存地址开始
    *   固件用于存储初始启动代码