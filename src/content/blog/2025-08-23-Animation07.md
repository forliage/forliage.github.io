---
title: "计算机动画07:关节(角色)动画·上"
description: ""
pubDate: "2025-08-23"
heroImage: ""
---

# 计算机动画07:关节(角色)动画·上

### **第一部分：关节动画的魅力与应用**

在计算机动画的世界里，如果我们想让画面不仅仅是冰冷的几何体在移动，而是充满生命力，我们就需要引入**角色**——比如人、动物，甚至是会动的机器人。这些角色能让整个场景瞬间“活”起来。而**关节动画**，正是实现这一切的核心技术，是赋予这些角色生命和活力的基石。

#### **1.1 应用无处不在**

关节动画技术几乎渗透在我们数字生活的方方面面，它的应用深度和广度可能远超大家的想象。

**在游戏中，它是角色的灵魂...**

无论是你在《FIFA》里看到C罗振臂高呼的标志性庆祝动作，还是在《魔兽世界》里兽人战士充满力量的挥砍，又或者是在《英雄联盟》里英雄们释放的华丽技能，以及《NBA 2K》系列中篮球巨星们流畅的过人暴扣——所有这些栩栩如生的人物动作，背后都是由复杂的关节动画系统驱动的。它让虚拟角色能够模拟真实世界中复杂的运动。

**在动画中，它能赋予万物生命...**

这项技术的神奇之处在于，它不仅能用于有生命的角色。我们甚至可以为没有生命、软塌塌的物体（比如一个面粉袋）内部构建一套虚拟的“骨骼”。通过控制这套骨骼，我们就能让它像一个有思想、有情绪的角色一样，做出挤压、伸展、跳跃等拟人化的动作。这是动画师赋予物体“性格”的关键技巧。

**在电影中，它是视觉奇观的缔造者...**

电影工业是关节动画技术的集大成者。从早期的《恐龙》中栩栩如生的史前巨兽，到皮克斯经典《海底总动员》里悠闲游动的海龟，从史诗级的《金刚》那充满力量与情感的动作，到《加勒比海盗》中拥有章鱼触须、动作诡异的戴维·琼斯，再到《变形金刚》里那些结构无比复杂、变形流畅的机器人——它们每一个动作，每一个姿态，都离不开强大的关节动画技术。

特别是随着动作捕捉（Motion Capture）和表演捕捉（Performance Capture）技术的发展，如在《极地特快》（Polar Express）和后来的《阿丽塔：战斗天使》（Alita: Battle Angel）中，我们已经能将真人演员的精细表情和动作数据，实时地映射到虚拟角色的关节骨骼上，从而创造出前所未有的真实感和感染力。

### **第二部分：关节动画的核心模型与概念**

现在我们已经感受到了关节动画的强大，那么，它是如何从技术上实现的呢？我们需要掌握几个至关重要的核心概念。

#### **2.1 模型与骨骼 (Model and Skeleton)**

一个可动的角色通常由两部分组成：

1.  **模型（Model/Skin/Mesh）**: 这是我们最终在屏幕上看到的部分，也就是角色的“皮肤”或“外壳”，它通常是一个多边形网格。
2.  **骨骼（Skeleton/Rig）**: 这是隐藏在模型内部的一套驱动结构，它由一系列的\*\*关节（Joints）**和**连杆（Links，也常被称为骨骼 Bones）\*\*组成。

动画师并不直接去逐一拖拽模型上的每一个顶点，而是通过控制骨骼的运动，来间接地带动整个模型运动。这就好比我们人类，是骨骼带动肌肉和皮肤在运动。

graph TD A\[骨骼 Skeleton\] -- 驱动 Deforms --> B(模型 Model/Skin); subgraph A direction LR J1(关节 Joint) -- 连接 Connects --> L1(连杆 Link); L1 -- 连接 Connects --> J2(关节 Joint); J2 -- 连接 Connects --> L2(连杆 Link); end style B fill:#f9f,stroke:#333,stroke-width:2px

#### **2.2 模型层次 vs. 运动层次 (Model Hierarchy vs. Motion Hierarchy)**

为了有效地组织和控制骨骼，我们引入了**层次结构（Hierarchy）** 的概念。

*   **通常用相对运动来描述**：想象一下你的身体。你的小臂相对于大臂运动，大臂相对于肩膀运动，而肩膀又相对于躯干运动。我们不会去计算每个部位在世界中的绝对位置，而是描述这种“子级相对于父级”的运动关系。
*   **运动层次的构成**：
    *   **物体层次 + 相对运动 = 运动层次**。
    *   **连杆（Links）**: 代表身体的各个部分，比如大臂、小臂、手掌。
    *   **关节（Joints）**: 连接这些连杆，并定义了它们之间如何相对运动。
    *   **运动通常受限制**: 比如，你的膝盖只能向一个方向弯曲，而你的肩膀则可以进行更自由的旋转。这些限制是关节的固有属性，我们称之为**自由度（Degrees of Freedom, DOF）**。

#### **2.3 运动学 vs. 动力学 (Kinematics vs. Dynamics)**

在动画领域，我们经常听到两个词：运动学和动力学。它们的区别至关重要：

*   **运动学 (Kinematics)**: 研究的是**运动的几何性质**，即“如何运动”。它只关心位置、速度、加速度等，而不考虑引起这些运动的力。我们这门课的核心问题就是：“如何通过设置位置随时间的参数来对连杆设置动画？” 这就是运动学问题。
*   **动力学 (Dynamics)**: 研究的是**引起运动的力**，即“为何运动”。它会考虑质量、惯性、力、扭矩等物理量，通常用于物理模拟，比如布料飘动、碰撞效果等。

**今天，我们的焦点将完全集中在运动学上。**

#### **2.4 关节模型 (Articulated Model)**

一个关节角色可以被抽象成一个由连杆和关节组成的**树状结构**。

*   **把关节角色表示为一系列通过关节(joints)相连接的连杆(links)。**

graph TD subgraph 角色 A\[人体轮廓\] end subgraph 抽象 B\[几何分块\] end subgraph 骨骼 C\[关节和连杆\] end subgraph 树状数据结构 D{Root} D --- D1 --- D1\_1 --- D1\_2 D --- D2 --- D2\_1 --- D2\_2 D2\_1 --- D2\_1\_1 end A --> B --> C --> D

在这个树状结构中：

*   **节点（Node）**: 代表物体的某个部件（例如，大臂、头部）。
*   **边（Edge）**: 代表连接两个部件的关节，以及它们之间的相对变换。
*   **根节点（Root）**: 通常是角色的核心部分（如骨盆），它的位置和朝向是在世界坐标系中定义的。

#### **2.5 自由度 (Degrees of Freedom, DOF)**

**自由度**是指完全指定一个物体运动所需的最小独立坐标数目。

*   一个在三维空间中自由运动的刚体，拥有 **6个自由度 (6 DOF)**：
    *   3个平移自由度 (Translational DOF): 沿 X, Y, Z 轴的移动。
    *   3个旋转自由度 (Rotational DOF): 绕 X, Y, Z 轴的旋转（通常称为 Pitch, Yaw, Roll）。

对于关节模型：

*   **单个自由度关节**：只允许在一个方向上运动。
    *   **转动关节 (Revolute joint)**: 如肘关节，只允许旋转。
    *   **移动关节 (Prismatic joint)**: 如活塞，只允许平移。
*   **复杂关节**：拥有多个自由度。
    *   **2自由度关节**: 如手腕，可以向上下和左右弯曲。
    *   **3自由度关节**:
        *   **球状关节 (Ball and socket joint)**: 如肩关节，可以在三个轴向上自由旋转。
        *   **万向节 (Gimbal)**: 机械中常见的3自由度旋转接头。

一个重要的概念是：**一个n个自由度的复杂关节，可以看作是由n个1自由度的关节，通过n-1个长度为0的连杆串联而成。** 这在数学和编程实现上为我们提供了巨大的便利。

**人体模型的自由度**

一个典型的人体模型，其自由度分布大致如下：

*   **根节点 (Root)**: 位于骨盆，拥有全部6个自由度（3平移+3旋转），决定了角色在世界中的整体位置和朝向。
*   **其它关节**: 通常只使用旋转关节 (Rotational joints)。
    *   **肩关节 (Shoulder)**: 3 DOF
    *   **腕关节 (Wrist)**: 2 DOF
    *   **膝关节 (Knee)**: 1 DOF

#### **2.6 数据结构**

如何用代码来表示这种层次结构呢？我们通常使用一个树状的数据结构。

*   **层次连杆可用一树状结构来表示**：
    *   **根节点 (Root Node)**: 对应于物体的根部，其变换（位置和朝向）是在**世界坐标系**中给出的。
    *   **其它节点 (Child Nodes)**: 其变换是**相对于父节点**来表示的。
    *   **叶节点 (Leaf Nodes)**: 树的末端节点，如指尖、脚尖。

**代码实现思路**

我们可以定义一个`Joint`或`Node`的结构体/类：

```
#include <vector>
                #include <string>
                #include "glm/glm.hpp" // 使用GLM库处理向量和矩阵

                struct Joint {
                    std::string name;

                    // 相对于父节点的变换信息
                    glm::vec3 offset;       // 从父关节到此关节的平移（连杆的长度和方向）
                    glm::vec3 rotation;     // 此关节当前的旋转角度 (e.g., Euler angles)

                    // 层次结构关系
                    Joint* parent;
                    std::vector<Joint*> children;

                    // 计算出的变换矩阵
                    glm::mat4 localTransform; // 局部变换矩阵
                    glm::mat4 worldTransform; // 世界变换矩阵

                    // 构造函数和方法
                    Joint(const std::string& name, const glm::vec3& offset)
                        : name(name), offset(offset), rotation(0.0f), parent(nullptr) {}

                    void AddChild(Joint* child) {
                        children.push_back(child);
                        child->parent = this;
                    }
                    
                    // 更新变换矩阵的方法...
                };
                
```

### **第三部分：正向运动学 (Forward Kinematics, FK)**

现在，我们进入今天第一个核心技术点：**正向运动学**。

**定义**: **动画师通过直接指定每一个关节的运动参数（通常是旋转角度），系统据此计算出各个连杆以及末端执行器（End Effector，如手或脚）在世界空间中的最终位置和姿态。**

这是一种“从根到叶”的计算过程。你设定了因（关节角度），然后去求解果（最终位置）。

#### **3.1 层次变换的数学原理**

FK的核心就是矩阵的级联（concatenation）。一个子节点的世界坐标，是其父节点的世界坐标变换与其自身的局部坐标变换累积相乘的结果。

假设我们有一个顶点`V`，它定义在某个连杆 `Link_k` 的局部坐标系中。为了得到它在世界坐标系中的位置 `V'`，我们需要将从根节点到 `Link_k` 的所有变换矩阵依次左乘。

$$V' = M\_{world} \\cdot V = (M\_0 \\cdot M\_1 \\cdot ... \\cdot M\_k) \\cdot V$$

其中，`M_i` 是第 `i` 个节点相对于其父节点的局部变换矩阵。它通常由一个平移矩阵 `T_i` 和一个旋转矩阵 `R_i(θ_i)` 组成。

$$M\_i = T\_i \\cdot R\_i(\\theta\_i)$$

**让我们通过一个例子来理解这个过程：**

考虑一个两节的手臂 `Link_0 -> Link_1 -> Link_1,1`。

*   `V₀`: `Link₀` 上的一个顶点。
    
*   `V₁`: `Link₁` 上的一个顶点。
    
*   `V₁,₁`: `Link₁,₁` 上的一个顶点。
    
*   `T₀`: `Link₀`（根）在世界坐标系中的变换。
    
*   `T₁`: `Link₁` 相对于 `Link₀` 的平移变换（即`Link₀`的长度）。
    
*   `R₁(θ₁)`: `Link₁` 绕其关节的旋转。
    
*   `T₁,₁`: `Link₁,₁` 相对于 `Link₁` 的平移变换。
    
*   `R₁,₁(θ₁,₁)`: `Link₁,₁` 绕其关节的旋转。
    

那么，这些顶点在世界坐标系中的位置为：

*   $V\_0' = T\_0 \\cdot V\_0$
*   $V\_1' = T\_0 \\cdot (T\_1 \\cdot R\_1(\\theta\_1) \\cdot V\_1) = (T\_0 T\_1 R\_1(\\theta\_1)) \\cdot V\_1$
*   $V\_{1,1}' = T\_0 \\cdot T\_1 R\_1(\\theta\_1) \\cdot (T\_{1,1} R\_{1,1}(\\theta\_{1,1}) \\cdot V\_{1,1}) = (T\_0 T\_1 R\_1(\\theta\_1) T\_{1,1} R\_{1,1}(\\theta\_{1,1})) \\cdot V\_{1,1}$

**注意矩阵的顺序！** 变换是从父级到子级依次应用的。

#### **3.2 FK的实现：树的遍历**

计算整棵骨骼树的FK过程，本质上就是对树进行一次**深度优先遍历 (Depth-First Search, DFS)**。

**算法伪代码:**

```
// 使用一个矩阵栈来保存父节点的累积变换
                MatrixStack matrix_stack;
                matrix_stack.push(IdentityMatrix); // 初始为单位矩阵

                function TraverseAndCalculateFK(joint, parentWorldTransform):
                    // 1. 计算当前关节的局部变换矩阵
                    //    localTransform = TranslationMatrix(joint.offset) * RotationMatrix(joint.rotation)
                    joint.calculateLocalTransform();

                    // 2. 计算当前关节的世界变换矩阵
                    //    worldTransform = parentWorldTransform * localTransform
                    joint.worldTransform = parentWorldTransform * joint.localTransform;

                    // 3. 递归遍历所有子关节
                    for each child in joint.children:
                        TraverseAndCalculateFK(child, joint.worldTransform);

                // 从根节点开始调用
                TraverseAndCalculateFK(root_joint, IdentityMatrix);
                
```

#### **3.3 FK例子：一个三连杆平面臂**

让我们来计算一个具体的例子。假设一个平面上的三连杆机械臂，Base在原点。

*   连杆长度: $l\_1, l\_2, l\_3$
*   关节角度: $\\theta\_1, \\theta\_2, \\theta\_3$ (相对于水平轴或上一连杆)

末端影响器 (End Effector) 的坐标 $(x, y)$ 是什么？

我们可以通过累加每个连杆在$X$和$Y$轴上的投影来得到：

*   **连杆1的末端坐标**: $(l\_1 \\cos(\\theta\_1), l\_1 \\sin(\\theta\_1))$
*   **连杆2的相对朝向**: $\\theta\_1 + \\theta\_2'$ (这里假设 $\\theta\_2$ 是相对角度，为了简单起见，我们定义所有角度都相对于一个固定的轴，比如水平轴，如上图所示)。
    *   根据图示，$\\theta\_2$ 是与一个向下延伸的虚线的夹角。如果水平线为0度，连杆1的角度是$\\theta\_1$，那么连杆2与水平线的夹角是 $\\theta\_1 - (180 - \\theta\_2')$，这很复杂。
    *   **让我们重新定义角度**，让问题更清晰：设 $\\theta\_1, \\theta\_2, \\theta\_3$ 均为连杆与**水平正方向**的夹角。
    *   那么末端坐标 $(x, y)$ 就是所有连杆在x和y方向上的分量之和： $$x = l\_1 \\cos(\\theta\_1) + l\_2 \\cos(\\theta\_2) + l\_3 \\cos(\\theta\_3)$$ $$y = l\_1 \\sin(\\theta\_1) + l\_2 \\sin(\\theta\_2) + l\_3 \\sin(\\theta\_3)$$
    *   **如果角度是相对的** (即 $\\theta\_i$ 是 `link_i` 相对于 `link_{i-1}` 的角度)，则：
        *   `link_1` 的世界角度是 $\\theta\_1$
        *   `link_2` 的世界角度是 $\\theta\_1 + \\theta\_2$
        *   `link_3` 的世界角度是 $\\theta\_1 + \\theta\_2 + \\theta\_3$
        *   最终坐标为： $$x = l\_1 \\cos(\\theta\_1) + l\_2 \\cos(\\theta\_1 + \\theta\_2) + l\_3 \\cos(\\theta\_1 + \\theta\_2 + \\theta\_3)$$ $$y = l\_1 \\sin(\\theta\_1) + l\_2 \\sin(\\theta\_1 + \\theta\_2) + l\_3 \\cos(\\theta\_1 + \\theta\_2 + \\theta\_3)$$

这就是正向运动学——**给定关节参数，求解末端位置**。

### **第四部分：逆向运动学 (Inverse Kinematics, IK)**

现在，我们来看问题的另一面，这也是关节动画中更强大但也更具挑战性的部分：**逆向运动学**。

**定义**: **动画师指定末端执行器（End Effector）的目标位置和/或姿态，系统反向求解出为了达到该目标，关节链中所有关节需要设置的角度。**

这是一种“从叶到根”的思考方式。你设定了果（目标位置），然后去反向求解因（关节角度）。这非常符合我们的直觉：当你想拿起桌上的杯子时，你不会去想“我的肩膀要转30度，肘部要弯70度...”，你只会想着“让我的手移动到杯子的位置”，你的大脑会自动为你完成IK的计算。

#### **4.1 IK的挑战**

IK问题远比FK复杂，因为它面临着几个固有的难题：

1.  **解的存在性**:
    
    *   **无解**: 如果目标点超出了机械臂的可达范围，那么IK问题无解。
    *   **唯一解**: 这种情况非常罕见，通常只在关节数量和约束条件恰好匹配时出现。
    *   **多解/无穷多解**: 这是最常见的情况。对于一个简单的2D两连杆手臂，到达一个点通常就有两种姿态（“肘朝上”和“肘朝下”）。对于拥有更多关节的人体手臂（肩、肘、腕），可以到达同一个目标点的姿态有无穷多种。我们称之为**冗余 (Redundancy)**。
    
    graph TD subgraph "多解情况 (Multiple Solutions)" direction LR Base((Base)) Target{Target} ElbowUp(Elbow Up) ElbowDown(Elbow Down) Base -- L1 --> ElbowUp -- L2 --> Target Base -- L1 --> ElbowDown -- L2 --> Target end subgraph "无解情况 (No Solution)" direction LR Base2((Base)) -- L1 --> Elbow2((Elbow)) -- L2 --> EndEffector(End) Target2{Target is out of reach} end style Target fill:#f00,stroke:#333,stroke-width:2px style Target2 fill:#f00,stroke:#333,stroke-width:2px
    
2.  **奇异性 (Singularities)**: 在某些特定的关节构型下，关节链会失去一个或多个自由度，导致无法向某些方向移动。最常见的例子就是手臂完全伸直时，你无法让手在伸直的方向上再“向前”移动。在这些点上，IK的数学解会变得不稳定或无定义。
    
3.  **求解的复杂性**: FK的方程是直接的三角函数，而IK要求解的是一组高度**非线性**的三角函数方程组，这通常没有简单的代数解。
    

#### **4.2 求解IK的方法：解析法**

对于非常简单的关节链（比如2D两连杆手臂），我们可以通过几何或代数方法找到**解析解（Analytical Solution）**。

**例子：2D两连杆手臂的解析解**

让我们来推导这个经典问题的解。

*   已知：连杆长度 $L\_1, L\_2$，目标点坐标 $(X, Y)$。
*   求解：关节角度 $\\theta\_1, \\theta\_2$。

**推导步骤:**

1.  **建立几何关系** 我们有一个由原点(0,0)、肘关节、目标点(X,Y)构成的三角形。三条边的长度分别是 $L\_1, L\_2$ 和 $D = \\sqrt{X^2 + Y^2}$。
    
    graph LR Base("Base (0,0)") -- L1 --> Elbow((Elbow)); Elbow -- L2 --> Goal("Goal (X,Y)"); Base -. "D = sqrt(X²+Y²)" .-> Goal;
    
2.  **使用余弦定理求解 $\\theta\_2$** 在 $\\triangle ABC$ 中，根据余弦定理： $$D^2 = L\_1^2 + L\_2^2 - 2L\_1L\_2 \\cos(\\alpha)$$ 其中 $\\alpha$ 是肘关节处的内角。
    
    $$\\cos(\\alpha) = \\frac{L\_1^2 + L\_2^2 - D^2}{2L\_1L\_2} = \\frac{L\_1^2 + L\_2^2 - (X^2 + Y^2)}{2L\_1L\_2}$$
    
    从图中可以看出，我们定义的关节角 $\\theta\_2$ 与内角 $\\alpha$ 的关系是 $\\alpha = 180^\\circ - \\theta\_2$ (假设 $\\theta\_2$ 为正代表向外弯曲)。 因为 $\\cos(180^\\circ - \\theta\_2) = -\\cos(\\theta\_2)$，所以： $$-\\cos(\\theta\_2) = \\frac{L\_1^2 + L\_2^2 - X^2 - Y^2}{2L\_1L\_2}$$
    
    $$\\cos(\\theta\_2) = \\frac{X^2 + Y^2 - L\_1^2 - L\_2^2}{2L\_1L\_2}$$
    
    因此，$\\theta\_2$ 的解是： $$\\theta\_2 = \\pm \\arccos\\left(\\frac{X^2 + Y^2 - L\_1^2 - L\_2^2}{2L\_1L\_2}\\right)$$
    
    这里的 `+` 和 `-` 分别对应“肘朝下”和“肘朝上”的两种情况。
    
3.  **求解 $\\theta\_1$** 现在我们知道了 $\\theta\_2$，如何求 $\\theta\_1$？ $\\theta\_1$ 可以看作是两个角度的和或差：$\\theta\_1 = \\beta \\pm \\gamma$
    
    *   $\\beta$ 是从Base到Goal点的连线与X轴的夹角。 $\\beta = \\text{atan2}(Y, X)$ (使用 `atan2` 函数可以正确处理所有象限)。
    *   $\\gamma$ 是 $\\triangle ABC$ 在Base处的内角。
    
    再次使用余弦定理求 $\\gamma$： $$L\_2^2 = L\_1^2 + D^2 - 2L\_1D \\cos(\\gamma)$$ $$\\cos(\\gamma) = \\frac{L\_1^2 + D^2 - L\_2^2}{2L\_1D} = \\frac{L\_1^2 + X^2 + Y^2 - L\_2^2}{2L\_1\\sqrt{X^2+Y^2}}$$ $$\\gamma = \\arccos\\left(\\frac{L\_1^2 + X^2 + Y^2 - L\_2^2}{2L\_1\\sqrt{X^2+Y^2}}\\right)$$
    
    最终，$\\theta\_1$ 的解是： $$\\theta\_1 = \\text{atan2}(Y, X) \\mp \\gamma$$
    
    注意这里的 `∓` 与 $\\theta\_2$ 的 `±` 是对应的。如果 $\\theta\_2$ 取正值（肘朝下），则 $\\theta\_1$ 要减去 $\\gamma$；如果 $\\theta\_2$ 取负值（肘朝上），则 $\\theta\_1$ 要加上 $\\gamma$。
    

**解析法的局限**: 这种方法虽然精确，但只适用于非常简单的结构。对于超过3个关节的链，或者在三维空间中，代数方程会变得异常复杂甚至无解。因此，在实际应用中，我们更多地依赖**数值法**。

#### **4.3 求解IK的方法：数值法 (简介)**

当解析法失效时，我们采用迭代的数值方法来**逼近**解。这些方法的基本思想是：

1.  从当前的关节姿态开始。
2.  计算末端执行器当前位置与目标位置的差距（误差）。
3.  根据这个误差，微调所有关节的角度，使得末端执行器向目标靠近一小步。
4.  重复步骤2和3，直到误差小于一个可接受的阈值，或者达到最大迭代次数。

常见的数值求解IK的方法包括：

*   **逆向雅可比方法 (Inverse-Jacobian method)**: 这是最经典和流行的方法之一，它通过一个叫做“雅可比矩阵”的工具来建立关节速度和末端执行器速度之间的线性关系。
*   **循环坐标下降法 (Cyclic Coordinate Descent, CCD)**: 一种更简单直观的方法，它从末端关节开始，依次旋转每个关节，使其指向目标。
*   **FABRIK (Forward And Backward Reaching Inverse Kinematics)**: 一种基于几何的迭代方法，通过前后拉伸关节链来逼近目标。
*   **基于优化的方法 (Optimization-based method)**: 将IK问题看作是一个优化问题，目标是最小化末端执行器与目标之间的距离，同时可能考虑其它约束（如关节限制、保持平衡等）。

我们将在下一讲中，详细深入地探讨这些强大的数值方法，特别是逆向雅可比方法。