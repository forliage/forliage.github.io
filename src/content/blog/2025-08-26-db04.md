---
title: "数据库系统04:实体-关系模型(E-R Model)"
description: ""
pubDate: "2025-08-26"
heroImage: ""
---

# 数据库系统04:实体-关系模型(E-R Model)

### **引言：**

想象一下，客户找到你，要你开发一个大学教务系统。他们的需求是这样的：“我们需要管理学生、课程和教授，学生可以选课，教授可以教课，每个系都有自己的课程和学生...”

如果你听到这里，立刻打开终端开始`CREATE TABLE student...`，那么一场灾难几乎是注定的。为什么？

*   “一个学生能选多少门课？一门课最多有多少学生？”
*   “一个教授能教几门课？一门课可以由多个教授合上吗？”
*   “学生和课程的联系，跟教授和课程的联系，是一回事吗？”

直接进入表设计，就像一个建筑师不画设计图纸就直接让施工队开工。你会陷入无休止的细节、歧义和返工中。

**E-R模型的设计哲学：**

**它是一种高层次的、独立于具体数据库实现的概念数据模型。其核心目的是：**

1.  **沟通工具：** E-R图直观、易懂，可以作为与客户、产品经理、非技术人员沟通的“共同语言”，确保所有人对业务需求的理解是一致的。
2.  **分析工具：** 强迫设计师系统性地思考现实世界中的“事物”（实体）、“事物之间的联系”（关系）以及它们的“特性”（属性）。
3.  **设计蓝图：** E-R模型一旦确定，就可以作为一份精确的说明书，指导后续的逻辑设计（关系模式）和物理设计。

E-R模型由陈品山（Peter Chen）在1976年提出，它的伟大之处在于，它提供了一套简单而强大的符号，让我们能够把现实世界的“故事”画成一张清晰的地图。

### **第一部分：E-R模型的基本构件**

#### **1.1 实体 (Entity) 与实体集 (Entity Set)**

*   **实体 (Entity):** 现实世界中一个**可区分**的对象。它可以是物理存在的（一个学生、一本书），也可以是概念上的（一门课程、一次银行交易）。
*   **实体集 (Entity Set):** 具有**相同类型**和**相同属性**的实体的集合。在E-R图中用**矩形**表示。例如：`学生(Student)`、`课程(Course)`。

#### **1.2 属性 (Attribute)：实体的特征**

实体是通过属性来描述的。在E-R图中用**椭圆形**表示，并通过线连接到其所属的实体集。

**属性的分类与设计哲学：**

*   **简单属性 vs. 复合属性 (Simple vs. Composite)**
    
    *   **简单属性 (Simple):** 不可再分的原子值，如`age`。
    *   **复合属性 (Composite):** 可分解为多个更小的部分，如`name`可以分解为`first_name`, `last_name`。
    *   **设计哲学：** 建模时保留复合属性，可以更清晰地表达业务概念（“姓名”是一个整体）。但在最终转换为关系表时，复合属性的**叶子节点**（`first_name`, `last_name`）通常会成为表的列，因为关系模型的第一范式要求列的原子性。
*   **单值属性 vs. 多值属性 (Single-valued vs. Multi-valued)**
    
    *   **单值属性 (Single-valued):** 对任何实体，该属性只有一个值，如`student_id`。
    *   **多值属性 (Multi-valued):** 一个实体可以有多个该属性的值，如`phone_numbers`。在E-R图中用**双线椭圆**表示。
    *   **设计哲学：** E-R模型允许我们直接表达“一个学生有多个电话”这个概念。但在关系模型中，表的一个单元格不能存放多个值。因此，在转换时，多值属性通常需要被**分离成一个独立的新表**。这是E-R模型灵活性与关系模型严格性之间的一个重要转换点。
*   **派生属性 vs. 基属性 (Derived vs. Stored)**
    
    *   **基属性 (Stored):** 需要物理存储的属性，如`date_of_birth`。
    *   **派生属性 (Derived):** 其值可以从其他属性计算得出，如`age`可以由`date_of_birth`和当前日期计算。在E-R图中用**虚线椭圆**表示。
    *   **设计哲学：** 识别派生属性是为了**减少数据冗余**和**避免不一致性**。如果存储了`age`，那么每年都需要去更新所有人的年龄，很容易出错。在设计层面标识出`age`是派生的，意味着在最终的表中，我们通常只存储`date_of_birth`，而`age`则在查询时动态计算。

#### **1.3 关系 (Relationship) 与关系集 (Relationship Set)**

*   **关系 (Relationship):** 两个或多个实体之间的**关联**。
    
*   **关系集 (Relationship Set):** **同类型**关系的集合。在E-R图中用**菱形**表示。例如，`advisor`是一个连接`学生`和`教授`的关系集。
    
*   **关系的度 (Degree):** 参与一个关系集的实体集的数量。
    
    *   **二元 (Binary):** 最常见，连接两个实体集（如：学生 `选修` 课程）。
    *   **三元 (Ternary):** 连接三个实体集。**何时需要三元关系？** 当一个关联本身必须同时涉及三个实体才能完整表达其含义时。例如，一个`项目(Project)`需要`员工(Employee)`使用某种`技能(Skill)`。这个“使用”关系是三元的。如果拆成三个二元关系（员工-项目，员工-技能，项目-技能），就丢失了“在哪个项目上使用哪种技能”的精确信息。
    *   **设计哲学：** 尽量使用二元关系。只有当业务逻辑无法被多个二元关系无损地表达时，才考虑使用多元关系。
*   **关系集的属性：** 关系本身也可以有属性，用来描述这个关联的特征。例如，在`学生`和`课程`的`选修(takes)`关系中，`grade`（成绩）就是一个描述“选修”这个行为的属性。
    

### **第二部分：定义规则 —— 约束**

E-R模型不仅描述结构，更重要的是描述规则。

#### **2.1 映射基数 (Mapping Cardinality)：数量的约束**

映射基数定义了一个实体通过一个关系集能与多少个其他实体关联。对于二元关系，主要有四种：

*   **一对一 (One-to-One):** 一个`国家(Country)`只有一个`首都(Capital)`，一个`首都`也只属于一个`国家`。E-R图中用 `1 <--> 1` 表示。
*   **一对多 (One-to-Many):** 一个`部门(Department)`可以有多个`员工(Employee)`，但一个`员工`只属于一个`部门`。E-R图中用 `1 <--> N` (或 `1 <--> M`) 表示。
*   **多对一 (Many-to-One):** `员工`与`部门`关系的另一视角。
*   **多对多 (Many-to-Many):** 一个`学生(Student)`可以选修多门`课程(Course)`，一门`课程`也可以被多个`学生`选修。E-R图中用 `N <--> M` 表示。

**设计哲学：** 基数约束是数据库设计的**核心**。它直接决定了后续转换成关系表时，外键该放在哪里，或者是否需要创建额外的关联表。

*   **1:1** -> 外键可以放在任意一边，或者合并成一张表。
*   **1:N** -> 外键必须放在“多”的那一端，指向“一”的那一端的主键。
*   **M:N** -> 必须创建一个新的关联表（或称连接表、桥接表），该表的主键通常是两边实体主键的组合。

#### **2.2 参与约束 (Participation Constraints)：存在性的约束**

*   **全部参与 (Total Participation):** 实体集中的**每一个**实体都必须参与到该关系中。例如，每一门`课程(Course)`都必须属于一个`系(Department)`。在E-R图中，用一条**双线**连接实体集和关系集。
*   **部分参与 (Partial Participation):** 实体集中的实体可以不参与该关系。例如，不是每一个`教授(Professor)`都必须是`系主任(manages)`。这是默认情况，用**单线**表示。

**设计哲学：** 参与约束最终会影响关系表中外键列的`NOT NULL`约束。

*   如果`Course`在与`Department`的关系中是**全部参与**，那么在转换成的`Course`表中，`dept_id`这个外键列必须是\*\*`NOT NULL`\*\*的。

#### **2.3 键 (Keys)：唯一性的保证**

*   **超键 (Super Key):** 能唯一标识实体集中一个实体的一个或多个属性的集合。
*   **候选键 (Candidate Key):** 最小的超键。
*   **主键 (Primary Key):** 被设计者选定的、用于唯一标识实体的候选键。在E-R图中，主键的属性名下有**下划线**。

### **第三部分：处理复杂性 —— 高级E-R概念**

#### **3.1 弱实体集 (Weak Entity Set)**

**思考一个问题：** 对于一栋教学楼，它的房间号是“101”, “102”... 对于另一栋楼，也有“101”, “102”。那么“101”这个房间号能唯一标识一个房间吗？不能。它必须依赖于它所在的“教学楼”才能被唯一标识。

*   **弱实体集：** 一个自身没有足够属性形成主键的实体集。它的存在**依赖于**另一个**强实体集**。例如：`房间(Room)`。
*   **强实体集 (或标识实体集):** 为弱实体集提供标识的实体集。例如：`教学楼(Building)`。
*   **标识关系 (Identifying Relationship):** 连接强弱实体集的关系。
*   **分辨符 (Discriminator / Partial Key):** 弱实体集中，能够区分**在同一个强实体下**的不同弱实体的属性。例如：`room_number`。在E-R图中用**虚下划线**表示。

**E-R图表示：**

*   弱实体集用**双线矩形**。
*   标识关系用**双线菱形**。

**弱实体集的主键 = 强实体集的主键 + 弱实体集的分辨符。** 例如，一个`Room`实体的主键是 `{building_id, room_number}`。

**设计哲学：** 弱实体集模型精确地捕捉了现实世界中的“拥有”或“从属”关系，这种关系中，子实体的身份是与父实体绑定的。

#### **3.2 扩展E-R (EER) 特性：继承与抽象**

*   **特化 (Specialization)：自顶向下**
    
    *   **概念：** 将一个通用的实体集（超类）根据某些特征区分为更具体的子实体集（子类）。例如，将`人(Person)`特化为`学生(Student)`和`教员(Instructor)`。
    *   `Student`和`Instructor`会**继承**`Person`的所有属性（如`name`, `address`），并拥有自己**特有**的属性（如`Student`有`tot_cred`，`Instructor`有`salary`）。
    *   在E-R图中用一个**空心三角箭头**指向超类，并用`ISA`（is a）表示。
*   **泛化 (Generalization)：自底向上**
    
    *   **概念：** 将多个具有共同属性的实体集（子类）抽象出一个更通用的实体集（超类）。例如，从`轿车(Car)`和`卡车(Truck)`中泛化出`车辆(Vehicle)`。
    *   特化和泛化是同一概念的两种不同视角，在E-R图中表示法相同。

**设计约束：**

*   **不相交 (Disjoint) vs. 重叠 (Overlapping):**
    *   `Disjoint`: 一个超类实体最多只能是一个子类的成员（如一个人不能既是`Student`又是`Instructor`）。
    *   `Overlapping`: 允许同时是多个子类的成员。
*   **全部 (Total) vs. 部分 (Partial):**
    *   `Total`: 每个超类实体**必须**是某个子类的成员（如每个`Person`都必须是`Student`或`Instructor`）。
    *   `Partial`: 允许超类实体不属于任何一个子类。

**设计哲学：** 继承（ISA关系）是面向对象思想在数据建模中的应用。它能极好地处理“is a kind of”关系，减少了模型冗余，提高了模型的表达力和可扩展性。

*   **聚集 (Aggregation)：将关系视为实体**
    *   **问题：** 如何表达“关系”与“实体”之间的关系？例如，一个`员工(Employee)`被指派去**监督**一个`项目(Project)`的某个`工作(Job)`。这里的“监督(sponsorship)”关系，其对象不是`Project`也不是`Job`，而是“在某个项目上的某个工作”这个**关联本身**。
    *   **解决方案：** 聚集允许我们将一个关系集（如`proj_job`）及其参与的实体集（`Project`, `Job`）**打包**成一个抽象的、更高层次的“聚合实体”，然后让其他实体（如`Employee`）与这个聚合体建立关系。
    *   在E-R图中，用一个**虚线框**将要聚集的部分框起来。

**设计哲学：** 聚集提供了一种处理复杂关联的**抽象机制**，它提升了模型的层次，使得我们可以把一个复杂的子系统看作一个单一的单元来对待。

### **第四部分：从E-R图到关系模式 —— 系统的转换算法**

这是将设计蓝图变为具体施工指令的关键一步。以下是一套可以机械执行的规则：

1.  **强实体集：** 为每个强实体集创建一个同名表。表的列是该实体集的所有**简单属性**（复合属性则取其叶子节点）。主键就是实体集的主键。
2.  **弱实体集：** 为每个弱实体集创建一个表。
    *   列 = 弱实体集的所有属性 + **标识强实体集的主键**（作为外键）。
    *   表的主键 = **强实体集的主键 + 弱实体集的分辨符**。
3.  **关系集：**
    *   **多对多 (M:N):** 创建一个新表。
        *   列 = 参与关系的所有实体集的主键（作为外键） + 关系集自身的属性。
        *   主键 = 参与关系的所有实体集的主键的**组合**。
    *   **一对多 (1:N) / 一对一 (1:1):** **不创建新表**。在“多”端（或任意一端）的实体表里，添加“一”端实体的主键作为**外键**。关系集的属性也一并添加到该表中。
4.  **多值属性：** 为每个多值属性创建一个新表。
    *   列 = 拥有该属性的实体集的主键（作为外键） + 多值属性本身。
    *   主键 = 两列的组合。
5.  **继承 (ISA关系):** 有多种策略，各有优劣。
    *   **策略一（每个实体一个表）：** 为超类和每个子类都创建一个表。子类的表只包含其特有属性和超类的主键（作为主键和外键）。获取一个子类的完整信息需要**连接查询**。
    *   **策略二（所有子类一个表）：** 只为每个子类创建一个表。每个子类的表包含**继承的属性**和**自身的属性**。超类不创建表（或用视图模拟）。访问单个子类很快，但如果要查询所有`Person`，则需要`UNION`多个表。
    *   **策略三（所有实体一个表）：** 只创建一个大表，包含超类和所有子类的**全部属性**，外加一个`type`字段来区分实体类型。对于不适用的属性，其值为`NULL`。**优点：** 无需连接。**缺点：** 大量`NULL`值，空间浪费，违反范式。

**设计决策：** 继承的转换策略没有绝对的好坏，需要根据查询模式（是经常查父类还是子类？）、数据重叠度等因素来权衡选择。