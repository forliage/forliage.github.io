---
title: "x86汇编10-2:保护模式进阶"
description: ""
pubDate: "2025-08-25"
heroImage: ""
---

# x86汇编10-2:保护模式进阶

### **引言**

想象一下两个国家，一个是平民区（Ring 3），一个是戒备森严的中央政务区（Ring 0）。平民不能随意闯入政务区，否则会被卫兵（CPU硬件异常）立即逮捕。但是，平民需要办事，比如办理护照（文件IO）。

解决方案是什么？在两个区域的边界上设立一个\*\*“大使馆”或“政务服务大厅”\*\*。这个大厅本身有明确的地址，平民被允许进入。进入后，你不能乱跑，只能到指定的窗口，提交你的申请，由内部的工作人员（高权限代码）为你办理，办完后将结果交给你，然后你离开。

在x86保护模式中，这个“服务大厅”就是**门描述符（Gate Descriptor）**。

### **1 调用门 (Call Gate)**

调用门是为\*\*应用程序主动请求操作系统服务（即系统调用）\*\*而设计的。

#### **1.1 什么是调用门？**

*   **定义**: 调用门是一个**系统段描述符**（S=0，Type=12），它不指向一段内存，而是定义了一个受控的**远过程调用（Far Call）**。它本质上是一个安全的“传送门”，其描述符中包含了传送的目标地址和规则。
    
*   **位置**: 调用门描述符可以存放在GDT或LDT中。
    
*   **结构 (8字节)**:
    
    *   **目标代码段选择子 (Destination Selector)**: 目标过程（通常是Ring 0）的代码段选择子。
    *   **目标偏移 (Destination Offset)**: 目标过程在代码段内的32位入口地址。
    *   **DPL (Descriptor Privilege Level)**: **门本身的权限**。这至关重要，它规定了**谁有资格使用这个门**。通常设置为3，表示Ring 3的应用程序可以使用。
    *   **参数数量 (Parameter Count)**: 指定在发生特权级切换时，需要从调用者（低权限）的堆栈上复制多少个参数（以`DWORD`为单位）到被调用者（高权限）的堆栈上。
    *   **P (Present) 位**: 该门是否有效。
*   **设计哲学**: 调用门的设计体现了**最小权限原则**和**接口封装**。
    
    1.  **受控入口**: 应用程序不能跳转到内核的任意位置，只能跳转到调用门指定的**唯一入口点**。这防止了恶意代码绕过安全检查，直接执行内核的危险代码。
    2.  **权限隔离**: 应用程序只是“使用”门（`CALL`一个门选择子），它对门背后的Ring 0代码一无所知，也无法修改。

#### **1.2 调用门相关的`CALL`和`RETF`指令**

当一个`CALL FAR`指令的操作数指向一个调用门选择子时，CPU会执行一套极其复杂的、由硬件固化的操作流程。

**`CALL FAR gate_selector:offset` (offset会被忽略) 的硬件执行流程:**

1.  **权限检查**:
    *   **检查1 (访问门)**: `CPL <= Gate DPL` 并且 `RPL <= Gate DPL`。确保当前代码和请求者有权使用这个门。
    *   **检查2 (目标代码段)**: 调用门指向的目标代码段描述符的`DPL`必须**小于等于**`CPL`。即，只允许通过调用门**转移到同级或更高权限**的代码段。
2.  **如果发生特权级提升 (例如，从Ring 3 -> Ring 0):**
    *   **堆栈切换 (Stack Switch)**: 这是最关键的安全机制。CPU不能继续使用Ring 3的堆栈，因为它不安全、不可靠且可能空间不足。CPU会：
        1.  查找当前任务的**任务状态段 (TSS)**（由`TR`寄存器指向）。
        2.  从TSS中取出为目标特权级（Ring 0）预先准备好的堆栈指针：`SS0`和`ESP0`。
        3.  加载`SS0`和`ESP0`到`SS`和`ESP`寄存器，切换到内核的安全堆栈。
    *   **参数复制**:
        1.  CPU将旧的`SS`和`ESP`（Ring 3的堆栈指针）压入**新的内核堆栈**。
        2.  根据调用门描述符中的**参数数量**，将指定数量的参数从旧堆栈复制到新堆栈。
    *   **压入返回地址**:
        1.  将旧的`CS`和`EIP`（Ring 3的返回地址）压入新堆栈。
3.  **加载并跳转**:
    *   将调用门中指定的**目标代码段选择子**和**目标偏移**加载到`CS`和`EIP`寄存器。
    *   `CS`中的`CPL`此时更新为目标代码段的DPL（即0）。
    *   CPU开始从Ring 0的新地址执行。

**`RETF` (Far Return) 的硬件执行流程:** 当Ring 0的代码执行`RETF`时，CPU会检查栈上的返回地址`CS`选择子，发现其`RPL`为3，就知道这是一次跨级返回。

1.  CPU执行权限检查。
2.  从当前（内核）堆栈上弹出`EIP`, `CS`, `ESP`, `SS`，恢复到Ring 3的状态。
3.  堆栈切换回用户空间。
4.  （可选）如果`RETF`带有操作数（如`RETF 8`），会在**返回后**调整用户堆栈指针，用于清理参数。

#### **1.3 任务状态段 (TSS) 与任务切换**

*   **TSS (Task State Segment)**: 是内存中一个特殊的数据结构，用于保存一个任务（进程或线程）的完整上下文（所有寄存器的值、LDT选择子、I/O权限位图等）。
*   **在门调用中的核心作用**: TSS在现代操作系统中很少用于硬件任务切换（因为效率不高），但它有一个**不可替代**的作用：为每个任务提供**特权级0、1、2的堆栈指针（`SS0/ESP0`, `SS1/ESP1`, `SS2/ESP2`）**。
*   **设计哲学**: 操作系统在创建每个进程时，都会为其创建一个TSS，并在TSS中填好该进程的内核堆栈地址。当该进程通过调用门或中断进入内核时，CPU硬件能自动、安全地找到正确的内核堆栈，实现了**进程间的内核堆栈隔离**。

#### **1.4 调用门实例**

一个Ring 3程序通过调用门调用Ring 0的代码，在屏幕上打印一条消息。

```
; --- GDT 定义 ---
                ; ... (NULL, Ring0 Code/Data, Ring3 Code/Data 描述符) ...
                GDT_CALL_GATE_SELECTOR EQU $ - GDT_BASE
                gdt_call_gate:
                    DW gate_offset_low      ; 目标偏移 0-15
                    DW GDT_RING0_CODE_SELECTOR ; 目标代码段选择子
                    DB 0                    ; 参数数量 (0-4位) & 保留位
                    DB 11101100b            ; Type=CallGate, S=0, DPL=3, P=1
                    DW gate_offset_high     ; 目标偏移 16-31

                ; --- Ring 3 代码 ---
                CALL FAR [cs:gdt_call_gate] ; 调用门，offset部分会被忽略

                ; --- Ring 0 处理程序 (由门指向) ---
                gate_handler:
                    ; 此时CPL=0, 运行在独立的内核堆栈上
                    ; ... 在屏幕打印 "Hello from Ring 0!" 的代码 ...
                    RETF
                
```

### **2 中断门与陷阱门——意外事件的“紧急通道”**

硬件中断和CPU异常是不可预知的事件。当中断发生时，如果CPU正运行在Ring 3，而中断处理程序在Ring 0，同样需要一个安全的跨级机制。这个机制就是**中断门**和**陷阱门**。

#### **2.1 什么是中断门/陷阱门？**

*   **定义**: 它们也是系统段描述符，结构与调用门非常相似，但用于处理中断和异常。
*   **位置**: 必须存放在**中断描述符表 (IDT - Interrupt Descriptor Table)** 中。CPU通过`IDTR`寄存器找到IDT。
*   **区别 (中断类别)**:
    *   **中断门 (Interrupt Gate)**: 当通过此门进入处理程序时，CPU硬件**自动清除`IF`标志位**，即**关中断**。
    *   **陷阱门 (Trap Gate)**: 进入处理程序时，**不改变`IF`标志位**。
*   **设计哲学**:
    *   **硬件中断**（如时钟、键盘）应该使用**中断门**。这可以防止在处理一个中断时，被同类型的另一个中断打断，造成堆栈溢出等问题（中断嵌套需要非常小心地手动管理）。
    *   **异常**（如缺页、除零）和**软件中断**(`INT n`)通常使用**陷阱门**。因为在处理一个异常时，允许响应更紧急的硬件中断是合理的。

#### **2.2 中断相关的`INT`和`IRETD`指令**

**中断/异常发生时的硬件执行流程:**

1.  CPU获取中断向量号`N`。
2.  CPU用`N`作为索引，在IDT中查找第`N`个门描述符。
3.  **权限检查**:
    *   对于软件中断`INT n`，检查 `CPL <= Gate DPL`。允许应用程序触发中断。
    *   对于硬件中断和异常，通常不检查CPL。
4.  **如果发生特权级提升 (Ring 3 -> Ring 0):**
    *   **堆栈切换**: 与调用门完全相同，使用TSS中的`SS0/ESP0`切换到内核堆栈。
    *   **压栈**: CPU依次将旧的`SS`, `ESP`, `EFLAGS`, `CS`, `EIP`压入**新的内核堆栈**。
    *   **（可选）压入错误码**: 某些异常（如缺页、通用保护）会由硬件额外压入一个错误码。
5.  **加载并跳转**:
    *   从门描述符中加载目标`CS`和`EIP`。
    *   如果使用的是中断门，清除`IF`标志位。
    *   `CPL`更新为0，开始执行中断处理程序。

**`IRETD` (Interrupt Return, 32-bit) 的硬件执行流程:** 这是从中断/异常处理程序返回的**唯一**指令。

1.  CPU执行权限检查。
2.  `IRETD`会从当前堆栈上依次弹出`EIP`, `CS`, `EFLAGS`。
3.  因为恢复的`CS`指向了Ring 3，CPU知道发生了特权级切换，于是会继续弹出`ESP`和`SS`，恢复用户堆栈。
4.  执行恢复到Ring 3。`EFLAGS`的恢复是关键，它**自动恢复了中断前的`IF`标志位状态**。

#### **2.3 中断门实例**

一个Ring 3程序通过`INT 80h`触发一个系统调用。

```
; --- IDT 定义 ---
                ; 假设IDT位于某处，IDTR已设置
                IDT_ENTRY_80H:
                    DW isr_offset_low      ; 目标偏移
                    DW GDT_RING0_CODE_SELECTOR
                    DB 0
                    DB 11101110b           ; Type=32bit TrapGate, S=0, DPL=3, P=1
                    DW isr_offset_high

                ; --- Ring 3 代码 ---
                INT 80h                     ; 触发中断

                ; --- Ring 0 中断服务程序 (ISR) ---
                isr_handler:
                    ; CPL=0, 运行在内核堆栈
                    ; 堆栈内容: [ESP]=EIP, [ESP+4]=CS, [ESP+8]=EFLAGS, ...
                    ; ... 处理系统调用 ...
                    IRETD                   ; 从中断返回
                
```