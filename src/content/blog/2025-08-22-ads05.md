---
title: "ads05:二项队列（Binomial Queue）"
description: ""
pubDate: "2025-08-22"
heroImage: ""
---

# ads05:二项队列（Binomial Queue）

（补档：将以前的ads笔记做修缮后上传）

### 第一部分：二项堆的基石 —— 二项树 (Binomial Tree)

要理解二项堆，我们必须首先理解它的基本组成部分：**二项树**。

**定义：** 二项树是一种递归定义的有序树，我们用 $B\_k$ 来表示一棵 $k$ 阶二项树。

*   **$B\_0$** 是一棵 **0 阶**二项树，它只有一个节点。
*   **$B\_k$** 是一棵 **$k$ 阶**二项树，它由两棵 $B\_{k-1}$（$k-1$ 阶二项树）连接而成。具体地，我们将其中一棵 $B\_{k-1}$ 的根节点，作为另一棵 $B\_{k-1}$ 根节点的最左边的孩子。

让我们来看一下前几阶二项树的样子：

graph TD subgraph B\_0 B0\_root(( )) end subgraph B\_1 B1\_root(( )) --- B1\_child(( )) end subgraph B\_2 B2\_root(( )) --- B2\_c1(( )) B2\_root --- B2\_c2(( )) B2\_c1 --- B2\_gc(( )) end subgraph B\_3 B3\_root(( )) --- B3\_c1(( )) B3\_root --- B3\_c2(( )) B3\_root --- B3\_c3(( )) B3\_c1 --- B3\_gc1\_1(( )) B3\_c1 --- B3\_gc1\_2(( )) B3\_gc1\_1 --- B3\_ggc(( )) B3\_c2 --- B3\_gc2\_1(( )) end subgraph B\_4 B4\_root(( )) --- B4\_c1(( )) B4\_root --- B4\_c2(( )) B4\_root --- B4\_c3(( )) B4\_root --- B4\_c4(( )) B4\_c1 --- B4\_gc1\_1(( )) B4\_c1 --- B4\_gc1\_2(( )) B4\_c1 --- B4\_gc1\_3(( )) B4\_c2 --- B4\_gc2\_1(( )) B4\_c2 --- B4\_gc2\_2(( )) B4\_c3 --- B4\_gc3\_1(( )) B4\_gc1\_1 --- B4\_ggc1\_1(( )) B4\_gc1\_1 --- B4\_ggc1\_2(( )) B4\_ggc1\_1 --- B4\_gggc(( )) B4\_gc1\_2 --- B4\_ggc1\_3(( )) B4\_gc2\_1 --- B4\_ggc2\_1(( )) end

观察这些树，我们可以发现一些非常重要的数学性质。这些性质不仅优美，而且是二项堆高效运作的理论基础。

#### 二项树的性质

对于一棵 $k$ 阶二项树 $B\_k$：

1.  **节点数**: $B\_k$ 恰好有 **$2^k$** 个节点。
    
    *   **证明 (数学归纳法):**
        *   **基础情况 ($k=0$):** $B\_0$ 有 1 个节点，$2^0 = 1$。成立。
        *   **归纳假设:** 假设 $B\_{k-1}$ 有 $2^{k-1}$ 个节点。
        *   **归纳证明:** $B\_k$ 由两棵 $B\_{k-1}$ 构成，因此其节点总数为 $2^{k-1} + 2^{k-1} = 2 \* 2^{k-1} = 2^k$。
        *   证毕。
2.  **树高**: $B\_k$ 的高度为 **$k$**。
    
    *   **证明 (数学归纳法):**
        *   **基础情况 ($k=0$):** $B\_0$ 的高度为 0。成立。
        *   **归纳假设:** 假设 $B\_{k-1}$ 的高度为 $k-1$。
        *   **归纳证明:** $B\_k$ 的根是由一棵 $B\_{k-1}$ 的根形成的，它的子树是一棵新的 $B\_{k-1}$。因此，$B\_k$ 的高度是 $B\_{k-1}$ 的高度加 1，即 $(k-1) + 1 = k$。
        *   证毕。
3.  **根的度数**: $B\_k$ 的根节点恰好有 **$k$** 个孩子。并且，这些孩子节点恰好是 $B\_{k-1}, B\_{k-2}, ..., B\_0$ 的根（从左到右）。
    
    *   **证明 (通过构造):**
        *   $B\_k$ 由两棵 $B\_{k-1}$ 构成，我们称之为 $T\_A$ 和 $T\_B$。假设 $T\_B$ 的根连接到 $T\_A$ 的根。
        *   $T\_A$ 的根原来有 $k-1$ 个孩子，它们是 $B\_{k-2}, ..., B\_0$ 的根。
        *   现在，$T\_B$ 的根成为 $T\_A$ 根的一个新孩子。$T\_B$ 本身是一棵 $B\_{k-1}$。
        *   因此，$B\_k$ 的根现在有 $(k-1) + 1 = k$ 个孩子，它们分别是 $B\_{k-1}, B\_{k-2}, ..., B\_0$ 的根。
        *   证毕。
4.  **深度的节点数 (核心性质)**: 在 $B\_k$ 中，深度为 $d$ 的节点数量为 **二项式系数 C(k, d)**，即 $k$ 中选 $d$ 的组合数。
    
    *   **为什么叫“二项树”？** 这就是名字的由来！$(a+b)^k$ 的二项式展开，其系数就与此有关。
    *   **证明 (数学归纳法):**
        *   令 $N(k, d)$ 为 $B\_k$ 在深度 $d$ 的节点数。
        *   **基础情况 ($k=0$):** $B\_0$ 在深度 0 有 1 个节点，$N(0, 0) = 1$。而 $C(0, 0) = 1$。成立。
        *   **归纳假设:** 假设对于 $B\_{k-1}$，其深度 $d$ 的节点数为 $N(k-1, d) = C(k-1, d)$。
        *   **归纳证明:** $B\_k$ 由两棵 $B\_{k-1}$（$T\_A$ 和 $T\_B$）构成。$B\_k$ 中深度为 $d$ 的节点来自两个部分：
            1.  来自 $T\_A$ 中深度为 $d$ 的节点。其数量为 $N(k-1, d)$。
            2.  来自 $T\_B$ 中深度为 $d-1$ 的节点（因为 $T\_B$ 的根被挂在了 $B\_k$ 的根下，深度增加了1）。其数量为 $N(k-1, d-1)$。
        *   因此，$N(k, d) = N(k-1, d) + N(k-1, d-1)$。
        *   根据帕斯卡恒等式（Pascal's Identity），我们知道 $C(k, d) = C(k-1, d) + C(k-1, d-1)$。
        *   所以，$N(k, d) = C(k, d)$。
        *   证毕。

* * *

### 第二部分：二项堆的结构

现在我们知道了二项树，那么二项堆是什么呢？

一个二项堆不是一棵树，而是一个由**二项树组成的森林**。

这个森林必须满足两个核心属性：

1.  **堆序属性 (Heap-Ordered):** 森林中的**每一棵**二项树都满足**最小堆**性质。即，每个节点的值都小于或等于其所有孩子节点的值。这也意味着每棵树的根节点是该树中的最小值。
2.  **结构属性 (Unique Structure):** 对于任意阶数 $k$，森林中**至多只有一棵** $B\_k$ 类型的二项树。

**关键思想：与二进制的深刻联系**

这个结构属性非常巧妙。它意味着一个包含 $N$ 个节点的二项堆的结构，是由 $N$ 的二进制表示唯一确定的！

假设 $N$ 的二进制表示为 $(...b\_k ... b\_1 b\_0)\_2$。 如果 $b\_k$ 位是 $1$，那么这个二项堆中就包含一棵 $B\_k$。 如果 $b\_k$ 位是 $0$，那么这个二项堆中就没有 $B\_k$。

**【示例】一个包含 13 个节点的二项堆**

1.  **计算:** $13$ 的二进制表示是 $1101\_2$。
2.  **分解:** $13 = 8 + 4 + 0 + 1 = 1_2^3 + 1_2^2 + 0_2^1 + 1_2^0$。
3.  **构建:** 这意味着这个二项堆由 $B\_3$ (8个节点), $B\_2$ (4个节点), 和 $B\_0$ (1个节点) 组成。它没有 $B\_1$。

假设我们有13个元素，它们可以构成如下的二项堆（注意，每棵树都满足最小堆性质）：

graph TD subgraph "Binomial Heap (Size 13)" subgraph B0 direction TB B0\_R((13)) end subgraph B2 direction TB B2\_R((23)) --> B2\_C1((51)) B2\_R --> B2\_C2((24)) B2\_C1 --> B2\_GC1((65)) end subgraph B3 direction TB B3\_R((12)) --> B3\_C1((21)) B3\_R --> B3\_C2((24)) B3\_R --> B3\_C3((14)) B3\_C1 --> B3\_GC1\_1((65)) B3\_C1 --> B3\_GC1\_2((26)) B3\_GC1\_2 --> B3\_GGC1((18)) B3\_C2 --> B3\_GC2\_1((16)) end end

_注意：$B\_1$ 是不存在的，用灰色表示其缺失的位置，以强调结构。_

graph TD subgraph "Structure for N=13 (Binary 1101)" direction LR subgraph B0 \[Exists\] B0\_Node((13)) end subgraph B1 \[Not Present\] B1\_Placeholder( ) style B1\_Placeholder fill:#eee,stroke:#999,stroke-width:2px,stroke-dasharray: 5 5 end subgraph B2 \[Exists\] B2\_R((23)) --> B2\_C1((51)) B2\_R --> B2\_C2((24)) B2\_C1 --> B2\_GC1((65)) end subgraph B3 \[Exists\] B3\_R((12)) --> B3\_C1((21)) B3\_R --> B3\_C2((24)) B3\_R --> B3\_C3((14)) B3\_C1 --> B3\_GC1\_1((65)) & B3\_GC1\_2((26)) B3\_GC1\_2 --> B3\_GGC1((18)) B3\_C2 --> B3\_GC2\_1((16)) end end

这个根节点的列表（13, 23, 12）是二项堆的核心，我们通常按树的阶数从小到大排序。

* * *

### 第三部分：核心操作

#### 1\. 查找最小值 (FindMin)

*   **原理:** 由于每棵二项树都满足最小堆性质，整个堆的最小值必然是森林中某棵树的根。
    
*   **实现:** 我们只需要遍历所有树的根节点，找到其中的最小值即可。
    
*   **复杂度:** 一个包含 $N$ 个节点的堆，最多有多少棵树？树的数量等于 $N$ 的二进制表示中 $1$ 的个数。当 $N = 2^k - 1$ 时，树的数量最多，为 $k$。因为 $k = \\lfloor \\log\_2 N\\rfloor$，所以根节点的数量是 $O(\\log N)$。因此，`FindMin` 的时间复杂度为 **$O(\\log N)$**。
    
*   **优化:** 我们可以像在斐波那契堆中一样，维护一个指向最小根节点的指针。这样，`FindMin` 操作就可以在 **$O(1)$** 时间内完成。不过，这个指针需要在执行 `Insert`, `Merge`, `DeleteMin` 等修改堆结构的操作时进行更新。
    

#### 2\. 合并 (Merge / Union)

这是二项堆的“杀手级应用”。合并两个二项堆 $H\_1$ 和 $H\_2$ 的过程，与二进制加法惊人地相似。

*   **思想:** 我们从 $k=0$ 开始，逐阶（就像二进制的每一位）处理。对于每一阶 $k$，我们可能会有来自 $H\_1$ 的 $B\_k$，来自 $H\_2$ 的 $B\_k$，以及从前一阶 $k-1$ 合并产生的“进位” $B\_k$。
*   **规则:** 在第 $k$ 阶，我们最多可能有三棵 $B\_k$。
    *   **0 棵 $B\_k$:** 什么都不做。
    *   **1 棵 $B\_k$:** 这棵树直接成为结果堆中的 $B\_k$。
    *   **2 棵 $B\_k$:** 将这两棵树合并成一棵 $B\_{k+1}$。这棵 $B\_{k+1}$ 成为到下一阶的“进位”。结果堆中没有 $B\_k$。
    *   **3 棵 $B\_k$:** 保留其中一棵作为结果堆中的 $B\_k$，另外两棵合并成一棵 $B\_{k+1}$，作为到下一阶的“进位”。

**【合并示例】** 合并 $H\_1$ (大小为 6) 和 $H\_2$ (大小为 7)。

*   $6 = (110)\_2$ -> $H\_1$ 有 $B\_2$ 和 $B\_1$。
*   $7 = (111)\_2$ -> $H\_2$ 有 $B\_2$, $B\_1$, 和 $B\_0$。
*   合并结果大小为 13，应该是 $(1101)\_2$ -> $B\_3$, $B\_2$, $B\_0$。

让我们模拟这个过程：

阶 (k)

H1

H2

Carry In

Sum (棵)

Result

Carry Out

**0**

无

B0

无

1

B0

无

**1**

B1

B1

无

2

无

B2

**2**

B2

B2

B2 (进位)

3

B2

B3

**3**

无

无

B3 (进位)

1

B3

无

最终结果包含 $B\_3$, $B\_2$, $B\_0$，与预期一致！

**合并两棵同阶树 `CombineTrees(T1, T2)`** 这是合并操作的基础。假设要合并两棵 $B\_k$。

1.  比较它们的根节点 `root1` 和 `root2` 的值。
2.  假设 `value(root1) <= value(root2)`。
3.  将 `T2` 变成 `T1` 的一个新孩子（通常是最左边的孩子）。
4.  结果是一棵 $B\_{k+1}$，其根是 `root1`。 这个操作是 **O(1)** 的。

**复杂度:** 合并过程需要遍历两个堆的根列表，其长度都是 $O(\\log N)$。每一步都是 $O(1)$ 的 `CombineTrees` 操作。因此，总的合并时间复杂度为 **$O(\\log N)$**。

#### 3\. 插入 (Insert)

*   **原理:** 插入一个新元素可以看作是**特殊情况的合并**。
*   **实现:**
    1.  创建一个只包含待插入新元素的二项堆（即一个 $B\_0$）。
    2.  将这个新堆与原有的堆进行合并。
*   **复杂度:**
    *   **最坏情况:** $O(\\log N)$。例如，向一个包含 $2^k - 1$ 个元素的堆（由 $B\_{k-1}, ..., B\_0$ 组成）插入一个元素。这会引发一连串的进位，直到形成一棵 $B\_k$。
    *   **均摊情况 (Amortized Analysis):** $O(1)$。

**【均摊分析】** 为什么插入的均摊时间是 $O(1)$？我们可以用两种方法来理解。

**方法一：聚合分析 (Aggregate Analysis)** 考虑连续 $N$ 次插入到一个空堆中。

*   第1次插入：1次操作 (创建 $B\_0$)
*   第2次插入：2次操作 (合并 $B\_0$ 和 $B\_0$ 成 $B\_1$)
*   第3次插入：1次操作 (添加 $B\_0$)
*   第4次插入：3次操作 (合并 $B\_0$, $B\_0$ -> $B\_1$；合并 $B\_1$, $B\_1$ -> $B\_2$) ... 总的来看，每次插入，元素 $i$ 的二进制表示的最低位是 $0$ 变成 $1$。如果第 $k$ 位是第一个 $0$，则会发生 $k$ 次合并。 在 $N$ 次插入中，$B\_0$ 合并了 $N/2$ 次，$B\_1$ 合并了 $N/4$ 次，$B\_2$ 合并了 $N/8$ 次... 总合并次数 = $N/2 + N/4 + N/8 + ... < N$。 所以 $N$ 次插入总共花费 $O(N)$ 的时间，平均每次就是 **$O(1)$**。

**方法二：势能法 (Potential Function Method)** 这是更严谨的证明。

*   定义**势能函数 $\\Phi(H)$** 为堆 $H$ 中树的数量。
*   第 $i$ 次操作的**实际成本**为 $C\_i$。
*   第 $i$ 次操作的**均摊成本**为 $a\_i = C\_i + \\Phi(H\_i) - \\Phi(H\_{i-1})$。
*   假设第 $i$ 次插入操作需要 $k$ 次 `CombineTrees` 操作。这意味着在插入前，堆中有 $B\_0, B\_1, ..., B\_{k-1}$。
    *   实际成本 $C\_i = k + 1$ (k 次合并，1 次创建新堆)。
    *   操作前树的数量 $\\Phi(H\_{i-1}) = k$。
    *   操作后，这些树合并成一棵 $B\_k$，树的数量 $\\Phi(H\_i) = 1$（假设堆中更高阶的树不受影响）。
    *   势能变化 $\\Delta \\Phi = \\Phi(H\_i) - \\Phi(H\_{i-1}) = 1 - k$。
    *   均摊成本 $a\_i = (k+1) + (1-k) = 2$。
*   因此，每次插入的均摊成本是一个常数 **$O(1)$**。

#### 4\. 删除最小值 (DeleteMin)

这是最复杂的操作，但逻辑清晰，可以分解为以下步骤：

1.  **找到最小根:** 遍历根列表，找到带有最小值的根。假设它属于 $B\_k$。 (复杂度: $O(\\log N)$)
2.  **分离:** 将这棵 $B\_k$ 从堆 $H$ 的森林中移除。剩下的树构成一个新的堆 $H'$。 (复杂度: $O(1)$)
3.  **拆解:** 移除 $B\_k$ 的根节点（这就是我们要返回的最小值）。它的 $k$ 个孩子，根据性质，恰好是 $B\_{k-1}, B\_{k-2}, ..., B\_0$ 的根。将这些孩子看作一个独立的二项堆 $H''$。 (复杂度: $O(\\log N)$ 来创建 $H''$ 的根列表)
4.  **合并:** 合并 $H'$ 和 $H''$。 (复杂度: $O(\\log N)$)

**【DeleteMin 示例】** 假设我们从之前大小为 13 的堆中删除最小值。

graph TD subgraph "H' (Heap after removing B3)" direction LR subgraph B0 B0\_R((13)) end subgraph B2 B2\_R((23)) --> B2\_C1((51)) B2\_R --> B2\_C2((24)) B2\_C1 --> B2\_GC1((65)) end end

1.  **FindMin:** 最小值为 12，在 $B\_3$ 的根上。
2.  **分离:**
    
    *   $H'$ 包含 $B\_2$ 和 $B\_0$。
    
    graph TD subgraph "H'' (from children of node 12)" direction LR %% B\_0 Tree from B\_3's children B0\_from\_B3((14)) %% B\_1 Tree from B\_3's children B1\_from\_B3\_R((24)) --> B1\_from\_B3\_C((16)) %% B\_2 Tree from B\_3's children B2\_from\_B3\_R((21)) --> B2\_from\_B3\_C1((65)) B2\_from\_B3\_R --> B2\_from\_B3\_C2((26)) B2\_from\_B3\_C2 --> B2\_from\_B3\_GC((18)) end
    
3.  **拆解:** 移除 12。$B\_3$ 的孩子是 $B\_2$, $B\_1$, $B\_0$ 的根。它们形成 $H''$。
    
    graph TD subgraph "H'' (Formed from children of min root 12)" direction LR subgraph "Child 1 (B2)" B2\_from\_B3\_R((21)) --> B2\_from\_B3\_C1((65)) B2\_from\_B3\_R --> B2\_from\_B3\_C2((26)) B2\_from\_B3\_C2 --> B2\_from\_B3\_GC((18)) end subgraph "Child 2 (B1)" B1\_from\_B3\_R((24)) --> B1\_from\_B3\_C((16)) end subgraph "Child 3 (B0)" B0\_from\_B3((14)) end end
    
4.  **合并:** 合并 $H'$ (大小 5) 和 $H''$ (大小 7)。结果是一个大小为 12 的新堆。$5 = (101)\_2$, $7 = (111)\_2$。$5+7=12 = (1100)\_2$。最终结果将包含 $B\_3$ 和 $B\_2$。

总复杂度为 **$O(\\log N)$**。

* * *

### 第四部分：实现细节与代码

要高效地实现二项堆，我们需要一个合适的节点表示。**左孩子-右兄弟表示法** 是一个绝佳的选择。

#### 数据结构定义 (C++)

```cpp
#include <vector>
#include <iostream>
#include <algorithm>
#include <climits>

// 节点结构
struct BinNode {
    int key;            // 节点的值
    int degree;         // 节点的度（即孩子的数量，等于其作为根的二项树的阶）
    BinNode* parent;    // 指向父节点
    BinNode* child;     // 指向最左边的孩子
    BinNode* sibling;   // 指向右边的兄弟

    BinNode(int k) : key(k), degree(0), parent(nullptr), child(nullptr), sibling(nullptr) {}
};

// 二项堆结构
class BinomialHeap {
private:
    BinNode* head; // 指向根链表的头部（最小阶数的树）
    
    // 内部辅助函数
    void link(BinNode* y, BinNode* z);
    BinNode* merge_lists(BinNode* h1, BinNode* h2);
    BinNode* union_heaps(BinNode* h1, BinNode* h2);
    void print_tree(BinNode* node, std::string indent, bool last);

public:
    BinomialHeap() : head(nullptr) {}
    ~BinomialHeap(); // 需要实现析构函数来释放内存

    bool isEmpty() const { return head == nullptr; }
    void insert(int key);
    int findMin() const;
    int extractMin();
    void merge(BinomialHeap& other);
    void print() const;
};
```

#### 关键操作实现

**1\. Link (对应 `CombineTrees`)** 将一棵树连接到另一棵树下，形成更高一阶的树。

```cpp
// 将 y 的根链接到 z 的根下，z 成为新根
void BinomialHeap::link(BinNode* y, BinNode* z) {
    y->parent = z;
    y->sibling = z->child;
    z->child = y;
    z->degree++;
}
```

**2\. Union (核心合并逻辑)** 模拟二进制加法，合并两个根链表。

```cpp
BinNode* BinomialHeap::union_heaps(BinNode* h1, BinNode* h2) {
    BinNode* new_head = merge_lists(h1, h2);
    if (new_head == nullptr) {
        return nullptr;
    }

    BinNode* prev_x = nullptr;
    BinNode* x = new_head;
    BinNode* next_x = x->sibling;

    while (next_x != nullptr) {
        if ((x->degree != next_x->degree) || 
            (next_x->sibling != nullptr && next_x->sibling->degree == x->degree)) {
            // Case 1 & 2: x 和 next_x 的度不同，或者后面还有一个同度的
            prev_x = x;
            x = next_x;
        } else {
            // Case 3 & 4: x 和 next_x 的度相同
            if (x->key <= next_x->key) { // x 成为根
                x->sibling = next_x->sibling;
                link(next_x, x);
            } else { // next_x 成为根
                if (prev_x == nullptr) {
                    new_head = next_x;
                } else {
                    prev_x->sibling = next_x;
                }
                link(x, next_x);
                x = next_x;
            }
        }
        next_x = x->sibling;
    }
    return new_head;
}

// 辅助函数: 合并两个按度排序的根链表
BinNode* BinomialHeap::merge_lists(BinNode* h1, BinNode* h2) {
    // ... 标准的合并两个有序链表的逻辑 ...
    if (!h1) return h2;
    if (!h2) return h1;

    BinNode* head;
    BinNode* tail;

    if (h1->degree <= h2->degree) {
        head = h1;
        h1 = h1->sibling;
    } else {
        head = h2;
        h2 = h2->sibling;
    }
    tail = head;

    while (h1 && h2) {
        if (h1->degree <= h2->degree) {
            tail->sibling = h1;
            h1 = h1->sibling;
        } else {
            tail->sibling = h2;
            h2 = h2->sibling;
        }
        tail = tail->sibling;
    }

    if (h1) {
        tail->sibling = h1;
    } else {
        tail->sibling = h2;
    }

    return head;
}
```

**3\. Insert** 创建一个单节点堆，然后合并。

```cpp
void BinomialHeap::insert(int key) {
    BinNode* new_node = new BinNode(key);
    head = union_heaps(head, new_node);
}
```

**4\. ExtractMin** 实现前面描述的四个步骤。

```cpp
int BinomialHeap::extractMin() {
    if (isEmpty()) {
        std::cerr << "Heap is empty!" << std::endl;
        return INT_MIN;
    }

    // 步骤 1: 找到最小根
    BinNode* min_node = head;
    BinNode* min_prev = nullptr;
    BinNode* current = head->sibling;
    BinNode* prev = head;
    
    while (current != nullptr) {
        if (current->key < min_node->key) {
            min_node = current;
            min_prev = prev;
        }
        prev = current;
        current = current->sibling;
    }

    // 步骤 2: 从根链表中移除最小节点
    if (min_prev == nullptr) { // 最小节点是头节点
        head = min_node->sibling;
    } else {
        min_prev->sibling = min_node->sibling;
    }

    // 步骤 3: 创建子树构成的新堆 H''
    BinNode* new_head = nullptr;
    BinNode* child = min_node->child;
    while (child != nullptr) {
        BinNode* next_child = child->sibling;
        child->sibling = new_head;
        child->parent = nullptr; // 子节点的父指针清空
        new_head = child;
        child = next_child;
    }
    // 注意：这里的 new_head 是一个反向的链表，需要翻转
    BinNode* reversed_head = nullptr;
    current = new_head;
    while(current != nullptr) {
        BinNode* next = current->sibling;
        current->sibling = reversed_head;
        reversed_head = current;
        current = next;
    }
    
    // 步骤 4: 合并 H' 和 H''
    head = union_heaps(head, reversed_head);

    int min_key = min_node->key;
    delete min_node;
    return min_key;
}
```

* * *

### 第五部分：总结与拓展

#### 性能对比

操作

二叉堆 (Binary Heap)

二项堆 (Binomial Heap)

斐波那契堆 (Fibonacci Heap)

**Insert**

$O(\\log N)$

**$O(1)$ (均摊)**, $O(\\log N)$

**$O(1)$**

**FindMin**

$O(1)$

$O(1)$ (带指针优化)

$O(1)$

**DeleteMin**

$O(\\log N)$

$O(\\log N)$

$O(\\log N)$ (均摊)

**Merge(Union)**

$O(N)$

**$O(\\log N)$**

**$O(1)$**

**DecreaseKey**

$O(\\log N)$

$O(\\log N)$

**$O(1)$ (均摊)**

**结论:**

*   二项堆在**合并**操作上完胜二叉堆。
*   它的 `Insert` 均摊性能也非常好。
*   虽然斐波那契堆在理论上更快，但其结构复杂，常数因子巨大，在实践中除非数据规模极大且 `DecreaseKey` 操作非常频繁，否则二项堆可能是更好的选择。

#### 应用场景

二项堆的 $O(\\log N)$ 合并特性使其非常适用于：

1.  **事件模拟系统:** 当需要将多个独立的事件队列合并成一个时。
2.  **实现其他高级算法:** 作为某些算法的内部组件，这些算法需要频繁地合并优先队列。
3.  **Dijkstra's & Prim's 算法:** 虽然斐波那契堆因其 $O(1)$ 的 `DecreaseKey` 而成为理论上的最佳选择，但二项堆的 $O(\\log N)$ `DecreaseKey`（通过上浮节点实现）也比二叉堆的实现更灵活，并且整体性能依然优秀。在需要合并图的场景下（例如，处理动态图），二项堆的优势会更加明显。