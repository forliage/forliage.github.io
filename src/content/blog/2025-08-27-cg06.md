---
title: "计算机图形学06:几何变换"
description: ""
pubDate: "2025-08-27"
heroImage: ""
---

# 计算机图形学06:几何变换

### **引言：变换即一切**

在计算机图形学中，**变换**无处不在。它至少有两种核心应用场景：

1.  **改变物体：** 对模型本身进行操作，改变它的大小、位置和朝向，例如，让一架飞机在场景中飞行。
2.  **改变坐标系：** 物体不动，而是移动和旋转我们观察它的“尺子”——坐标系。这在处理复杂的场景图和相机视图时至关重要。

幸运的是，由于所有三维模型最终都是由一系列**顶点**构成的，我们只需要学会如何变换一个点，就能变换整个世界。

### **1\. 基本的二维/三维变换**

我们先来了解几种最基础的变换类型。

#### **1.1 平移 (Translation)**

*   **目的：** 移动物体的位置。
*   **描述：** 将物体上的每个点 $(x, y, z)$ 沿着一个平移向量 $\\mathbf{T} = (T\_x, T\_y, T\_z)$ 进行移动。
*   **数学形式：** $x' = x + T\_x$ $y' = y + T\_y$ $z' = z + T\_z$
*   **属性：** 平移是一种**刚体变换 (Rigid Body Transformation)**，因为它只改变位置，不改变物体的形状、大小或朝向。

#### **1.2 缩放 (Scaling)**

*   **目的：** 改变物体的大小。
*   **描述：** 将物体上的每个点 $(x, y, z)$ 相对于**坐标原点**，在各个坐标轴方向上乘以一个缩放因子 $(S\_x, S\_y, S\_z)$。
*   **数学形式：** $x' = x \\cdot S\_x$ $y' = y \\cdot S\_y$ $z' = z \\cdot S\_z$
*   **属性：**
    *   如果 $S\_x = S\_y = S\_z$，则为**统一缩放 (Uniform Scaling)**，物体保持原有比例。
    *   否则为**非统一缩放 (Non-uniform Scaling)**，物体会被拉伸或压缩，导致形状改变。
    *   **关键点：** 标准的缩放操作是**相对于原点**进行的。如果一个物体不在原点，对其进行缩放不仅会改变它的大小，还会同时改变它的位置！

#### **1.3 旋转 (Rotation)**

*   **目的：** 改变物体的朝向。
*   **描述：** 将物体上的每个点 $(x, y, z)$ 围绕**某个旋转轴**旋转一定的角度 $\\theta$。
*   **数学形式 (以围绕Z轴旋转为例):** $x' = x \\cos\\theta - y \\sin\\theta$ $y' = x \\sin\\theta + y \\cos\\theta$ $z' = z$
*   **属性：** 旋转也是一种**刚体变换**。
*   **关键点：** 与缩放类似，标准的旋转操作也是\*\*相对于原点（或某个坐标轴）\*\*进行的。

### **2\. 统一的语言：矩阵表示法**

我们有三种不同的基本变换，它们的数学形式各不相同：平移是加法，缩放和旋转是乘法。这给处理带来了不便。我们能否找到一种统一的方式来表示所有这些变换呢？答案是**矩阵**。

*   **缩放矩阵 $S(S\_x, S\_y, S\_z)$:** $$\\begin{pmatrix} x' \\\\ y' \\\\ z' \\end{pmatrix} = \\begin{pmatrix} S\_x & 0 & 0 \\\\ 0 & S\_y & 0 \\\\ 0 & 0 & S\_z \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$$
    
*   **旋转矩阵 $R\_z(\\theta)$ (绕Z轴):** $$\\begin{pmatrix} x' \\\\ y' \\\\ z' \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$$
    

缩放和旋转都可以漂亮地表示为与顶点坐标向量的**矩阵乘法**。但是，平移呢？平移是向量加法，我们无法用一个3x3矩阵的乘法来表示 $P' = P + T$。

这个问题成为了一个巨大的障碍。如果我们不能统一表示平移，我们就无法将一系列复杂的变换（比如“先旋转再平移”）合并成一个单一的操作。这正是**齐次坐标 (Homogeneous Coordinates)** 登场解决的难题。

### **3\. 神奇的第四维：齐次坐标**

齐次坐标是计算机图形学中最优雅、最重要的数学技巧之一。

*   **核心思想：** 通过增加一个额外的维度（w分量），将n维空间中的问题映射到n+1维空间中去解决。
    
*   **表示法：**
    
    *   一个三维笛卡尔坐标点 $(x, y, z)$ 在齐次坐标中表示为 $(x, y, z, 1)$。
    *   一个三维笛卡尔坐标向量 $(x, y, z)$ 在齐次坐标中表示为 $(x, y, z, 0)$。
*   **从齐次坐标转换回笛卡尔坐标：**
    
    *   对于点 $(x, y, z, w)$ 且 $w \\neq 0$，其对应的三维笛卡尔坐标为 $(x/w, y/w, z/w)$。
    *   这意味着，在齐次坐标系中，$(1, 2, 3, 1)$ 和 $(2, 4, 6, 2)$ 表示的是同一个三维点。

**为什么w分量如此关键？**

*   **w=1代表点：** 点是有位置的，它可以被平移。
*   **w=0代表向量：** 向量只有方向和大小，没有位置，它不应该被平移。例如，一个指向北方的向量，无论你站在哪里，它都应该指向北方。

#### **使用齐次坐标统一变换**

引入齐次坐标后，我们使用4x4矩阵来进行变换。现在，奇迹发生了：**平移也可以表示为矩阵乘法了！**

*   **平移矩阵 $T(T\_x, T\_y, T\_z)$:** $$\\begin{pmatrix} x' \\\\ y' \\\\ z' \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 0 & T\_x \\\\ 0 & 1 & 0 & T\_y \\\\ 0 & 0 & 1 & T\_z \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{pmatrix}$$
    
    验证一下：$x' = 1 \\cdot x + 0 \\cdot y + 0 \\cdot z + T\_x \\cdot 1 = x + T\_x$。完全正确！
    
    再看看对向量（w=0）的作用： $$\\begin{pmatrix} v\_x' \\\\ v\_y' \\\\ v\_z' \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 0 & T\_x \\\\ 0 & 1 & 0 & T\_y \\\\ 0 & 0 & 1 & T\_z \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} v\_x \\\\ v\_y \\\\ v\_z \\\\ 0 \\end{pmatrix}$$
    
    验证一下：$v\_x' = v\_x, v\_y' = v\_y, v\_z' = v\_z$。向量果然没有被平移！
    

现在，平移、旋转、缩放都统一为了4x4矩阵的乘法。这是一个巨大的突破！

### **4\. 变换的组合 (Composition of Transformations)**

现实世界中的运动往往是复杂的，例如“让一个物体以自身的中心为轴旋转”。我们知道，标准的旋转是绕原点进行的。要实现这个效果，我们需要一个**复合变换 (Composite Transformation)**：

1.  **第一步：** 将物体平移，使其中心点与原点重合。 (矩阵 $T$)
2.  **第二步：** 执行标准的旋转操作。 (矩阵 $R$)
3.  **第三步：** 将物体平移回原来的位置。 (矩阵 $T^{-1}$)

由于所有变换都是矩阵，对一个点 $P$ 应用这一系列变换的过程就是： $$P' = T^{-1} (R (T P))$$

根据矩阵乘法的结合律，这等价于： $$P' = (T^{-1} R T) P$$

这意味着我们可以**预先计算**复合变换矩阵 $M = T^{-1} R T$。然后，我们只需要用这个单一的矩阵 $M$ 去乘以模型的所有顶点，就可以一步到位地完成整个复杂变换！

**这是现代图形管线的核心：** 无论你的变换序列有多长，最终都可以合并成一个单一的矩阵。GPU所做的，就是用这个最终的矩阵去高效地处理成千上万的顶点。

#### **变换的顺序至关重要！**

矩阵乘法**不满足交换律** ($AB \\neq BA$)。这意味着变换的顺序会极大地影响最终结果。

*   **先旋转，再平移：** 物体会围绕原点旋转，然后整个被移动到新的位置。
*   **先平移，再旋转：** 物体会先被移动到新的位置，然后围绕**新的原点**进行旋转，产生一种“公转”的效果。

**在OpenGL等遵循列主序矩阵的系统中，代码中的变换顺序与实际数学上的应用顺序是相反的。** 如果你写的代码是：

```
glTranslate(...);
glRotate(...);
drawObject();
```

那么一个顶点 $v$ 实际经历的变换是 $v' = (\\text{Translate Matrix} \\times \\text{Rotate Matrix}) \\times v$。即**代码中最后调用的变换最先作用于顶点**。

### **5\. OpenGL中的变换**

在（旧版）OpenGL中，变换是通过维护一个**当前变换矩阵 (Current Transformation Matrix, CTM)** 的状态机来实现的。

*   `glMatrixMode(mode)`: 选择要操作的矩阵，最常用的是 `GL_MODELVIEW` (模型视图矩阵)。
*   `glLoadIdentity()`: 将当前矩阵重置为单位矩阵。
*   `glTranslatef(x, y, z)`: 生成一个平移矩阵，并**右乘**到当前矩阵上。
*   `glRotatef(angle, x, y, z)`: 生成一个旋转矩阵，并**右乘**到当前矩阵上。
*   `glScalef(x, y, z)`: 生成一个缩放矩阵，并**右乘**到当前矩阵上。

**代码示例：绕任意轴旋转** 假设我们要将一个物体绕点 $P\_1(4, 5, 6)$，以向量 $(1, 2, 3)$ 为轴，旋转45度。 这个复合变换的数学表达是 $M = T\_{P1} R\_{45} T\_{-P1}$。 由于OpenGL的逆序特性，代码应该写成：

```
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
// 步骤3: 平移回来
glTranslatef(4.0, 5.0, 6.0); 
// 步骤2: 绕原点旋转
glRotatef(45.0, 1.0, 2.0, 3.0); 
// 步骤1: 平移到原点
glTranslatef(-4.0, -5.0, -6.0); 
// 在这里绘制的物体，就会应用上述复合变换
drawObject();
```

#### **矩阵堆栈 (Matrix Stack)**

在处理具有层级结构的模型（如一个身体，有大臂、小臂、手掌）时，我们需要一种方法来保存和恢复变换状态。OpenGL为此提供了**矩阵堆栈**。

*   `glPushMatrix()`: 将当前变换矩阵的副本压入堆栈顶部。
*   `glPopMatrix()`: 弹出堆栈顶部的矩阵，恢复它作为当前变换矩阵。

这使得我们可以轻松地实现场景图的遍历：

```
draw_robot() {
    // ... 绘制身体 ...
    glPushMatrix(); // 保存身体的变换状态
    
    // 应用针对大臂的变换 (相对于身体)
    glTranslate(...); 
    glRotate(...);
    draw_upper_arm();
    
    glPushMatrix(); // 保存大臂的变换状态
    
    // 应用针对小臂的变换 (相对于大臂)
    glTranslate(...);
    glRotate(...);
    draw_lower_arm();
    
    glPopMatrix(); // 恢复到大臂的坐标系
    
    glPopMatrix(); // 恢复到身体的坐标系
}
```