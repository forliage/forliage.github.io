---
title: "数据库系统设计08:并发控制(Concurrency Control)"
description: ""
pubDate: "2025-08-26"
heroImage: ""
---

# 数据库系统设计08:并发控制(Concurrency Control)

并发控制的**核心使命**就是：**设计一套协议 (Protocols)，在允许多个事务尽可能“交错”执行以提高并发度的同时，严格保证这种交错执行的结果，等价于某个串行执行的结果（即可串行化）。**

这就像是在指挥一场复杂的空中交通管制。我们希望飞机（事务）能够同时起飞降落，以最大化机场（数据库）的吞吐量，但我们又必须通过一套严格的规则（并发控制协议），确保它们绝不会在空中相撞（产生数据不一致）。

今天，我们将深入探索最主流的几种“空管”策略，主要聚焦于**基于锁 (Lock-based)** 的协议。我们将从最简单的锁开始，不断遭遇问题（如死锁、幻读），然后引入更复杂的机制（如两阶段锁、多粒度锁）来解决它们。这将是一次充满挑战，但收获巨大的旅程。

### **第一部分：两阶段封锁协议 (2PL)**

基于锁的并发控制是最古老、最直观，也是应用最广泛的技术。其基本思想是：**事务在访问任何数据项之前，必须先获得该数据项的“锁”，访问结束后再释放锁。**

#### **1.1 基础锁模式**

*   **共享锁 (Shared Lock / S-Lock):**
    *   也称为**读锁**。
    *   **规则:** 如果事务 $T$ 持有数据项 $Q$ 的S锁，那么 $T$ 可以**读取** $Q$，但不能**修改** $Q$。
    *   **兼容性:** 多个事务可以**同时**持有同一个数据项的S锁。S锁与S锁是兼容的。
*   **排他锁 (Exclusive Lock / X-Lock):**
    *   也称为**写锁**。
    *   **规则:** 如果事务 $T$ 持有数据项 $Q$ 的X锁，那么 $T$ 可以**读取并修改** $Q$。
    *   **兼容性:** 任何时候，最多只有一个事务能持有数据项 $Q$ 的X锁。X锁与任何其他锁（S锁或X锁）都**不兼容**。

**锁兼容性矩阵:**

已持有 \\ 请求

S (共享)

X (排他)

**S (共享)**

**Yes**

No

**X (排他)**

No

No

#### **1.2 随用随放的锁**

一个初学者可能会想：我需要读/写数据时就加锁，用完了就马上释放，这样并发度不是最高吗？

考虑转账事务 $T\_3$ (A->B) 和 $T\_4$ (查询A, B)：

1.  **$T\_3$: lock-x(B), read(B), B:=B-50, write(B), unlock(B)** _($T\_3$以为B用完了，提前释放了锁)_
2.  **$T\_4$: lock-s(A), read(A), unlock(A)**
3.  **$T\_4$: lock-s(B), read(B), unlock(B)** _($T\_4$此时读取了B的中间值)_
4.  **$T\_3$: lock-x(A), read(A), A:=A+50, write(A), unlock(A)**

*   **问题:** $T\_4$在$T\_3$的两次写操作之间读取了数据，看到了一个“A还没加钱，B已经扣钱”的**不一致**状态。这个调度显然不是可串行化的。
*   **根源:** **锁的过早释放** 破坏了事务的隔离性。

#### **1.3 两阶段封锁协议 (Two-Phase Locking, 2PL)**

为了解决上述问题，伟大的Jim Gray提出了里程碑式的**2PL协议**。它规定，每个事务的加锁和解锁过程必须分为两个**严格分开的阶段**：

1.  **增长阶段 (Growing Phase):** 事务**只能申请锁**，不能释放任何锁。
2.  **缩减阶段 (Shrinking Phase):** 事务**只能释放锁**，不能再申请任何新的锁。

**\[图示2PL的阶段\]**

```
      ▲
      |   (可以获取锁)
锁的数量 |   Growing Phase
      |  /
      ▼ /
      Lock Point
            \
             \ Shrinking Phase
              \ (只能释放锁)
               ▼
      ----------------------> 时间
```

*   **锁点 (Lock Point):** 事务获得其最后一个锁的那个时间点，标志着增长阶段的结束和缩减阶段的开始。

**2PL的黄金定理:** **任何遵守2PL协议的调度，都一定是冲突可串行化的。** 事务的等价串行顺序，就是由它们的**锁点 (Lock Point)** 顺序决定的。

#### **1.4 2PL的变体与现实世界的选择**

2PL虽然保证了可串行化，但它本身仍然存在问题。

*   **级联回滚 (Cascading Aborts):**
    *   **问题:** 在基本的2PL中，事务可以在缩减阶段释放锁，而此时事务本身可能还未提交。如果另一个事务获取了这个锁，读取了数据，而第一个事务随后中止了，就会引发级联回滚。
*   **解决方案：严格两阶段封锁 (Strict 2PL)**
    *   **规则:** 事务必须**持有其所有的排他锁 (X-Locks)**，直到它**提交或中止**。S锁可以在缩减阶段释放。
    *   **优点:** 避免了级联回滚。因为写操作的结果只在事务结束后才对外界可见。
*   **解决方案：强两阶段封锁 (Rigorous 2PL / Strong Strict 2PL)**
    *   **规则:** 事务必须**持有其所有的锁（包括S锁和X锁）**，直到它**提交或中止**。
    *   **优点:** 实现最简单，并且可以保证事务按其**提交的顺序**进行串行化。这是**绝大多数商业数据库实际采用的协议**。

#### **1.5 锁的实现：锁管理器与锁表**

*   **锁管理器 (Lock Manager):** 数据库中一个专门处理加锁、解锁请求的组件。
*   **锁表 (Lock Table):**
    *   一个内存中的哈希表，`key`是被锁的数据项标识（如`PageID`, `RowID`），`value`是一个包含了“谁持有锁”、“锁的模式”、“等待队列”等信息的复杂结构。
    *   当一个锁请求到来时，锁管理器查询锁表：
        *   如果数据项无锁，或请求的锁模式兼容，则授予锁。
        *   如果不兼容，则将该请求放入该数据项的等待队列中，事务阻塞。
    *   当一个事务释放锁时，锁管理器会从等待队列中唤醒一个或多个兼容的请求。

### **第二部分：多粒度锁协议 (MGL)**

到目前为止，我们假设锁是加在单个数据项（如一行记录）上的。但这并不总是最高效的。

#### **2.1 粒度的权衡**

*   **细粒度 (Fine Granularity)** (e.g., 行锁 Row-level lock):
    *   **优点:** **并发度高**。两个事务只要不访问同一行，就可以并行执行。
    *   **缺点:** **锁开销大**。如果一个事务要更新一整张表，它需要获取数百万个行锁，锁管理本身的开销会成为瓶颈。
*   **粗粒度 (Coarse Granularity)** (e.g., 表锁 Table-level lock):
    *   **优点:** **锁开销小**。一个事务更新全表，只需一个表锁。
    *   **缺点:** **并发度低**。只要有一个事务持有表锁，其他任何想访问该表的事务都必须等待。

我们需要一个机制，允许系统根据事务的需求，在不同粒度（如数据库、表、页、行）上进行加锁。

#### **2.2 多粒度锁协议 (Multiple Granularity Locking, MGL)**

MGL将数据项组织成一个**层次结构（树）**，例如： `Database -> Tables -> Pages -> Rows`

*   **规则:** 在这个层次结构上加锁，必须遵循自顶向下的原则。要在一个子节点上加锁，必须先在其所有祖先节点上持有某种形式的“意向锁”。
    
*   **意向锁 (Intention Locks):**
    
    *   **意向共享锁 (Intention Shared, IS):** 表明事务**意图**在下层节点请求**S锁**。
    *   **意向排他锁 (Intention Exclusive, IX):** 表明事务**意图**在下层节点请求**X锁**。
    *   **共享意向排他锁 (Shared with Intention Exclusive, SIX):**
        *   一个组合锁，比较特殊。它表示，当前事务要**读取整个子树**（持有S锁），并且**意图在子树的某些低层节点进行更新**（持有IX意向）。
        *   **典型场景:** `UPDATE table SET salary = salary * 1.1 WHERE age > 30`。这个查询需要读取表中的每一行来检查`age`（需要对表加S锁），但只会更新满足条件的行（需要在这些行上加X锁）。此时在表上加一个SIX锁是最高效的。
*   **MGL兼容性矩阵 (扩展版):**
    

已持有 \\ 请求

IS

IX

S

SIX

X

**IS**

**Y**

**Y**

**Y**

**Y**

N

**IX**

**Y**

**Y**

N

N

N

**S**

**Y**

N

**Y**

N

N

**SIX**

**Y**

N

N

N

N

**X**

N

N

N

N

N

*   **加锁流程示例 (`UPDATE a row`):**
    
    1.  请求对 `Database` 加 `IX` 锁。
    2.  请求对 `Table` 加 `IX` 锁。
    3.  请求对 `Page` 加 `IX` 锁。
    4.  请求对 `Row` 加 `X` 锁。
*   **解锁流程:** **自底向上**释放。
    

MGL通过引入意向锁，巧妙地解决了在层次结构中检查锁冲突的问题。例如，当一个事务想对整张表加X锁时，它只需要检查表节点是否有不兼容的锁即可。如果另一个事务正持有某行的S锁，那么它必然在表节点上持有一个IS锁，X锁请求会因为与IS锁冲突而被阻塞。无需去检查每一行。

### **第三部分：死锁 (Deadlocks)**

2PL协议虽然保证了可串行化，但它无法避免一个经典的问题——**死锁**。

#### **3.1 死锁的产生**

*   **定义:** 两个或多个事务，相互等待对方持有的资源（锁），形成一个**循环等待**，导致所有事务都无法继续执行。
    *   $T\_3$持有B的X锁，请求A的锁。
    *   $T\_4$持有A的S锁，请求B的锁。
    *   $T\_3$等待$T\_4$，$T\_4$等待$T\_3$，形成死锁。

#### **3.2 死锁处理的三种策略**

数据库系统通常采用以下三种策略之一来处理死锁。

##### **策略1：死锁预防 (Deadlock Prevention)**

*   **思想:** 在系统设计阶段，通过施加某些限制，从根本上**杜绝**死锁发生的可能性。
*   **方法:**
    1.  **预先声明 (Pre-declaration):** 事务在开始执行前，必须**一次性获取它所需的所有锁**。如果无法全部获取，则一个也不获取，等待。
        *   **缺点:** 很难预知所有需要的锁，并且会严重降低并发度。
    2.  **锁序 (Lock Ordering) / 图协议:**
        *   对所有可加锁的数据项定义一个**全局的线性顺序**（例如，按表名排序，再按主键排序）。
        *   **规则:** 所有事务必须**按照这个预定义的顺序**来申请锁。
        *   **优点:** 简单有效，绝对不会产生死锁（因为无法形成循环等待）。
        *   **缺点:** 强制的加锁顺序可能与业务逻辑的自然访问顺序不符，导致编程困难。

##### **策略2：死锁避免 (Deadlock Avoidance)**

*   **思想:** 系统在**授予每一个锁请求之前**，都会先进行“安全检查”，预测授予这个锁是否**可能**导致未来的死锁。如果可能，则不授予，让事务等待。
*   **方法:**
    *   **Wait-Die (等待-死亡):**
        *   基于事务的时间戳。$TS(T\_i)$表示事务$T\_i$的开始时间。假设$T\_i$请求一个由$T\_j$持有的锁。
        *   如果$TS(T\_i) < TS(T\_j)$ ($T\_i$是**老**事务)，则$T\_i$**等待**$T\_j$。
        *   如果$TS(T\_i) > TS(T\_j)$ ($T\_i$是**新**事务)，则$T\_i$**死亡** (回滚)。
    *   **Wound-Wait (伤害-等待):**
        *   如果$TS(T\_i) < TS(T\_j)$ ($T\_i$是**老**事务)，则$T\_i$**伤害**$T\_j$ (强制$T\_j$回滚并释放锁)，$T\_i$获取锁。
        *   如果$TS(T\_i) > TS(T\_j)$ ($T\_i$是**新**事务)，则$T\_i$**等待**$T\_j$。
    *   **优点:** 这两种方案都能有效避免死锁，并且不会产生饥饿（因为总是偏向于老事务）。

##### **策略3：死锁检测与恢复 (Deadlock Detection & Recovery)**

*   **思想:** **不预防也不避免，而是允许死锁发生**。系统有一个后台的“侦探”，定期检查是否存在死锁。如果发现，就采取行动打破它。这是**最常用**的策略。
*   **检测方法：等待图 (Waits-For Graph)**
    *   图的顶点是事务。
    *   如果事务$T\_i$正在等待$T\_j$释放锁，就在图中画一条边 $T\_i \\rightarrow T\_j$。
    *   **死锁存在的充要条件是：等待图中存在一个环。**
    *   死锁检测器就是定期地在等待图中**运行环检测算法**。
*   **恢复方法：打破循环**
    1.  **选择牺牲品 (Victim Selection):** 选择环中的一个或多个事务作为“牺牲品”，将其中止。选择标准通常是：回滚代价最小的、执行时间最短的、持有锁最少的等。
    2.  **回滚 (Rollback):**
        *   **完全回滚:** 中止整个牺牲品事务。
        *   **部分回滚:** 只回滚到足以打破死锁的那一步操作。

#### **3.4 幻读与解决方案**

*   **问题回顾 (幻读):** 一个事务$T\_1$执行范围查询，$T\_2$在$T\_1$的两次查询之间，插入了一条满足该范围的新记录。$T\_1$第二次查询时，会看到这条“幻影”记录。
*   **为什么行锁不够？** $T\_2$插入的是一条**全新的记录**，它不存在于$T\_1$第一次查询时，因此$T\_1$无法对一个“不存在”的行加锁。
*   **解决方案：**
    1.  **表锁:** 简单粗暴，直接锁住整张表，阻止任何插入。但并发度太差。
    2.  **谓词锁 (Predicate Locking):**
        *   对查询的`WHERE`条件本身加锁。例如，对`age > 20`这个谓词加锁。任何想插入`age > 20`的新记录的事务，都会被阻塞。
        *   **理论上完美，但实现开销极大**，商业数据库很少直接实现。
    3.  **索引范围锁 / Next-Key Locking (MySQL InnoDB的实现):**
        *   一个非常聪明的工程近似。
        *   它不是锁数据行，而是**锁索引中的范围**。当$T\_1$查询`age > 20`时，它会在`age`索引上，锁定所有`age > 20`的现有条目，以及**这些条目之间的“间隙” (Gaps)**，和最后一个条目到无穷大之间的间隙。
        *   当$T\_2$想插入一条`age = 25`的新记录时，它必须先在索引中插入这条记录，但它会发现`20`到下一个键之间的“间隙”已经被锁住了，于是只能等待。
        *   这有效地防止了幻读，同时提供了比表锁高得多的并发度。